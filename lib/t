./Analysis/.svn/text-base/AliasAnalysis.cpp.svn-base:      .paramHasAttr(0, Attributes::NoAlias);
./Analysis/.svn/text-base/CodeMetrics.cpp.svn-base:    !F->getFnAttributes().hasAttribute(Attributes::ReturnsTwice);
./Analysis/.svn/text-base/InlineCost.cpp.svn-base:      AlwaysInline(F.getFnAttributes().hasAttribute(Attributes::AlwaysInline)),
./Analysis/.svn/text-base/InlineCost.cpp.svn-base:      !F.getFnAttributes().hasAttribute(Attributes::ReturnsTwice)) {
./Analysis/.svn/text-base/InlineCost.cpp.svn-base:      Callee->getFnAttributes().hasAttribute(Attributes::NoInline) ||
./Analysis/.svn/text-base/MemoryBuiltins.cpp.svn-base:  return CS && CS.hasFnAttr(Attributes::NoAlias);
./Analysis/.svn/text-base/MemoryDependenceAnalysis.cpp.svn-base:        LI->getParent()->getParent()->getFnAttributes().
./Analysis/.svn/text-base/MemoryDependenceAnalysis.cpp.svn-base:          hasAttribute(Attributes::AddressSafety))
./Analysis/.svn/text-base/RegionPrinter.cpp.svn-base:  std::string getEdgeAttributes(RegionNode *srcNode,
./Analysis/CodeMetrics.cpp:    !F->getFnAttributes().hasAttribute(Attributes::ReturnsTwice);
./Analysis/AliasAnalysis.cpp:      .paramHasAttr(0, Attributes::NoAlias);
./Analysis/InlineCost.cpp:      AlwaysInline(F.getFnAttributes().hasAttribute(Attributes::AlwaysInline)),
./Analysis/InlineCost.cpp:      !F.getFnAttributes().hasAttribute(Attributes::ReturnsTwice)) {
./Analysis/InlineCost.cpp:      Callee->getFnAttributes().hasAttribute(Attributes::NoInline) ||
./Analysis/MemoryBuiltins.cpp:  return CS && CS.hasFnAttr(Attributes::NoAlias);
./Analysis/MemoryDependenceAnalysis.cpp:        LI->getParent()->getParent()->getFnAttributes().
./Analysis/MemoryDependenceAnalysis.cpp:          hasAttribute(Attributes::AddressSafety))
./Analysis/RegionPrinter.cpp:  std::string getEdgeAttributes(RegionNode *srcNode,
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_zeroext:         B.addAttribute(Attributes::ZExt); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_signext:         B.addAttribute(Attributes::SExt); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_inreg:           B.addAttribute(Attributes::InReg); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_sret:            B.addAttribute(Attributes::StructRet); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_noalias:         B.addAttribute(Attributes::NoAlias); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_nocapture:       B.addAttribute(Attributes::NoCapture); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_byval:           B.addAttribute(Attributes::ByVal); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_nest:            B.addAttribute(Attributes::Nest); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_noreturn:        B.addAttribute(Attributes::NoReturn); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_nounwind:        B.addAttribute(Attributes::NoUnwind); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_uwtable:         B.addAttribute(Attributes::UWTable); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_returns_twice:   B.addAttribute(Attributes::ReturnsTwice); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_noinline:        B.addAttribute(Attributes::NoInline); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_readnone:        B.addAttribute(Attributes::ReadNone); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_readonly:        B.addAttribute(Attributes::ReadOnly); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_inlinehint:      B.addAttribute(Attributes::InlineHint); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_alwaysinline:    B.addAttribute(Attributes::AlwaysInline); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_optsize:         B.addAttribute(Attributes::OptimizeForSize); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_ssp:             B.addAttribute(Attributes::StackProtect); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_sspreq:          B.addAttribute(Attributes::StackProtectReq); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_noredzone:       B.addAttribute(Attributes::NoRedZone); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_noimplicitfloat: B.addAttribute(Attributes::NoImplicitFloat); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_naked:           B.addAttribute(Attributes::Naked); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_nonlazybind:     B.addAttribute(Attributes::NonLazyBind); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    case lltok::kw_address_safety:  B.addAttribute(Attributes::AddressSafety); break;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:///    ::= Type OptionalAttributes Value OptionalAttributes
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    ArgList.push_back(ParamInfo(ArgLoc, V, Attributes::get(V->getContext(),
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:                              Attributes::get(ArgTy->getContext(),
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:                                Attributes::get(ArgTy->getContext(), Attrs),
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    if (ArgList[i].Attrs.hasAttributes())
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    FuncAttrs.removeAttribute(Attributes::Alignment);
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  SmallVector<AttributeWithIndex, 8> Attrs;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  if (RetAttrs.hasAttributes())
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:      AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:                              Attributes::get(RetType->getContext(),
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    if (ArgList[i].Attrs.hasAttributes())
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:      Attrs.push_back(AttributeWithIndex::get(i+1, ArgList[i].Attrs));
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  if (FuncAttrs.hasAttributes())
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:      AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:                              Attributes::get(RetType->getContext(),
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  if (PAL.getParamAttributes(1).hasAttribute(Attributes::StructRet) &&
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  Fn->setAttributes(PAL);
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  // Set up the Attributes for the function.
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  SmallVector<AttributeWithIndex, 8> Attrs;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  if (RetAttrs.hasAttributes())
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:      AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:                              Attributes::get(Callee->getContext(),
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    if (ArgList[i].Attrs.hasAttributes())
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:      Attrs.push_back(AttributeWithIndex::get(i+1, ArgList[i].Attrs));
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  if (FnAttrs.hasAttributes())
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:      AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:                              Attributes::get(Callee->getContext(),
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  // Finish off the Attributes and check them
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  II->setAttributes(PAL);
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  // Set up the Attributes for the function.
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  SmallVector<AttributeWithIndex, 8> Attrs;
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  if (RetAttrs.hasAttributes())
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:      AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:                              Attributes::get(Callee->getContext(),
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:    if (ArgList[i].Attrs.hasAttributes())
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:      Attrs.push_back(AttributeWithIndex::get(i+1, ArgList[i].Attrs));
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  if (FnAttrs.hasAttributes())
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:      AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:                              Attributes::get(Callee->getContext(),
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  // Finish off the Attributes and check them
./AsmParser/.svn/text-base/LLParser.cpp.svn-base:  CI->setAttributes(PAL);
./AsmParser/.svn/text-base/LLParser.h.svn-base:#include "llvm/Attributes.h"
./AsmParser/.svn/text-base/LLParser.h.svn-base:      Attributes Attrs;
./AsmParser/.svn/text-base/LLParser.h.svn-base:      ParamInfo(LocTy loc, Value *v, Attributes attrs)
./AsmParser/.svn/text-base/LLParser.h.svn-base:      Attributes Attrs;
./AsmParser/.svn/text-base/LLParser.h.svn-base:      ArgInfo(LocTy L, Type *ty, Attributes Attr, const std::string &N)
./AsmParser/LLParser.cpp:    case lltok::kw_zeroext:         B.addAttribute(Attributes::ZExt); break;
./AsmParser/LLParser.cpp:    case lltok::kw_signext:         B.addAttribute(Attributes::SExt); break;
./AsmParser/LLParser.cpp:    case lltok::kw_inreg:           B.addAttribute(Attributes::InReg); break;
./AsmParser/LLParser.cpp:    case lltok::kw_sret:            B.addAttribute(Attributes::StructRet); break;
./AsmParser/LLParser.cpp:    case lltok::kw_noalias:         B.addAttribute(Attributes::NoAlias); break;
./AsmParser/LLParser.cpp:    case lltok::kw_nocapture:       B.addAttribute(Attributes::NoCapture); break;
./AsmParser/LLParser.cpp:    case lltok::kw_byval:           B.addAttribute(Attributes::ByVal); break;
./AsmParser/LLParser.cpp:    case lltok::kw_nest:            B.addAttribute(Attributes::Nest); break;
./AsmParser/LLParser.cpp:    case lltok::kw_noreturn:        B.addAttribute(Attributes::NoReturn); break;
./AsmParser/LLParser.cpp:    case lltok::kw_nounwind:        B.addAttribute(Attributes::NoUnwind); break;
./AsmParser/LLParser.cpp:    case lltok::kw_uwtable:         B.addAttribute(Attributes::UWTable); break;
./AsmParser/LLParser.cpp:    case lltok::kw_returns_twice:   B.addAttribute(Attributes::ReturnsTwice); break;
./AsmParser/LLParser.cpp:    case lltok::kw_noinline:        B.addAttribute(Attributes::NoInline); break;
./AsmParser/LLParser.cpp:    case lltok::kw_readnone:        B.addAttribute(Attributes::ReadNone); break;
./AsmParser/LLParser.cpp:    case lltok::kw_readonly:        B.addAttribute(Attributes::ReadOnly); break;
./AsmParser/LLParser.cpp:    case lltok::kw_inlinehint:      B.addAttribute(Attributes::InlineHint); break;
./AsmParser/LLParser.cpp:    case lltok::kw_alwaysinline:    B.addAttribute(Attributes::AlwaysInline); break;
./AsmParser/LLParser.cpp:    case lltok::kw_optsize:         B.addAttribute(Attributes::OptimizeForSize); break;
./AsmParser/LLParser.cpp:    case lltok::kw_ssp:             B.addAttribute(Attributes::StackProtect); break;
./AsmParser/LLParser.cpp:    case lltok::kw_sspreq:          B.addAttribute(Attributes::StackProtectReq); break;
./AsmParser/LLParser.cpp:    case lltok::kw_noredzone:       B.addAttribute(Attributes::NoRedZone); break;
./AsmParser/LLParser.cpp:    case lltok::kw_noimplicitfloat: B.addAttribute(Attributes::NoImplicitFloat); break;
./AsmParser/LLParser.cpp:    case lltok::kw_naked:           B.addAttribute(Attributes::Naked); break;
./AsmParser/LLParser.cpp:    case lltok::kw_nonlazybind:     B.addAttribute(Attributes::NonLazyBind); break;
./AsmParser/LLParser.cpp:    case lltok::kw_address_safety:  B.addAttribute(Attributes::AddressSafety); break;
./AsmParser/LLParser.cpp:///    ::= Type OptionalAttributes Value OptionalAttributes
./AsmParser/LLParser.cpp:    ArgList.push_back(ParamInfo(ArgLoc, V, Attributes::get(V->getContext(),
./AsmParser/LLParser.cpp:                              Attributes::get(ArgTy->getContext(),
./AsmParser/LLParser.cpp:                                Attributes::get(ArgTy->getContext(), Attrs),
./AsmParser/LLParser.cpp:    if (ArgList[i].Attrs.hasAttributes())
./AsmParser/LLParser.cpp:    FuncAttrs.removeAttribute(Attributes::Alignment);
./AsmParser/LLParser.cpp:  SmallVector<AttributeWithIndex, 8> Attrs;
./AsmParser/LLParser.cpp:  if (RetAttrs.hasAttributes())
./AsmParser/LLParser.cpp:      AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./AsmParser/LLParser.cpp:                              Attributes::get(RetType->getContext(),
./AsmParser/LLParser.cpp:    if (ArgList[i].Attrs.hasAttributes())
./AsmParser/LLParser.cpp:      Attrs.push_back(AttributeWithIndex::get(i+1, ArgList[i].Attrs));
./AsmParser/LLParser.cpp:  if (FuncAttrs.hasAttributes())
./AsmParser/LLParser.cpp:      AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./AsmParser/LLParser.cpp:                              Attributes::get(RetType->getContext(),
./AsmParser/LLParser.cpp:  if (PAL.getParamAttributes(1).hasAttribute(Attributes::StructRet) &&
./AsmParser/LLParser.cpp:  Fn->setAttributes(PAL);
./AsmParser/LLParser.cpp:  // Set up the Attributes for the function.
./AsmParser/LLParser.cpp:  SmallVector<AttributeWithIndex, 8> Attrs;
./AsmParser/LLParser.cpp:  if (RetAttrs.hasAttributes())
./AsmParser/LLParser.cpp:      AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./AsmParser/LLParser.cpp:                              Attributes::get(Callee->getContext(),
./AsmParser/LLParser.cpp:    if (ArgList[i].Attrs.hasAttributes())
./AsmParser/LLParser.cpp:      Attrs.push_back(AttributeWithIndex::get(i+1, ArgList[i].Attrs));
./AsmParser/LLParser.cpp:  if (FnAttrs.hasAttributes())
./AsmParser/LLParser.cpp:      AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./AsmParser/LLParser.cpp:                              Attributes::get(Callee->getContext(),
./AsmParser/LLParser.cpp:  // Finish off the Attributes and check them
./AsmParser/LLParser.cpp:  II->setAttributes(PAL);
./AsmParser/LLParser.cpp:  // Set up the Attributes for the function.
./AsmParser/LLParser.cpp:  SmallVector<AttributeWithIndex, 8> Attrs;
./AsmParser/LLParser.cpp:  if (RetAttrs.hasAttributes())
./AsmParser/LLParser.cpp:      AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./AsmParser/LLParser.cpp:                              Attributes::get(Callee->getContext(),
./AsmParser/LLParser.cpp:    if (ArgList[i].Attrs.hasAttributes())
./AsmParser/LLParser.cpp:      Attrs.push_back(AttributeWithIndex::get(i+1, ArgList[i].Attrs));
./AsmParser/LLParser.cpp:  if (FnAttrs.hasAttributes())
./AsmParser/LLParser.cpp:      AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./AsmParser/LLParser.cpp:                              Attributes::get(Callee->getContext(),
./AsmParser/LLParser.cpp:  // Finish off the Attributes and check them
./AsmParser/LLParser.cpp:  CI->setAttributes(PAL);
./AsmParser/LLParser.h:#include "llvm/Attributes.h"
./AsmParser/LLParser.h:      Attributes Attrs;
./AsmParser/LLParser.h:      ParamInfo(LocTy loc, Value *v, Attributes attrs)
./AsmParser/LLParser.h:      Attributes Attrs;
./AsmParser/LLParser.h:      ArgInfo(LocTy L, Type *ty, Attributes Attr, const std::string &N)
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:  std::vector<AttrListPtr>().swap(MAttributes);
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:bool BitcodeReader::ParseAttributeBlock() {
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:  if (!MAttributes.empty())
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:  SmallVector<AttributeWithIndex, 8> Attrs;
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:        Attributes ReconstitutedAttr =
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:          Attributes::decodeLLVMAttributesForBitcode(Context, Record[i+1]);
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:        if (B.hasAttributes())
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:          Attrs.push_back(AttributeWithIndex::get(Record[i],
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:                                                  Attributes::get(Context, B)));
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:      MAttributes.push_back(AttrListPtr::get(Attrs));
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:        if (ParseAttributeBlock())
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:      Func->setAttributes(getAttributes(Record[4]));
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:      AttrListPtr PAL = getAttributes(Record[0]);
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:      cast<InvokeInst>(I)->setAttributes(PAL);
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:      AttrListPtr PAL = getAttributes(Record[0]);
./Bitcode/Reader/.svn/text-base/BitcodeReader.cpp.svn-base:      cast<CallInst>(I)->setAttributes(PAL);
./Bitcode/Reader/.svn/text-base/BitcodeReader.h.svn-base:#include "llvm/Attributes.h"
./Bitcode/Reader/.svn/text-base/BitcodeReader.h.svn-base:  /// MAttributes - The set of attributes by index.  Index zero in the
./Bitcode/Reader/.svn/text-base/BitcodeReader.h.svn-base:  std::vector<AttrListPtr> MAttributes;
./Bitcode/Reader/.svn/text-base/BitcodeReader.h.svn-base:  AttrListPtr getAttributes(unsigned i) const {
./Bitcode/Reader/.svn/text-base/BitcodeReader.h.svn-base:    if (i-1 < MAttributes.size())
./Bitcode/Reader/.svn/text-base/BitcodeReader.h.svn-base:      return MAttributes[i-1];
./Bitcode/Reader/.svn/text-base/BitcodeReader.h.svn-base:  bool ParseAttributeBlock();
./Bitcode/Reader/BitcodeReader.h:#include "llvm/Attributes.h"
./Bitcode/Reader/BitcodeReader.h:  /// MAttributes - The set of attributes by index.  Index zero in the
./Bitcode/Reader/BitcodeReader.h:  std::vector<AttrListPtr> MAttributes;
./Bitcode/Reader/BitcodeReader.h:  AttrListPtr getAttributes(unsigned i) const {
./Bitcode/Reader/BitcodeReader.h:    if (i-1 < MAttributes.size())
./Bitcode/Reader/BitcodeReader.h:      return MAttributes[i-1];
./Bitcode/Reader/BitcodeReader.h:  bool ParseAttributeBlock();
./Bitcode/Reader/BitcodeReader.cpp:  std::vector<AttrListPtr>().swap(MAttributes);
./Bitcode/Reader/BitcodeReader.cpp:bool BitcodeReader::ParseAttributeBlock() {
./Bitcode/Reader/BitcodeReader.cpp:  if (!MAttributes.empty())
./Bitcode/Reader/BitcodeReader.cpp:  SmallVector<AttributeWithIndex, 8> Attrs;
./Bitcode/Reader/BitcodeReader.cpp:        Attributes ReconstitutedAttr =
./Bitcode/Reader/BitcodeReader.cpp:          Attributes::decodeLLVMAttributesForBitcode(Context, Record[i+1]);
./Bitcode/Reader/BitcodeReader.cpp:        if (B.hasAttributes())
./Bitcode/Reader/BitcodeReader.cpp:          Attrs.push_back(AttributeWithIndex::get(Record[i],
./Bitcode/Reader/BitcodeReader.cpp:                                                  Attributes::get(Context, B)));
./Bitcode/Reader/BitcodeReader.cpp:      MAttributes.push_back(AttrListPtr::get(Attrs));
./Bitcode/Reader/BitcodeReader.cpp:        if (ParseAttributeBlock())
./Bitcode/Reader/BitcodeReader.cpp:      Func->setAttributes(getAttributes(Record[4]));
./Bitcode/Reader/BitcodeReader.cpp:      AttrListPtr PAL = getAttributes(Record[0]);
./Bitcode/Reader/BitcodeReader.cpp:      cast<InvokeInst>(I)->setAttributes(PAL);
./Bitcode/Reader/BitcodeReader.cpp:      AttrListPtr PAL = getAttributes(Record[0]);
./Bitcode/Reader/BitcodeReader.cpp:      cast<CallInst>(I)->setAttributes(PAL);
./Bitcode/Writer/.svn/text-base/BitcodeWriter.cpp.svn-base:static void WriteAttributeTable(const ValueEnumerator &VE,
./Bitcode/Writer/.svn/text-base/BitcodeWriter.cpp.svn-base:  const std::vector<AttrListPtr> &Attrs = VE.getAttributes();
./Bitcode/Writer/.svn/text-base/BitcodeWriter.cpp.svn-base:      const AttributeWithIndex &PAWI = A.getSlot(i);
./Bitcode/Writer/.svn/text-base/BitcodeWriter.cpp.svn-base:      Record.push_back(Attributes::encodeLLVMAttributesForBitcode(PAWI.Attrs));
./Bitcode/Writer/.svn/text-base/BitcodeWriter.cpp.svn-base:    Vals.push_back(VE.getAttributeID(F->getAttributes()));
./Bitcode/Writer/.svn/text-base/BitcodeWriter.cpp.svn-base:    Vals.push_back(VE.getAttributeID(II->getAttributes()));
./Bitcode/Writer/.svn/text-base/BitcodeWriter.cpp.svn-base:    Vals.push_back(VE.getAttributeID(CI.getAttributes()));
./Bitcode/Writer/.svn/text-base/BitcodeWriter.cpp.svn-base:  WriteAttributeTable(VE, Stream);
./Bitcode/Writer/.svn/text-base/ValueEnumerator.cpp.svn-base:    EnumerateAttributes(cast<Function>(I)->getAttributes());
./Bitcode/Writer/.svn/text-base/ValueEnumerator.cpp.svn-base:          EnumerateAttributes(CI->getAttributes());
./Bitcode/Writer/.svn/text-base/ValueEnumerator.cpp.svn-base:          EnumerateAttributes(II->getAttributes());
./Bitcode/Writer/.svn/text-base/ValueEnumerator.cpp.svn-base:void ValueEnumerator::EnumerateAttributes(const AttrListPtr &PAL) {
./Bitcode/Writer/.svn/text-base/ValueEnumerator.cpp.svn-base:  unsigned &Entry = AttributeMap[PAL.getRawPointer()];
./Bitcode/Writer/.svn/text-base/ValueEnumerator.cpp.svn-base:    Attributes.push_back(PAL);
./Bitcode/Writer/.svn/text-base/ValueEnumerator.cpp.svn-base:    Entry = Attributes.size();
./Bitcode/Writer/.svn/text-base/ValueEnumerator.cpp.svn-base:  EnumerateAttributes(F.getAttributes());
./Bitcode/Writer/.svn/text-base/ValueEnumerator.h.svn-base:#include "llvm/Attributes.h"
./Bitcode/Writer/.svn/text-base/ValueEnumerator.h.svn-base:  typedef DenseMap<void*, unsigned> AttributeMapType;
./Bitcode/Writer/.svn/text-base/ValueEnumerator.h.svn-base:  AttributeMapType AttributeMap;
./Bitcode/Writer/.svn/text-base/ValueEnumerator.h.svn-base:  std::vector<AttrListPtr> Attributes;
./Bitcode/Writer/.svn/text-base/ValueEnumerator.h.svn-base:  unsigned getAttributeID(const AttrListPtr &PAL) const {
./Bitcode/Writer/.svn/text-base/ValueEnumerator.h.svn-base:    AttributeMapType::const_iterator I = AttributeMap.find(PAL.getRawPointer());
./Bitcode/Writer/.svn/text-base/ValueEnumerator.h.svn-base:    assert(I != AttributeMap.end() && "Attribute not in ValueEnumerator!");
./Bitcode/Writer/.svn/text-base/ValueEnumerator.h.svn-base:  const std::vector<AttrListPtr> &getAttributes() const {
./Bitcode/Writer/.svn/text-base/ValueEnumerator.h.svn-base:    return Attributes;
./Bitcode/Writer/.svn/text-base/ValueEnumerator.h.svn-base:  void EnumerateAttributes(const AttrListPtr &PAL);
./Bitcode/Writer/ValueEnumerator.cpp:    EnumerateAttributes(cast<Function>(I)->getAttributes());
./Bitcode/Writer/ValueEnumerator.cpp:          EnumerateAttributes(CI->getAttributes());
./Bitcode/Writer/ValueEnumerator.cpp:          EnumerateAttributes(II->getAttributes());
./Bitcode/Writer/ValueEnumerator.cpp:void ValueEnumerator::EnumerateAttributes(const AttrListPtr &PAL) {
./Bitcode/Writer/ValueEnumerator.cpp:  unsigned &Entry = AttributeMap[PAL.getRawPointer()];
./Bitcode/Writer/ValueEnumerator.cpp:    Attributes.push_back(PAL);
./Bitcode/Writer/ValueEnumerator.cpp:    Entry = Attributes.size();
./Bitcode/Writer/ValueEnumerator.cpp:  EnumerateAttributes(F.getAttributes());
./Bitcode/Writer/ValueEnumerator.h:#include "llvm/Attributes.h"
./Bitcode/Writer/ValueEnumerator.h:  typedef DenseMap<void*, unsigned> AttributeMapType;
./Bitcode/Writer/ValueEnumerator.h:  AttributeMapType AttributeMap;
./Bitcode/Writer/ValueEnumerator.h:  std::vector<AttrListPtr> Attributes;
./Bitcode/Writer/ValueEnumerator.h:  unsigned getAttributeID(const AttrListPtr &PAL) const {
./Bitcode/Writer/ValueEnumerator.h:    AttributeMapType::const_iterator I = AttributeMap.find(PAL.getRawPointer());
./Bitcode/Writer/ValueEnumerator.h:    assert(I != AttributeMap.end() && "Attribute not in ValueEnumerator!");
./Bitcode/Writer/ValueEnumerator.h:  const std::vector<AttrListPtr> &getAttributes() const {
./Bitcode/Writer/ValueEnumerator.h:    return Attributes;
./Bitcode/Writer/ValueEnumerator.h:  void EnumerateAttributes(const AttrListPtr &PAL);
./Bitcode/Writer/BitcodeWriter.cpp:static void WriteAttributeTable(const ValueEnumerator &VE,
./Bitcode/Writer/BitcodeWriter.cpp:  const std::vector<AttrListPtr> &Attrs = VE.getAttributes();
./Bitcode/Writer/BitcodeWriter.cpp:      const AttributeWithIndex &PAWI = A.getSlot(i);
./Bitcode/Writer/BitcodeWriter.cpp:      Record.push_back(Attributes::encodeLLVMAttributesForBitcode(PAWI.Attrs));
./Bitcode/Writer/BitcodeWriter.cpp:    Vals.push_back(VE.getAttributeID(F->getAttributes()));
./Bitcode/Writer/BitcodeWriter.cpp:    Vals.push_back(VE.getAttributeID(II->getAttributes()));
./Bitcode/Writer/BitcodeWriter.cpp:    Vals.push_back(VE.getAttributeID(CI.getAttributes()));
./Bitcode/Writer/BitcodeWriter.cpp:  WriteAttributeTable(VE, Stream);
./CodeGen/.svn/text-base/Analysis.cpp.svn-base:bool llvm::isInTailCallPosition(ImmutableCallSite CS, Attributes CalleeRetAttr,
./CodeGen/.svn/text-base/Analysis.cpp.svn-base:  Attributes CallerRetAttr = F->getAttributes().getRetAttributes();
./CodeGen/.svn/text-base/Analysis.cpp.svn-base:  if (AttrBuilder(CalleeRetAttr).removeAttribute(Attributes::NoAlias) !=
./CodeGen/.svn/text-base/Analysis.cpp.svn-base:      AttrBuilder(CallerRetAttr).removeAttribute(Attributes::NoAlias))
./CodeGen/.svn/text-base/Analysis.cpp.svn-base:  if (CallerRetAttr.hasAttribute(Attributes::ZExt) ||
./CodeGen/.svn/text-base/Analysis.cpp.svn-base:      CallerRetAttr.hasAttribute(Attributes::SExt))
./CodeGen/.svn/text-base/Analysis.cpp.svn-base:  Attributes CallerRetAttr = F->getAttributes().getRetAttributes();
./CodeGen/.svn/text-base/Analysis.cpp.svn-base:      .removeAttribute(Attributes::NoAlias).hasAttributes())
./CodeGen/.svn/text-base/Analysis.cpp.svn-base:  if (CallerRetAttr.hasAttribute(Attributes::ZExt) ||
./CodeGen/.svn/text-base/Analysis.cpp.svn-base:      CallerRetAttr.hasAttribute(Attributes::SExt))
./CodeGen/.svn/text-base/BranchFolding.cpp.svn-base:      MF->getFunction()->getFnAttributes().
./CodeGen/.svn/text-base/BranchFolding.cpp.svn-base:        hasAttribute(Attributes::OptimizeForSize) &&
./CodeGen/.svn/text-base/CodePlacementOpt.cpp.svn-base:  if (F->getFnAttributes().hasAttribute(Attributes::OptimizeForSize))
./CodeGen/.svn/text-base/MachineBlockPlacement.cpp.svn-base:  if (F.getFunction()->getFnAttributes().
./CodeGen/.svn/text-base/MachineBlockPlacement.cpp.svn-base:        hasAttribute(Attributes::OptimizeForSize))
./CodeGen/.svn/text-base/MachineFunction.cpp.svn-base:  if (Fn->getFnAttributes().hasAttribute(Attributes::StackAlignment))
./CodeGen/.svn/text-base/MachineFunction.cpp.svn-base:    FrameInfo->ensureMaxAlignment(Fn->getAttributes().
./CodeGen/.svn/text-base/MachineFunction.cpp.svn-base:                                  getFnAttributes().getStackAlignment());
./CodeGen/.svn/text-base/MachineFunction.cpp.svn-base:  if (!Fn->getFnAttributes().hasAttribute(Attributes::OptimizeForSize))
./CodeGen/.svn/text-base/PrologEpilogInserter.cpp.svn-base:  if (!F->getFnAttributes().hasAttribute(Attributes::Naked))
./CodeGen/.svn/text-base/PrologEpilogInserter.cpp.svn-base:  if (!F->getFnAttributes().hasAttribute(Attributes::Naked))
./CodeGen/.svn/text-base/PrologEpilogInserter.cpp.svn-base:  if (Fn.getFunction()->getFnAttributes().hasAttribute(Attributes::Naked))
./CodeGen/.svn/text-base/ScheduleDAGPrinter.cpp.svn-base:    static std::string getEdgeAttributes(const SUnit *Node,
./CodeGen/.svn/text-base/ScheduleDAGPrinter.cpp.svn-base:    static std::string getNodeAttributes(const SUnit *N,
./CodeGen/.svn/text-base/ShadowStackGC.cpp.svn-base:          II->setAttributes(CI->getAttributes());
./CodeGen/.svn/text-base/StackProtector.cpp.svn-base:#include "llvm/Attributes.h"
./CodeGen/.svn/text-base/StackProtector.cpp.svn-base:  if (F->getFnAttributes().hasAttribute(Attributes::StackProtectReq))
./CodeGen/.svn/text-base/StackProtector.cpp.svn-base:  if (!F->getFnAttributes().hasAttribute(Attributes::StackProtect))
./CodeGen/.svn/text-base/TailDuplication.cpp.svn-base:      MF.getFunction()->getFnAttributes().
./CodeGen/.svn/text-base/TailDuplication.cpp.svn-base:        hasAttribute(Attributes::OptimizeForSize))
./CodeGen/.svn/text-base/TargetLoweringObjectFileImpl.cpp.svn-base:  Streamer.EmitSymbolAttribute(Label, MCSA_Hidden);
./CodeGen/.svn/text-base/TargetLoweringObjectFileImpl.cpp.svn-base:  Streamer.EmitSymbolAttribute(Label, MCSA_Weak);
./CodeGen/.svn/text-base/TargetLoweringObjectFileImpl.cpp.svn-base:  Streamer.EmitSymbolAttribute(Label, MCSA_ELF_TypeObject);
./CodeGen/.svn/text-base/TargetLoweringObjectFileImpl.cpp.svn-base:    TAA = S->getTypeAndAttributes();
./CodeGen/.svn/text-base/TargetLoweringObjectFileImpl.cpp.svn-base:  if (S->getTypeAndAttributes() != TAA || S->getStubSize() != StubSize) {
./CodeGen/AsmPrinter/.svn/text-base/ARMException.cpp.svn-base:      Asm->OutStreamer.EmitSymbolAttribute(PerSym, MCSA_Global);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:        OutStreamer.EmitSymbolAttribute(GVSym, MCSA_WeakDefinition);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:        OutStreamer.EmitSymbolAttribute(GVSym, MCSA_WeakDefAutoPrivate);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Weak);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_ELF_TypeObject);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Local);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(CurrentFnSym, MCSA_ELF_TypeFunction);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(Mang->getSymbol(I), MCSA_WeakReference);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(Mang->getSymbol(I), MCSA_WeakReference);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:        OutStreamer.EmitSymbolAttribute(Name, MCSA_Global);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:        OutStreamer.EmitSymbolAttribute(Name, MCSA_WeakReference);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(OutContext.GetOrCreateSymbol(Sym),
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(OutContext.GetOrCreateSymbol(Sym),
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(Mang->getSymbol(GV), MCSA_NoDeadStrip);
./CodeGen/AsmPrinter/.svn/text-base/AsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(Sym, Attr);
./CodeGen/AsmPrinter/.svn/text-base/DIE.cpp.svn-base:  ID.AddInteger(Attribute);
./CodeGen/AsmPrinter/.svn/text-base/DIE.cpp.svn-base:    AP->EmitULEB128(AttrData.getAttribute(),
./CodeGen/AsmPrinter/.svn/text-base/DIE.cpp.svn-base:                    dwarf::AttributeString(AttrData.getAttribute()));
./CodeGen/AsmPrinter/.svn/text-base/DIE.cpp.svn-base:      << dwarf::AttributeString(Data[i].getAttribute())
./CodeGen/AsmPrinter/.svn/text-base/DIE.cpp.svn-base:      O << dwarf::AttributeString(Data[i].getAttribute());
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:    /// Attribute - Dwarf attribute code.
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:    uint16_t Attribute;
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:    DIEAbbrevData(uint16_t A, uint16_t F) : Attribute(A), Form(F) {}
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:    uint16_t getAttribute() const { return Attribute; }
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:    /// AddAttribute - Adds another set of attribute information to the
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:    void AddAttribute(uint16_t Attribute, uint16_t Form) {
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:      Data.push_back(DIEAbbrevData(Attribute, Form));
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:    /// AddFirstAttribute - Adds a set of attribute information to the front
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:    void AddFirstAttribute(uint16_t Attribute, uint16_t Form) {
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:      Data.insert(Data.begin(), DIEAbbrevData(Attribute, Form));
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:    /// Attributes values.
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:    void addValue(unsigned Attribute, unsigned Form, DIEValue *Value) {
./CodeGen/AsmPrinter/.svn/text-base/DIE.h.svn-base:      Abbrev.AddAttribute(Attribute, Form);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:void CompileUnit::addFlag(DIE *Die, unsigned Attribute) {
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:    Die->addValue(Attribute, dwarf::DW_FORM_flag_present,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:    addUInt(Die, Attribute, dwarf::DW_FORM_flag, 1);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:void CompileUnit::addUInt(DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:  Die->addValue(Attribute, Form, Value);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:void CompileUnit::addSInt(DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:  Die->addValue(Attribute, Form, Value);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:void CompileUnit::addString(DIE *Die, unsigned Attribute, StringRef String) {
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:  Die->addValue(Attribute, dwarf::DW_FORM_strp, Value);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:void CompileUnit::addLabel(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:  Die->addValue(Attribute, Form, Value);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:void CompileUnit::addDelta(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:  Die->addValue(Attribute, Form, Value);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:void CompileUnit::addDIEEntry(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:  Die->addValue(Attribute, Form, createDIEEntry(Entry));
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:void CompileUnit::addBlock(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:  Die->addValue(Attribute, Block->BestForm(), Block);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:void CompileUnit::addAddress(DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:  addBlock(Die, Attribute, 0, Block);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:                                    unsigned Attribute,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:  addBlock(Die, Attribute, 0, Block);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:                                       unsigned Attribute,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:  addBlock(Die, Attribute, 0, Block);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:void CompileUnit::addType(DIE *Entity, DIType Ty, unsigned Attribute) {
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:    Entity->addValue(Attribute, dwarf::DW_FORM_ref4, Entry);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:  Entity->addValue(Attribute, dwarf::DW_FORM_ref4, Entry);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:        unsigned PropertyAttributes = 0;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_readonly;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_readwrite;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_assign;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_retain;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_copy;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_nonatomic;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:        if (PropertyAttributes)
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:                 PropertyAttributes);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:    unsigned PropertyAttributes = 0;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_readonly;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_readwrite;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_assign;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_retain;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_copy;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_nonatomic;
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:    if (PropertyAttributes)
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.cpp.svn-base:              PropertyAttributes);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addFlag(DIE *Die, unsigned Attribute);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addUInt(DIE *Die, unsigned Attribute, unsigned Form, uint64_t Integer);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addSInt(DIE *Die, unsigned Attribute, unsigned Form, int64_t Integer);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addString(DIE *Die, unsigned Attribute, const StringRef Str);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addLabel(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addDelta(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addDIEEntry(DIE *Die, unsigned Attribute, unsigned Form, DIE *Entry);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addBlock(DIE *Die, unsigned Attribute, unsigned Form, DIEBlock *Block);
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addAddress(DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addComplexAddress(DbgVariable *&DV, DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addBlockByrefAddress(DbgVariable *&DV, DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/.svn/text-base/DwarfCompileUnit.h.svn-base:  void addType(DIE *Entity, DIType Ty, unsigned Attribute = dwarf::DW_AT_type);
./CodeGen/AsmPrinter/.svn/text-base/DwarfDebug.cpp.svn-base:    unsigned Attr = AbbrevData[i].getAttribute();
./CodeGen/AsmPrinter/.svn/text-base/DwarfDebug.cpp.svn-base:      Asm->OutStreamer.AddComment(dwarf::AttributeString(Attr));
./CodeGen/AsmPrinter/.svn/text-base/DwarfDebug.h.svn-base:  // Attributes used to construct specific Dwarf sections.
./CodeGen/AsmPrinter/.svn/text-base/OcamlGCPrinter.cpp.svn-base:  AP.OutStreamer.EmitSymbolAttribute(Sym, MCSA_Global);
./CodeGen/AsmPrinter/ARMException.cpp:      Asm->OutStreamer.EmitSymbolAttribute(PerSym, MCSA_Global);
./CodeGen/AsmPrinter/DIE.cpp:  ID.AddInteger(Attribute);
./CodeGen/AsmPrinter/DIE.cpp:    AP->EmitULEB128(AttrData.getAttribute(),
./CodeGen/AsmPrinter/DIE.cpp:                    dwarf::AttributeString(AttrData.getAttribute()));
./CodeGen/AsmPrinter/DIE.cpp:      << dwarf::AttributeString(Data[i].getAttribute())
./CodeGen/AsmPrinter/DIE.cpp:      O << dwarf::AttributeString(Data[i].getAttribute());
./CodeGen/AsmPrinter/DIE.h:    /// Attribute - Dwarf attribute code.
./CodeGen/AsmPrinter/DIE.h:    uint16_t Attribute;
./CodeGen/AsmPrinter/DIE.h:    DIEAbbrevData(uint16_t A, uint16_t F) : Attribute(A), Form(F) {}
./CodeGen/AsmPrinter/DIE.h:    uint16_t getAttribute() const { return Attribute; }
./CodeGen/AsmPrinter/DIE.h:    /// AddAttribute - Adds another set of attribute information to the
./CodeGen/AsmPrinter/DIE.h:    void AddAttribute(uint16_t Attribute, uint16_t Form) {
./CodeGen/AsmPrinter/DIE.h:      Data.push_back(DIEAbbrevData(Attribute, Form));
./CodeGen/AsmPrinter/DIE.h:    /// AddFirstAttribute - Adds a set of attribute information to the front
./CodeGen/AsmPrinter/DIE.h:    void AddFirstAttribute(uint16_t Attribute, uint16_t Form) {
./CodeGen/AsmPrinter/DIE.h:      Data.insert(Data.begin(), DIEAbbrevData(Attribute, Form));
./CodeGen/AsmPrinter/DIE.h:    /// Attributes values.
./CodeGen/AsmPrinter/DIE.h:    void addValue(unsigned Attribute, unsigned Form, DIEValue *Value) {
./CodeGen/AsmPrinter/DIE.h:      Abbrev.AddAttribute(Attribute, Form);
./CodeGen/AsmPrinter/OcamlGCPrinter.cpp:  AP.OutStreamer.EmitSymbolAttribute(Sym, MCSA_Global);
./CodeGen/AsmPrinter/DwarfDebug.cpp:    unsigned Attr = AbbrevData[i].getAttribute();
./CodeGen/AsmPrinter/DwarfDebug.cpp:      Asm->OutStreamer.AddComment(dwarf::AttributeString(Attr));
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:void CompileUnit::addFlag(DIE *Die, unsigned Attribute) {
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:    Die->addValue(Attribute, dwarf::DW_FORM_flag_present,
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:    addUInt(Die, Attribute, dwarf::DW_FORM_flag, 1);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:void CompileUnit::addUInt(DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:  Die->addValue(Attribute, Form, Value);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:void CompileUnit::addSInt(DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:  Die->addValue(Attribute, Form, Value);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:void CompileUnit::addString(DIE *Die, unsigned Attribute, StringRef String) {
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:  Die->addValue(Attribute, dwarf::DW_FORM_strp, Value);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:void CompileUnit::addLabel(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:  Die->addValue(Attribute, Form, Value);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:void CompileUnit::addDelta(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:  Die->addValue(Attribute, Form, Value);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:void CompileUnit::addDIEEntry(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:  Die->addValue(Attribute, Form, createDIEEntry(Entry));
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:void CompileUnit::addBlock(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:  Die->addValue(Attribute, Block->BestForm(), Block);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:void CompileUnit::addAddress(DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:  addBlock(Die, Attribute, 0, Block);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:                                    unsigned Attribute,
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:  addBlock(Die, Attribute, 0, Block);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:                                       unsigned Attribute,
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:  addBlock(Die, Attribute, 0, Block);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:void CompileUnit::addType(DIE *Entity, DIType Ty, unsigned Attribute) {
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:    Entity->addValue(Attribute, dwarf::DW_FORM_ref4, Entry);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:  Entity->addValue(Attribute, dwarf::DW_FORM_ref4, Entry);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:        unsigned PropertyAttributes = 0;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_readonly;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_readwrite;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_assign;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_retain;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_copy;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:          PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_nonatomic;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:        if (PropertyAttributes)
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:                 PropertyAttributes);
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:    unsigned PropertyAttributes = 0;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_readonly;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_readwrite;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_assign;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_retain;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_copy;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:      PropertyAttributes |= dwarf::DW_APPLE_PROPERTY_nonatomic;
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:    if (PropertyAttributes)
./CodeGen/AsmPrinter/DwarfCompileUnit.cpp:              PropertyAttributes);
./CodeGen/AsmPrinter/DwarfDebug.h:  // Attributes used to construct specific Dwarf sections.
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addFlag(DIE *Die, unsigned Attribute);
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addUInt(DIE *Die, unsigned Attribute, unsigned Form, uint64_t Integer);
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addSInt(DIE *Die, unsigned Attribute, unsigned Form, int64_t Integer);
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addString(DIE *Die, unsigned Attribute, const StringRef Str);
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addLabel(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addDelta(DIE *Die, unsigned Attribute, unsigned Form,
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addDIEEntry(DIE *Die, unsigned Attribute, unsigned Form, DIE *Entry);
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addBlock(DIE *Die, unsigned Attribute, unsigned Form, DIEBlock *Block);
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addAddress(DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addComplexAddress(DbgVariable *&DV, DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addBlockByrefAddress(DbgVariable *&DV, DIE *Die, unsigned Attribute,
./CodeGen/AsmPrinter/DwarfCompileUnit.h:  void addType(DIE *Entity, DIType Ty, unsigned Attribute = dwarf::DW_AT_type);
./CodeGen/AsmPrinter/AsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
./CodeGen/AsmPrinter/AsmPrinter.cpp:        OutStreamer.EmitSymbolAttribute(GVSym, MCSA_WeakDefinition);
./CodeGen/AsmPrinter/AsmPrinter.cpp:        OutStreamer.EmitSymbolAttribute(GVSym, MCSA_WeakDefAutoPrivate);
./CodeGen/AsmPrinter/AsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
./CodeGen/AsmPrinter/AsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Weak);
./CodeGen/AsmPrinter/AsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
./CodeGen/AsmPrinter/AsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_ELF_TypeObject);
./CodeGen/AsmPrinter/AsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Local);
./CodeGen/AsmPrinter/AsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
./CodeGen/AsmPrinter/AsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(CurrentFnSym, MCSA_ELF_TypeFunction);
./CodeGen/AsmPrinter/AsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(Mang->getSymbol(I), MCSA_WeakReference);
./CodeGen/AsmPrinter/AsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(Mang->getSymbol(I), MCSA_WeakReference);
./CodeGen/AsmPrinter/AsmPrinter.cpp:        OutStreamer.EmitSymbolAttribute(Name, MCSA_Global);
./CodeGen/AsmPrinter/AsmPrinter.cpp:        OutStreamer.EmitSymbolAttribute(Name, MCSA_WeakReference);
./CodeGen/AsmPrinter/AsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(OutContext.GetOrCreateSymbol(Sym),
./CodeGen/AsmPrinter/AsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(OutContext.GetOrCreateSymbol(Sym),
./CodeGen/AsmPrinter/AsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(Mang->getSymbol(GV), MCSA_NoDeadStrip);
./CodeGen/AsmPrinter/AsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(Sym, Attr);
./CodeGen/SelectionDAG/.svn/text-base/FunctionLoweringInfo.cpp.svn-base:                Fn->getAttributes().getRetAttributes(), Outs, TLI);
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAG.cpp.svn-base:    MF.getFunction()->getFnAttributes().
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAG.cpp.svn-base:      hasAttribute(Attributes::OptimizeForSize);
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAG.cpp.svn-base:  bool OptSize = MF.getFunction()->getFnAttributes().
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAG.cpp.svn-base:    hasAttribute(Attributes::OptimizeForSize);
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAG.cpp.svn-base:  bool OptSize = MF.getFunction()->getFnAttributes().
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAG.cpp.svn-base:    hasAttribute(Attributes::OptimizeForSize);
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:        if (F->getRetAttributes().hasAttribute(Attributes::SExt))
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:        else if (F->getRetAttributes().hasAttribute(Attributes::ZExt))
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:        if (F->getRetAttributes().hasAttribute(Attributes::InReg))
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:    if (!F->getFnAttributes().hasAttribute(Attributes::OptimizeForSize) ||
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:  GetReturnInfo(RetTy, CS.getAttributes().getRetAttributes(),
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:    Entry.isSExt  = CS.paramHasAttr(attrInd, Attributes::SExt);
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:    Entry.isZExt  = CS.paramHasAttr(attrInd, Attributes::ZExt);
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:    Entry.isInReg = CS.paramHasAttr(attrInd, Attributes::InReg);
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:    Entry.isSRet  = CS.paramHasAttr(attrInd, Attributes::StructRet);
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:    Entry.isNest  = CS.paramHasAttr(attrInd, Attributes::Nest);
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:    Entry.isByVal = CS.paramHasAttr(attrInd, Attributes::ByVal);
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:      !isInTailCallPosition(CS, CS.getAttributes().getRetAttributes(), TLI))
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:  GetReturnInfo(F.getReturnType(), F.getAttributes().getRetAttributes(),
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::ZExt))
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::SExt))
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::InReg))
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::StructRet))
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::ByVal)) {
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::Nest))
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:        if (F.getParamAttributes(Idx).hasAttribute(Attributes::SExt))
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGBuilder.cpp.svn-base:        else if (F.getParamAttributes(Idx).hasAttribute(Attributes::ZExt))
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGPrinter.cpp.svn-base:    static std::string getEdgeAttributes(const void *Node, EdgeIter EI,
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGPrinter.cpp.svn-base:    static std::string getNodeAttributes(const SDNode *N,
./CodeGen/SelectionDAG/.svn/text-base/SelectionDAGPrinter.cpp.svn-base:/// Used from getNodeAttributes.
./CodeGen/SelectionDAG/.svn/text-base/TargetLowering.cpp.svn-base:void llvm::GetReturnInfo(Type* ReturnType, Attributes attr,
./CodeGen/SelectionDAG/.svn/text-base/TargetLowering.cpp.svn-base:    if (attr.hasAttribute(Attributes::SExt))
./CodeGen/SelectionDAG/.svn/text-base/TargetLowering.cpp.svn-base:    else if (attr.hasAttribute(Attributes::ZExt))
./CodeGen/SelectionDAG/.svn/text-base/TargetLowering.cpp.svn-base:    if (attr.hasAttribute(Attributes::InReg))
./CodeGen/SelectionDAG/.svn/text-base/TargetLowering.cpp.svn-base:    if (attr.hasAttribute(Attributes::SExt))
./CodeGen/SelectionDAG/.svn/text-base/TargetLowering.cpp.svn-base:    else if (attr.hasAttribute(Attributes::ZExt))
./CodeGen/SelectionDAG/TargetLowering.cpp:void llvm::GetReturnInfo(Type* ReturnType, Attributes attr,
./CodeGen/SelectionDAG/TargetLowering.cpp:    if (attr.hasAttribute(Attributes::SExt))
./CodeGen/SelectionDAG/TargetLowering.cpp:    else if (attr.hasAttribute(Attributes::ZExt))
./CodeGen/SelectionDAG/TargetLowering.cpp:    if (attr.hasAttribute(Attributes::InReg))
./CodeGen/SelectionDAG/TargetLowering.cpp:    if (attr.hasAttribute(Attributes::SExt))
./CodeGen/SelectionDAG/TargetLowering.cpp:    else if (attr.hasAttribute(Attributes::ZExt))
./CodeGen/SelectionDAG/SelectionDAG.cpp:    MF.getFunction()->getFnAttributes().
./CodeGen/SelectionDAG/SelectionDAG.cpp:      hasAttribute(Attributes::OptimizeForSize);
./CodeGen/SelectionDAG/SelectionDAG.cpp:  bool OptSize = MF.getFunction()->getFnAttributes().
./CodeGen/SelectionDAG/SelectionDAG.cpp:    hasAttribute(Attributes::OptimizeForSize);
./CodeGen/SelectionDAG/SelectionDAG.cpp:  bool OptSize = MF.getFunction()->getFnAttributes().
./CodeGen/SelectionDAG/SelectionDAG.cpp:    hasAttribute(Attributes::OptimizeForSize);
./CodeGen/SelectionDAG/SelectionDAGPrinter.cpp:    static std::string getEdgeAttributes(const void *Node, EdgeIter EI,
./CodeGen/SelectionDAG/SelectionDAGPrinter.cpp:    static std::string getNodeAttributes(const SDNode *N,
./CodeGen/SelectionDAG/SelectionDAGPrinter.cpp:/// Used from getNodeAttributes.
./CodeGen/SelectionDAG/FunctionLoweringInfo.cpp:                Fn->getAttributes().getRetAttributes(), Outs, TLI);
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:        if (F->getRetAttributes().hasAttribute(Attributes::SExt))
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:        else if (F->getRetAttributes().hasAttribute(Attributes::ZExt))
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:        if (F->getRetAttributes().hasAttribute(Attributes::InReg))
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:    if (!F->getFnAttributes().hasAttribute(Attributes::OptimizeForSize) ||
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:  GetReturnInfo(RetTy, CS.getAttributes().getRetAttributes(),
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:    Entry.isSExt  = CS.paramHasAttr(attrInd, Attributes::SExt);
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:    Entry.isZExt  = CS.paramHasAttr(attrInd, Attributes::ZExt);
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:    Entry.isInReg = CS.paramHasAttr(attrInd, Attributes::InReg);
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:    Entry.isSRet  = CS.paramHasAttr(attrInd, Attributes::StructRet);
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:    Entry.isNest  = CS.paramHasAttr(attrInd, Attributes::Nest);
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:    Entry.isByVal = CS.paramHasAttr(attrInd, Attributes::ByVal);
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:      !isInTailCallPosition(CS, CS.getAttributes().getRetAttributes(), TLI))
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:  GetReturnInfo(F.getReturnType(), F.getAttributes().getRetAttributes(),
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::ZExt))
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::SExt))
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::InReg))
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::StructRet))
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::ByVal)) {
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:      if (F.getParamAttributes(Idx).hasAttribute(Attributes::Nest))
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:        if (F.getParamAttributes(Idx).hasAttribute(Attributes::SExt))
./CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:        else if (F.getParamAttributes(Idx).hasAttribute(Attributes::ZExt))
./CodeGen/BranchFolding.cpp:      MF->getFunction()->getFnAttributes().
./CodeGen/BranchFolding.cpp:        hasAttribute(Attributes::OptimizeForSize) &&
./CodeGen/MachineBlockPlacement.cpp:  if (F.getFunction()->getFnAttributes().
./CodeGen/MachineBlockPlacement.cpp:        hasAttribute(Attributes::OptimizeForSize))
./CodeGen/PrologEpilogInserter.cpp:  if (!F->getFnAttributes().hasAttribute(Attributes::Naked))
./CodeGen/PrologEpilogInserter.cpp:  if (!F->getFnAttributes().hasAttribute(Attributes::Naked))
./CodeGen/PrologEpilogInserter.cpp:  if (Fn.getFunction()->getFnAttributes().hasAttribute(Attributes::Naked))
./CodeGen/TargetLoweringObjectFileImpl.cpp:  Streamer.EmitSymbolAttribute(Label, MCSA_Hidden);
./CodeGen/TargetLoweringObjectFileImpl.cpp:  Streamer.EmitSymbolAttribute(Label, MCSA_Weak);
./CodeGen/TargetLoweringObjectFileImpl.cpp:  Streamer.EmitSymbolAttribute(Label, MCSA_ELF_TypeObject);
./CodeGen/TargetLoweringObjectFileImpl.cpp:    TAA = S->getTypeAndAttributes();
./CodeGen/TargetLoweringObjectFileImpl.cpp:  if (S->getTypeAndAttributes() != TAA || S->getStubSize() != StubSize) {
./CodeGen/StackProtector.cpp:#include "llvm/Attributes.h"
./CodeGen/StackProtector.cpp:  if (F->getFnAttributes().hasAttribute(Attributes::StackProtectReq))
./CodeGen/StackProtector.cpp:  if (!F->getFnAttributes().hasAttribute(Attributes::StackProtect))
./CodeGen/MachineFunction.cpp:  if (Fn->getFnAttributes().hasAttribute(Attributes::StackAlignment))
./CodeGen/MachineFunction.cpp:    FrameInfo->ensureMaxAlignment(Fn->getAttributes().
./CodeGen/MachineFunction.cpp:                                  getFnAttributes().getStackAlignment());
./CodeGen/MachineFunction.cpp:  if (!Fn->getFnAttributes().hasAttribute(Attributes::OptimizeForSize))
./CodeGen/ShadowStackGC.cpp:          II->setAttributes(CI->getAttributes());
./CodeGen/CodePlacementOpt.cpp:  if (F->getFnAttributes().hasAttribute(Attributes::OptimizeForSize))
./CodeGen/ScheduleDAGPrinter.cpp:    static std::string getEdgeAttributes(const SUnit *Node,
./CodeGen/ScheduleDAGPrinter.cpp:    static std::string getNodeAttributes(const SUnit *N,
./CodeGen/Analysis.cpp:bool llvm::isInTailCallPosition(ImmutableCallSite CS, Attributes CalleeRetAttr,
./CodeGen/Analysis.cpp:  Attributes CallerRetAttr = F->getAttributes().getRetAttributes();
./CodeGen/Analysis.cpp:  if (AttrBuilder(CalleeRetAttr).removeAttribute(Attributes::NoAlias) !=
./CodeGen/Analysis.cpp:      AttrBuilder(CallerRetAttr).removeAttribute(Attributes::NoAlias))
./CodeGen/Analysis.cpp:  if (CallerRetAttr.hasAttribute(Attributes::ZExt) ||
./CodeGen/Analysis.cpp:      CallerRetAttr.hasAttribute(Attributes::SExt))
./CodeGen/Analysis.cpp:  Attributes CallerRetAttr = F->getAttributes().getRetAttributes();
./CodeGen/Analysis.cpp:      .removeAttribute(Attributes::NoAlias).hasAttributes())
./CodeGen/Analysis.cpp:  if (CallerRetAttr.hasAttribute(Attributes::ZExt) ||
./CodeGen/Analysis.cpp:      CallerRetAttr.hasAttribute(Attributes::SExt))
./CodeGen/TailDuplication.cpp:      MF.getFunction()->getFnAttributes().
./CodeGen/TailDuplication.cpp:        hasAttribute(Attributes::OptimizeForSize))
./cscope.out:/;" f class:llvm::AttributeListImpl
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.cpp.svn-base:  Attributes.clear();
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.cpp.svn-base:        Attributes.push_back(DWARFAttribute(attr, form));
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.cpp.svn-base:  for (unsigned i = 0, e = Attributes.size(); i != e; ++i) {
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.cpp.svn-base:    const char *attrString = AttributeString(Attributes[i].getAttribute());
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.cpp.svn-base:      OS << format("DW_AT_Unknown_%x", Attributes[i].getAttribute());
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.cpp.svn-base:    const char *formString = FormEncodingString(Attributes[i].getForm());
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.cpp.svn-base:      OS << format("DW_FORM_Unknown_%x", Attributes[i].getForm());
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.cpp.svn-base:DWARFAbbreviationDeclaration::findAttributeIndex(uint16_t attr) const {
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.cpp.svn-base:  for (uint32_t i = 0, e = Attributes.size(); i != e; ++i) {
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.cpp.svn-base:    if (Attributes[i].getAttribute() == attr)
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.h.svn-base:#include "DWARFAttribute.h"
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.h.svn-base:  SmallVector<DWARFAttribute, 8> Attributes;
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.h.svn-base:  uint32_t getNumAttributes() const { return Attributes.size(); }
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.h.svn-base:    return Attributes.size() > idx ? Attributes[idx].getAttribute() : 0;
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.h.svn-base:    return Attributes.size() > idx ? Attributes[idx].getForm() : 0;
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.h.svn-base:  uint32_t findAttributeIndex(uint16_t attr) const;
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.h.svn-base:  const SmallVectorImpl<DWARFAttribute> &getAttributes() const {
./DebugInfo/.svn/text-base/DWARFAbbreviationDeclaration.h.svn-base:    return Attributes;
./DebugInfo/.svn/text-base/DWARFAttribute.h.svn-base://===-- DWARFAttribute.h ----------------------------------------*- C++ -*-===//
./DebugInfo/.svn/text-base/DWARFAttribute.h.svn-base:class DWARFAttribute {
./DebugInfo/.svn/text-base/DWARFAttribute.h.svn-base:  uint16_t Attribute;
./DebugInfo/.svn/text-base/DWARFAttribute.h.svn-base:  DWARFAttribute(uint16_t attr, uint16_t form)
./DebugInfo/.svn/text-base/DWARFAttribute.h.svn-base:    : Attribute(attr), Form(form) {}
./DebugInfo/.svn/text-base/DWARFAttribute.h.svn-base:  uint16_t getAttribute() const { return Attribute; }
./DebugInfo/.svn/text-base/DWARFCompileUnit.cpp.svn-base:  return DieArray[0].getAttributeValueAsString(this, DW_AT_comp_dir, 0);
./DebugInfo/.svn/text-base/DWARFCompileUnit.cpp.svn-base:        die.getAttributeValueAsUnsigned(this, DW_AT_low_pc, -1U);
./DebugInfo/.svn/text-base/DWARFCompileUnit.cpp.svn-base:        base_addr = die.getAttributeValueAsUnsigned(this, DW_AT_entry_pc, 0);
./DebugInfo/.svn/text-base/DWARFContext.cpp.svn-base:      cu->getCompileUnitDIE()->getAttributeValueAsUnsigned(cu, DW_AT_stmt_list,
./DebugInfo/.svn/text-base/DWARFContext.cpp.svn-base:    cu->getCompileUnitDIE()->getAttributeValueAsUnsigned(cu, DW_AT_stmt_list,
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:        const uint32_t numAttributes = AbbrevDecl->getNumAttributes();
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:        for (uint32_t i = 0; i != numAttributes; ++i) {
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:          dumpAttribute(OS, cu, &offset, attr, form, indent);
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:void DWARFDebugInfoEntryMinimal::dumpAttribute(raw_ostream &OS,
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  const char *attrString = AttributeString(attr);
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:    const uint32_t numAttributes = AbbrevDecl->getNumAttributes();
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:    for (i=0; i<numAttributes; ++i) {
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:        const uint32_t numAttributes = AbbrevDecl->getNumAttributes();
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:        for (uint32_t i = 0; i != numAttributes; ++i) {
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:DWARFDebugInfoEntryMinimal::getAttributeValue(const DWARFCompileUnit *cu,
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:    uint32_t attr_idx = AbbrevDecl->findAttributeIndex(attr);
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:DWARFDebugInfoEntryMinimal::getAttributeValueAsString(
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  if (getAttributeValue(cu, attr, form_value)) {
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:DWARFDebugInfoEntryMinimal::getAttributeValueAsUnsigned(
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  if (getAttributeValue(cu, attr, form_value))
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:DWARFDebugInfoEntryMinimal::getAttributeValueAsSigned(
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  if (getAttributeValue(cu, attr, form_value))
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:DWARFDebugInfoEntryMinimal::getAttributeValueAsReference(
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  if (getAttributeValue(cu, attr, form_value))
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  LowPC = getAttributeValueAsUnsigned(CU, DW_AT_low_pc, -1ULL);
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:    HighPC = getAttributeValueAsUnsigned(CU, DW_AT_high_pc, -1ULL);
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  uint32_t RangesOffset = getAttributeValueAsReference(CU, DW_AT_ranges, -1U);
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:      getAttributeValueAsString(CU, DW_AT_MIPS_linkage_name, 0))
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  if (const char *name = getAttributeValueAsString(CU, DW_AT_linkage_name, 0))
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  if (const char *name = getAttributeValueAsString(CU, DW_AT_name, 0))
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:      getAttributeValueAsReference(CU, DW_AT_specification, -1U);
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:      getAttributeValueAsReference(CU, DW_AT_abstract_origin, -1U);
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  CallFile = getAttributeValueAsUnsigned(CU, DW_AT_call_file, 0);
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  CallLine = getAttributeValueAsUnsigned(CU, DW_AT_call_line, 0);
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.cpp.svn-base:  CallColumn = getAttributeValueAsUnsigned(CU, DW_AT_call_column, 0);
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.h.svn-base:  void dumpAttribute(raw_ostream &OS, const DWARFCompileUnit *cu,
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.h.svn-base:  uint32_t getNumAttributes() const {
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.h.svn-base:    return !isNULL() ? AbbrevDecl->getNumAttributes() : 0;
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.h.svn-base:  uint32_t getAttributeValue(const DWARFCompileUnit *cu,
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.h.svn-base:  const char* getAttributeValueAsString(const DWARFCompileUnit* cu,
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.h.svn-base:  uint64_t getAttributeValueAsUnsigned(const DWARFCompileUnit *cu,
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.h.svn-base:  uint64_t getAttributeValueAsReference(const DWARFCompileUnit *cu,
./DebugInfo/.svn/text-base/DWARFDebugInfoEntry.h.svn-base:  int64_t getAttributeValueAsSigned(const DWARFCompileUnit* cu,
./DebugInfo/.svn/entries:DWARFAttribute.h
./DebugInfo/DWARFAbbreviationDeclaration.cpp:  Attributes.clear();
./DebugInfo/DWARFAbbreviationDeclaration.cpp:        Attributes.push_back(DWARFAttribute(attr, form));
./DebugInfo/DWARFAbbreviationDeclaration.cpp:  for (unsigned i = 0, e = Attributes.size(); i != e; ++i) {
./DebugInfo/DWARFAbbreviationDeclaration.cpp:    const char *attrString = AttributeString(Attributes[i].getAttribute());
./DebugInfo/DWARFAbbreviationDeclaration.cpp:      OS << format("DW_AT_Unknown_%x", Attributes[i].getAttribute());
./DebugInfo/DWARFAbbreviationDeclaration.cpp:    const char *formString = FormEncodingString(Attributes[i].getForm());
./DebugInfo/DWARFAbbreviationDeclaration.cpp:      OS << format("DW_FORM_Unknown_%x", Attributes[i].getForm());
./DebugInfo/DWARFAbbreviationDeclaration.cpp:DWARFAbbreviationDeclaration::findAttributeIndex(uint16_t attr) const {
./DebugInfo/DWARFAbbreviationDeclaration.cpp:  for (uint32_t i = 0, e = Attributes.size(); i != e; ++i) {
./DebugInfo/DWARFAbbreviationDeclaration.cpp:    if (Attributes[i].getAttribute() == attr)
./DebugInfo/DWARFAbbreviationDeclaration.h:#include "DWARFAttribute.h"
./DebugInfo/DWARFAbbreviationDeclaration.h:  SmallVector<DWARFAttribute, 8> Attributes;
./DebugInfo/DWARFAbbreviationDeclaration.h:  uint32_t getNumAttributes() const { return Attributes.size(); }
./DebugInfo/DWARFAbbreviationDeclaration.h:    return Attributes.size() > idx ? Attributes[idx].getAttribute() : 0;
./DebugInfo/DWARFAbbreviationDeclaration.h:    return Attributes.size() > idx ? Attributes[idx].getForm() : 0;
./DebugInfo/DWARFAbbreviationDeclaration.h:  uint32_t findAttributeIndex(uint16_t attr) const;
./DebugInfo/DWARFAbbreviationDeclaration.h:  const SmallVectorImpl<DWARFAttribute> &getAttributes() const {
./DebugInfo/DWARFAbbreviationDeclaration.h:    return Attributes;
./DebugInfo/DWARFContext.cpp:      cu->getCompileUnitDIE()->getAttributeValueAsUnsigned(cu, DW_AT_stmt_list,
./DebugInfo/DWARFContext.cpp:    cu->getCompileUnitDIE()->getAttributeValueAsUnsigned(cu, DW_AT_stmt_list,
./DebugInfo/DWARFDebugInfoEntry.cpp:        const uint32_t numAttributes = AbbrevDecl->getNumAttributes();
./DebugInfo/DWARFDebugInfoEntry.cpp:        for (uint32_t i = 0; i != numAttributes; ++i) {
./DebugInfo/DWARFDebugInfoEntry.cpp:          dumpAttribute(OS, cu, &offset, attr, form, indent);
./DebugInfo/DWARFDebugInfoEntry.cpp:void DWARFDebugInfoEntryMinimal::dumpAttribute(raw_ostream &OS,
./DebugInfo/DWARFDebugInfoEntry.cpp:  const char *attrString = AttributeString(attr);
./DebugInfo/DWARFDebugInfoEntry.cpp:    const uint32_t numAttributes = AbbrevDecl->getNumAttributes();
./DebugInfo/DWARFDebugInfoEntry.cpp:    for (i=0; i<numAttributes; ++i) {
./DebugInfo/DWARFDebugInfoEntry.cpp:        const uint32_t numAttributes = AbbrevDecl->getNumAttributes();
./DebugInfo/DWARFDebugInfoEntry.cpp:        for (uint32_t i = 0; i != numAttributes; ++i) {
./DebugInfo/DWARFDebugInfoEntry.cpp:DWARFDebugInfoEntryMinimal::getAttributeValue(const DWARFCompileUnit *cu,
./DebugInfo/DWARFDebugInfoEntry.cpp:    uint32_t attr_idx = AbbrevDecl->findAttributeIndex(attr);
./DebugInfo/DWARFDebugInfoEntry.cpp:DWARFDebugInfoEntryMinimal::getAttributeValueAsString(
./DebugInfo/DWARFDebugInfoEntry.cpp:  if (getAttributeValue(cu, attr, form_value)) {
./DebugInfo/DWARFDebugInfoEntry.cpp:DWARFDebugInfoEntryMinimal::getAttributeValueAsUnsigned(
./DebugInfo/DWARFDebugInfoEntry.cpp:  if (getAttributeValue(cu, attr, form_value))
./DebugInfo/DWARFDebugInfoEntry.cpp:DWARFDebugInfoEntryMinimal::getAttributeValueAsSigned(
./DebugInfo/DWARFDebugInfoEntry.cpp:  if (getAttributeValue(cu, attr, form_value))
./DebugInfo/DWARFDebugInfoEntry.cpp:DWARFDebugInfoEntryMinimal::getAttributeValueAsReference(
./DebugInfo/DWARFDebugInfoEntry.cpp:  if (getAttributeValue(cu, attr, form_value))
./DebugInfo/DWARFDebugInfoEntry.cpp:  LowPC = getAttributeValueAsUnsigned(CU, DW_AT_low_pc, -1ULL);
./DebugInfo/DWARFDebugInfoEntry.cpp:    HighPC = getAttributeValueAsUnsigned(CU, DW_AT_high_pc, -1ULL);
./DebugInfo/DWARFDebugInfoEntry.cpp:  uint32_t RangesOffset = getAttributeValueAsReference(CU, DW_AT_ranges, -1U);
./DebugInfo/DWARFDebugInfoEntry.cpp:      getAttributeValueAsString(CU, DW_AT_MIPS_linkage_name, 0))
./DebugInfo/DWARFDebugInfoEntry.cpp:  if (const char *name = getAttributeValueAsString(CU, DW_AT_linkage_name, 0))
./DebugInfo/DWARFDebugInfoEntry.cpp:  if (const char *name = getAttributeValueAsString(CU, DW_AT_name, 0))
./DebugInfo/DWARFDebugInfoEntry.cpp:      getAttributeValueAsReference(CU, DW_AT_specification, -1U);
./DebugInfo/DWARFDebugInfoEntry.cpp:      getAttributeValueAsReference(CU, DW_AT_abstract_origin, -1U);
./DebugInfo/DWARFDebugInfoEntry.cpp:  CallFile = getAttributeValueAsUnsigned(CU, DW_AT_call_file, 0);
./DebugInfo/DWARFDebugInfoEntry.cpp:  CallLine = getAttributeValueAsUnsigned(CU, DW_AT_call_line, 0);
./DebugInfo/DWARFDebugInfoEntry.cpp:  CallColumn = getAttributeValueAsUnsigned(CU, DW_AT_call_column, 0);
./DebugInfo/DWARFCompileUnit.cpp:  return DieArray[0].getAttributeValueAsString(this, DW_AT_comp_dir, 0);
./DebugInfo/DWARFCompileUnit.cpp:        die.getAttributeValueAsUnsigned(this, DW_AT_low_pc, -1U);
./DebugInfo/DWARFCompileUnit.cpp:        base_addr = die.getAttributeValueAsUnsigned(this, DW_AT_entry_pc, 0);
./DebugInfo/DWARFDebugInfoEntry.h:  void dumpAttribute(raw_ostream &OS, const DWARFCompileUnit *cu,
./DebugInfo/DWARFDebugInfoEntry.h:  uint32_t getNumAttributes() const {
./DebugInfo/DWARFDebugInfoEntry.h:    return !isNULL() ? AbbrevDecl->getNumAttributes() : 0;
./DebugInfo/DWARFDebugInfoEntry.h:  uint32_t getAttributeValue(const DWARFCompileUnit *cu,
./DebugInfo/DWARFDebugInfoEntry.h:  const char* getAttributeValueAsString(const DWARFCompileUnit* cu,
./DebugInfo/DWARFDebugInfoEntry.h:  uint64_t getAttributeValueAsUnsigned(const DWARFCompileUnit *cu,
./DebugInfo/DWARFDebugInfoEntry.h:  uint64_t getAttributeValueAsReference(const DWARFCompileUnit *cu,
./DebugInfo/DWARFDebugInfoEntry.h:  int64_t getAttributeValueAsSigned(const DWARFCompileUnit* cu,
./DebugInfo/DWARFAttribute.h://===-- DWARFAttribute.h ----------------------------------------*- C++ -*-===//
./DebugInfo/DWARFAttribute.h:class DWARFAttribute {
./DebugInfo/DWARFAttribute.h:  uint16_t Attribute;
./DebugInfo/DWARFAttribute.h:  DWARFAttribute(uint16_t attr, uint16_t form)
./DebugInfo/DWARFAttribute.h:    : Attribute(attr), Form(form) {}
./DebugInfo/DWARFAttribute.h:  uint16_t getAttribute() const { return Attribute; }
./Linker/.svn/text-base/LinkModules.cpp.svn-base:/// copyGVAttributes - copy additional attributes (those not needed to construct
./Linker/.svn/text-base/LinkModules.cpp.svn-base:static void copyGVAttributes(GlobalValue *DestGV, const GlobalValue *SrcGV) {
./Linker/.svn/text-base/LinkModules.cpp.svn-base:  DestGV->copyAttributesFrom(SrcGV);
./Linker/.svn/text-base/LinkModules.cpp.svn-base:  copyGVAttributes(NG, DstGV);
./Linker/.svn/text-base/LinkModules.cpp.svn-base:  copyGVAttributes(NewDGV, SGV);
./Linker/.svn/text-base/LinkModules.cpp.svn-base:  copyGVAttributes(NewDF, SF);
./Linker/.svn/text-base/LinkModules.cpp.svn-base:  copyGVAttributes(NewDA, SGA);
./Linker/LinkModules.cpp:/// copyGVAttributes - copy additional attributes (those not needed to construct
./Linker/LinkModules.cpp:static void copyGVAttributes(GlobalValue *DestGV, const GlobalValue *SrcGV) {
./Linker/LinkModules.cpp:  DestGV->copyAttributesFrom(SrcGV);
./Linker/LinkModules.cpp:  copyGVAttributes(NG, DstGV);
./Linker/LinkModules.cpp:  copyGVAttributes(NewDGV, SGV);
./Linker/LinkModules.cpp:  copyGVAttributes(NewDF, SF);
./Linker/LinkModules.cpp:  copyGVAttributes(NewDA, SGA);
./MC/.svn/text-base/MCAsmStreamer.cpp.svn-base:  virtual void EmitEHSymAttributes(const MCSymbol *Symbol,
./MC/.svn/text-base/MCAsmStreamer.cpp.svn-base:  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute);
./MC/.svn/text-base/MCAsmStreamer.cpp.svn-base:void MCAsmStreamer::EmitEHSymAttributes(const MCSymbol *Symbol,
./MC/.svn/text-base/MCAsmStreamer.cpp.svn-base:    EmitSymbolAttribute(EHSymbol, MCSA_Global);
./MC/.svn/text-base/MCAsmStreamer.cpp.svn-base:    EmitSymbolAttribute(EHSymbol, MCSA_WeakDefinition);
./MC/.svn/text-base/MCAsmStreamer.cpp.svn-base:    EmitSymbolAttribute(EHSymbol, MCSA_PrivateExtern);
./MC/.svn/text-base/MCAsmStreamer.cpp.svn-base:void MCAsmStreamer::EmitSymbolAttribute(MCSymbol *Symbol,
./MC/.svn/text-base/MCAsmStreamer.cpp.svn-base:                                        MCSymbolAttr Attribute) {
./MC/.svn/text-base/MCAsmStreamer.cpp.svn-base:  switch (Attribute) {
./MC/.svn/text-base/MCAsmStreamer.cpp.svn-base:    switch (Attribute) {
./MC/.svn/text-base/MCContext.cpp.svn-base:                unsigned TypeAndAttributes,
./MC/.svn/text-base/MCContext.cpp.svn-base:  return Entry = new (*this) MCSectionMachO(Segment, Section, TypeAndAttributes,
./MC/.svn/text-base/MCDwarf.cpp.svn-base:    streamer.EmitEHSymAttributes(frame.Function, EHSym);
./MC/.svn/text-base/MCELFStreamer.cpp.svn-base:  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute);
./MC/.svn/text-base/MCELFStreamer.cpp.svn-base:void MCELFStreamer::EmitSymbolAttribute(MCSymbol *Symbol,
./MC/.svn/text-base/MCELFStreamer.cpp.svn-base:                                          MCSymbolAttr Attribute) {
./MC/.svn/text-base/MCELFStreamer.cpp.svn-base:  if (Attribute == MCSA_IndirectSymbol) {
./MC/.svn/text-base/MCELFStreamer.cpp.svn-base:  switch (Attribute) {
./MC/.svn/text-base/MCMachOStreamer.cpp.svn-base:  virtual void EmitEHSymAttributes(const MCSymbol *Symbol,
./MC/.svn/text-base/MCMachOStreamer.cpp.svn-base:  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute);
./MC/.svn/text-base/MCMachOStreamer.cpp.svn-base:void MCMachOStreamer::EmitEHSymAttributes(const MCSymbol *Symbol,
./MC/.svn/text-base/MCMachOStreamer.cpp.svn-base:    EmitSymbolAttribute(EHSymbol, MCSA_Global);
./MC/.svn/text-base/MCMachOStreamer.cpp.svn-base:    EmitSymbolAttribute(EHSymbol, MCSA_WeakDefinition);
./MC/.svn/text-base/MCMachOStreamer.cpp.svn-base:    EmitSymbolAttribute(EHSymbol, MCSA_PrivateExtern);
./MC/.svn/text-base/MCMachOStreamer.cpp.svn-base:void MCMachOStreamer::EmitSymbolAttribute(MCSymbol *Symbol,
./MC/.svn/text-base/MCMachOStreamer.cpp.svn-base:                                          MCSymbolAttr Attribute) {
./MC/.svn/text-base/MCMachOStreamer.cpp.svn-base:  if (Attribute == MCSA_IndirectSymbol) {
./MC/.svn/text-base/MCMachOStreamer.cpp.svn-base:  switch (Attribute) {
./MC/.svn/text-base/MCNullStreamer.cpp.svn-base:    virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute){}
./MC/.svn/text-base/MCPureStreamer.cpp.svn-base:  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute) {
./MC/.svn/text-base/MCSectionMachO.cpp.svn-base:  : MCSection(SV_MachO, K), TypeAndAttributes(TAA), Reserved2(reserved2) {
./MC/.svn/text-base/MCSectionMachO.cpp.svn-base:  unsigned TAA = getTypeAndAttributes();
./MC/.svn/text-base/MCSectionMachO.cpp.svn-base:  return hasAttribute(MCSectionMachO::S_ATTR_PURE_INSTRUCTIONS);
./MC/.svn/text-base/MCStreamer.cpp.svn-base:void MCStreamer::EmitEHSymAttributes(const MCSymbol *Symbol,
./MC/.svn/text-base/MachObjectWriter.cpp.svn-base:  unsigned Flags = Section.getTypeAndAttributes();
./MC/.svn/text-base/WinCOFFStreamer.cpp.svn-base:  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute);
./MC/.svn/text-base/WinCOFFStreamer.cpp.svn-base:void WinCOFFStreamer::EmitSymbolAttribute(MCSymbol *Symbol,
./MC/.svn/text-base/WinCOFFStreamer.cpp.svn-base:                                          MCSymbolAttr Attribute) {
./MC/.svn/text-base/WinCOFFStreamer.cpp.svn-base:  switch (Attribute) {
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:  /// ParseDirectiveSymbolAttribute - Parse a directive like ".globl" which
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:  bool ParseDirectiveSymbolAttribute(MCSymbolAttr Attr);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:      return ParseDirectiveSymbolAttribute(MCSA_Global);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:      return ParseDirectiveSymbolAttribute(MCSA_IndirectSymbol);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:      return ParseDirectiveSymbolAttribute(MCSA_LazyReference);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:      return ParseDirectiveSymbolAttribute(MCSA_NoDeadStrip);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:      return ParseDirectiveSymbolAttribute(MCSA_SymbolResolver);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:      return ParseDirectiveSymbolAttribute(MCSA_PrivateExtern);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:      return ParseDirectiveSymbolAttribute(MCSA_Reference);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:      return ParseDirectiveSymbolAttribute(MCSA_WeakDefinition);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:      return ParseDirectiveSymbolAttribute(MCSA_WeakReference);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:      return ParseDirectiveSymbolAttribute(MCSA_WeakDefAutoPrivate);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:    Out.EmitSymbolAttribute(Sym, MCSA_NoDeadStrip);
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:/// ParseDirectiveSymbolAttribute
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:bool AsmParser::ParseDirectiveSymbolAttribute(MCSymbolAttr Attr) {
./MC/MCParser/.svn/text-base/AsmParser.cpp.svn-base:      getStreamer().EmitSymbolAttribute(Sym, Attr);
./MC/MCParser/.svn/text-base/COFFAsmParser.cpp.svn-base:    AddDirectiveHandler<&COFFAsmParser::ParseDirectiveSymbolAttribute>(".weak");
./MC/MCParser/.svn/text-base/COFFAsmParser.cpp.svn-base:  bool ParseDirectiveSymbolAttribute(StringRef Directive, SMLoc);
./MC/MCParser/.svn/text-base/COFFAsmParser.cpp.svn-base:/// ParseDirectiveSymbolAttribute
./MC/MCParser/.svn/text-base/COFFAsmParser.cpp.svn-base:bool COFFAsmParser::ParseDirectiveSymbolAttribute(StringRef Directive, SMLoc) {
./MC/MCParser/.svn/text-base/COFFAsmParser.cpp.svn-base:      getStreamer().EmitSymbolAttribute(Sym, Attr);
./MC/MCParser/.svn/text-base/ELFAsmParser.cpp.svn-base:    AddDirectiveHandler<&ELFAsmParser::ParseDirectiveSymbolAttribute>(".weak");
./MC/MCParser/.svn/text-base/ELFAsmParser.cpp.svn-base:    AddDirectiveHandler<&ELFAsmParser::ParseDirectiveSymbolAttribute>(".local");
./MC/MCParser/.svn/text-base/ELFAsmParser.cpp.svn-base:      &ELFAsmParser::ParseDirectiveSymbolAttribute>(".protected");
./MC/MCParser/.svn/text-base/ELFAsmParser.cpp.svn-base:      &ELFAsmParser::ParseDirectiveSymbolAttribute>(".internal");
./MC/MCParser/.svn/text-base/ELFAsmParser.cpp.svn-base:      &ELFAsmParser::ParseDirectiveSymbolAttribute>(".hidden");
./MC/MCParser/.svn/text-base/ELFAsmParser.cpp.svn-base:  bool ParseDirectiveSymbolAttribute(StringRef, SMLoc);
./MC/MCParser/.svn/text-base/ELFAsmParser.cpp.svn-base:/// ParseDirectiveSymbolAttribute
./MC/MCParser/.svn/text-base/ELFAsmParser.cpp.svn-base:bool ELFAsmParser::ParseDirectiveSymbolAttribute(StringRef Directive, SMLoc) {
./MC/MCParser/.svn/text-base/ELFAsmParser.cpp.svn-base:      getStreamer().EmitSymbolAttribute(Sym, Attr);
./MC/MCParser/.svn/text-base/ELFAsmParser.cpp.svn-base:  getStreamer().EmitSymbolAttribute(Sym, Attr);
./MC/MCParser/ELFAsmParser.cpp:    AddDirectiveHandler<&ELFAsmParser::ParseDirectiveSymbolAttribute>(".weak");
./MC/MCParser/ELFAsmParser.cpp:    AddDirectiveHandler<&ELFAsmParser::ParseDirectiveSymbolAttribute>(".local");
./MC/MCParser/ELFAsmParser.cpp:      &ELFAsmParser::ParseDirectiveSymbolAttribute>(".protected");
./MC/MCParser/ELFAsmParser.cpp:      &ELFAsmParser::ParseDirectiveSymbolAttribute>(".internal");
./MC/MCParser/ELFAsmParser.cpp:      &ELFAsmParser::ParseDirectiveSymbolAttribute>(".hidden");
./MC/MCParser/ELFAsmParser.cpp:  bool ParseDirectiveSymbolAttribute(StringRef, SMLoc);
./MC/MCParser/ELFAsmParser.cpp:/// ParseDirectiveSymbolAttribute
./MC/MCParser/ELFAsmParser.cpp:bool ELFAsmParser::ParseDirectiveSymbolAttribute(StringRef Directive, SMLoc) {
./MC/MCParser/ELFAsmParser.cpp:      getStreamer().EmitSymbolAttribute(Sym, Attr);
./MC/MCParser/ELFAsmParser.cpp:  getStreamer().EmitSymbolAttribute(Sym, Attr);
./MC/MCParser/COFFAsmParser.cpp:    AddDirectiveHandler<&COFFAsmParser::ParseDirectiveSymbolAttribute>(".weak");
./MC/MCParser/COFFAsmParser.cpp:  bool ParseDirectiveSymbolAttribute(StringRef Directive, SMLoc);
./MC/MCParser/COFFAsmParser.cpp:/// ParseDirectiveSymbolAttribute
./MC/MCParser/COFFAsmParser.cpp:bool COFFAsmParser::ParseDirectiveSymbolAttribute(StringRef Directive, SMLoc) {
./MC/MCParser/COFFAsmParser.cpp:      getStreamer().EmitSymbolAttribute(Sym, Attr);
./MC/MCParser/AsmParser.cpp:  /// ParseDirectiveSymbolAttribute - Parse a directive like ".globl" which
./MC/MCParser/AsmParser.cpp:  bool ParseDirectiveSymbolAttribute(MCSymbolAttr Attr);
./MC/MCParser/AsmParser.cpp:      return ParseDirectiveSymbolAttribute(MCSA_Global);
./MC/MCParser/AsmParser.cpp:      return ParseDirectiveSymbolAttribute(MCSA_IndirectSymbol);
./MC/MCParser/AsmParser.cpp:      return ParseDirectiveSymbolAttribute(MCSA_LazyReference);
./MC/MCParser/AsmParser.cpp:      return ParseDirectiveSymbolAttribute(MCSA_NoDeadStrip);
./MC/MCParser/AsmParser.cpp:      return ParseDirectiveSymbolAttribute(MCSA_SymbolResolver);
./MC/MCParser/AsmParser.cpp:      return ParseDirectiveSymbolAttribute(MCSA_PrivateExtern);
./MC/MCParser/AsmParser.cpp:      return ParseDirectiveSymbolAttribute(MCSA_Reference);
./MC/MCParser/AsmParser.cpp:      return ParseDirectiveSymbolAttribute(MCSA_WeakDefinition);
./MC/MCParser/AsmParser.cpp:      return ParseDirectiveSymbolAttribute(MCSA_WeakReference);
./MC/MCParser/AsmParser.cpp:      return ParseDirectiveSymbolAttribute(MCSA_WeakDefAutoPrivate);
./MC/MCParser/AsmParser.cpp:    Out.EmitSymbolAttribute(Sym, MCSA_NoDeadStrip);
./MC/MCParser/AsmParser.cpp:/// ParseDirectiveSymbolAttribute
./MC/MCParser/AsmParser.cpp:bool AsmParser::ParseDirectiveSymbolAttribute(MCSymbolAttr Attr) {
./MC/MCParser/AsmParser.cpp:      getStreamer().EmitSymbolAttribute(Sym, Attr);
./MC/MCStreamer.cpp:void MCStreamer::EmitEHSymAttributes(const MCSymbol *Symbol,
./MC/MCAsmStreamer.cpp:  virtual void EmitEHSymAttributes(const MCSymbol *Symbol,
./MC/MCAsmStreamer.cpp:  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute);
./MC/MCAsmStreamer.cpp:void MCAsmStreamer::EmitEHSymAttributes(const MCSymbol *Symbol,
./MC/MCAsmStreamer.cpp:    EmitSymbolAttribute(EHSymbol, MCSA_Global);
./MC/MCAsmStreamer.cpp:    EmitSymbolAttribute(EHSymbol, MCSA_WeakDefinition);
./MC/MCAsmStreamer.cpp:    EmitSymbolAttribute(EHSymbol, MCSA_PrivateExtern);
./MC/MCAsmStreamer.cpp:void MCAsmStreamer::EmitSymbolAttribute(MCSymbol *Symbol,
./MC/MCAsmStreamer.cpp:                                        MCSymbolAttr Attribute) {
./MC/MCAsmStreamer.cpp:  switch (Attribute) {
./MC/MCAsmStreamer.cpp:    switch (Attribute) {
./MC/MCELFStreamer.cpp:  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute);
./MC/MCELFStreamer.cpp:void MCELFStreamer::EmitSymbolAttribute(MCSymbol *Symbol,
./MC/MCELFStreamer.cpp:                                          MCSymbolAttr Attribute) {
./MC/MCELFStreamer.cpp:  if (Attribute == MCSA_IndirectSymbol) {
./MC/MCELFStreamer.cpp:  switch (Attribute) {
./MC/MachObjectWriter.cpp:  unsigned Flags = Section.getTypeAndAttributes();
./MC/MCNullStreamer.cpp:    virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute){}
./MC/WinCOFFStreamer.cpp:  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute);
./MC/WinCOFFStreamer.cpp:void WinCOFFStreamer::EmitSymbolAttribute(MCSymbol *Symbol,
./MC/WinCOFFStreamer.cpp:                                          MCSymbolAttr Attribute) {
./MC/WinCOFFStreamer.cpp:  switch (Attribute) {
./MC/MCPureStreamer.cpp:  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute) {
./MC/MCContext.cpp:                unsigned TypeAndAttributes,
./MC/MCContext.cpp:  return Entry = new (*this) MCSectionMachO(Segment, Section, TypeAndAttributes,
./MC/MCMachOStreamer.cpp:  virtual void EmitEHSymAttributes(const MCSymbol *Symbol,
./MC/MCMachOStreamer.cpp:  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute);
./MC/MCMachOStreamer.cpp:void MCMachOStreamer::EmitEHSymAttributes(const MCSymbol *Symbol,
./MC/MCMachOStreamer.cpp:    EmitSymbolAttribute(EHSymbol, MCSA_Global);
./MC/MCMachOStreamer.cpp:    EmitSymbolAttribute(EHSymbol, MCSA_WeakDefinition);
./MC/MCMachOStreamer.cpp:    EmitSymbolAttribute(EHSymbol, MCSA_PrivateExtern);
./MC/MCMachOStreamer.cpp:void MCMachOStreamer::EmitSymbolAttribute(MCSymbol *Symbol,
./MC/MCMachOStreamer.cpp:                                          MCSymbolAttr Attribute) {
./MC/MCMachOStreamer.cpp:  if (Attribute == MCSA_IndirectSymbol) {
./MC/MCMachOStreamer.cpp:  switch (Attribute) {
./MC/MCDwarf.cpp:    streamer.EmitEHSymAttributes(frame.Function, EHSym);
./MC/MCSectionMachO.cpp:  : MCSection(SV_MachO, K), TypeAndAttributes(TAA), Reserved2(reserved2) {
./MC/MCSectionMachO.cpp:  unsigned TAA = getTypeAndAttributes();
./MC/MCSectionMachO.cpp:  return hasAttribute(MCSectionMachO::S_ATTR_PURE_INSTRUCTIONS);
./Support/.svn/text-base/Dwarf.cpp.svn-base:/// AttributeString - Return the string for the specified attribute.
./Support/.svn/text-base/Dwarf.cpp.svn-base:const char *llvm::dwarf::AttributeString(unsigned Attribute) {
./Support/.svn/text-base/Dwarf.cpp.svn-base:  switch (Attribute) {
./Support/.svn/text-base/Dwarf.cpp.svn-base:/// AttributeEncodingString - Return the string for the specified attribute
./Support/.svn/text-base/Dwarf.cpp.svn-base:const char *llvm::dwarf::AttributeEncodingString(unsigned Encoding) {
./Support/Windows/.svn/text-base/Path.inc.svn-base:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/.svn/text-base/Path.inc.svn-base:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/.svn/text-base/Path.inc.svn-base:  DWORD attributes = GetFileAttributes(path.c_str());
./Support/Windows/.svn/text-base/Path.inc.svn-base:    assert(0 && "GetFileAttributes returned INVALID_FILE_ATTRIBUTES");
./Support/Windows/.svn/text-base/Path.inc.svn-base:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/.svn/text-base/Path.inc.svn-base:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/.svn/text-base/Path.inc.svn-base:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/.svn/text-base/Path.inc.svn-base:    if (!GetFileAttributesEx(path.c_str(), GetFileExInfoStandard, &fi)) {
./Support/Windows/.svn/text-base/Path.inc.svn-base:    status.mode = fi.dwFileAttributes & FILE_ATTRIBUTE_READONLY ? 0555 : 0777;
./Support/Windows/.svn/text-base/Path.inc.svn-base:    status.isDir = fi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
./Support/Windows/.svn/text-base/Path.inc.svn-base:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/.svn/text-base/Path.inc.svn-base:    if (!SetFileAttributes(path.c_str(), attr & ~FILE_ATTRIBUTE_READONLY)) {
./Support/Windows/.svn/text-base/Path.inc.svn-base:  if (!GetFileAttributesEx(path.c_str(), GetFileExInfoStandard, &fi)) {
./Support/Windows/.svn/text-base/Path.inc.svn-base:  if (!(fi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
./Support/Windows/.svn/text-base/Path.inc.svn-base:  if (!GetFileAttributesEx(path.c_str(), GetFileExInfoStandard, &fi))
./Support/Windows/.svn/text-base/Path.inc.svn-base:  if (fi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
./Support/Windows/.svn/text-base/Path.inc.svn-base:    if (fi.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
./Support/Windows/.svn/text-base/Path.inc.svn-base:      if (!SetFileAttributes(path.c_str(),
./Support/Windows/.svn/text-base/Path.inc.svn-base:                             fi.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY))
./Support/Windows/.svn/text-base/Path.inc.svn-base:    if (bhfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
./Support/Windows/.svn/text-base/Path.inc.svn-base:      if (!SetFileAttributes(path.c_str(),
./Support/Windows/.svn/text-base/Path.inc.svn-base:              bhfi.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY))
./Support/Windows/.svn/text-base/Path.inc.svn-base:        return MakeErrMsg(ErrMsg, path + ": SetFileAttributes: ");
./Support/Windows/.svn/text-base/Path.inc.svn-base:    if (!(bhfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY)) {
./Support/Windows/.svn/text-base/Path.inc.svn-base:      if (!SetFileAttributes(path.c_str(),
./Support/Windows/.svn/text-base/Path.inc.svn-base:              bhfi.dwFileAttributes | FILE_ATTRIBUTE_READONLY))
./Support/Windows/.svn/text-base/Path.inc.svn-base:        return MakeErrMsg(ErrMsg, path + ": SetFileAttributes: ");
./Support/Windows/.svn/text-base/PathV2.inc.svn-base:  DWORD attributes = ::GetFileAttributesW(path_utf16.begin());
./Support/Windows/.svn/text-base/PathV2.inc.svn-base:  if (!::GetFileAttributesExW(path_utf16.begin(),
./Support/Windows/.svn/text-base/PathV2.inc.svn-base:  DWORD attr = ::GetFileAttributesW(path_utf16.begin());
./Support/Windows/.svn/text-base/PathV2.inc.svn-base:                    0, // Attributes only.
./Support/Windows/.svn/text-base/PathV2.inc.svn-base:                    0, // Attributes only.
./Support/Windows/.svn/text-base/PathV2.inc.svn-base:  DWORD attributes = ::GetFileAttributesW(path_utf16.begin());
./Support/Windows/.svn/text-base/PathV2.inc.svn-base:  if ( ! ::SetFileAttributesW(path_utf16.begin(), attributes))
./Support/Windows/.svn/text-base/Process.inc.svn-base:        return csbi.wAttributes;
./Support/Windows/.svn/text-base/Process.inc.svn-base:  SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), colors);
./Support/Windows/.svn/text-base/Process.inc.svn-base:  SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), colors);
./Support/Windows/.svn/text-base/Process.inc.svn-base:static WORD GetConsoleTextAttribute(HANDLE hConsoleOutput) {
./Support/Windows/.svn/text-base/Process.inc.svn-base:  return info.wAttributes;
./Support/Windows/.svn/text-base/Process.inc.svn-base:   = GetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE));
./Support/Windows/.svn/text-base/Process.inc.svn-base:  SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), new_attributes);
./Support/Windows/.svn/text-base/Process.inc.svn-base:  SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), defaultColors());
./Support/Windows/Path.inc:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/Path.inc:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/Path.inc:  DWORD attributes = GetFileAttributes(path.c_str());
./Support/Windows/Path.inc:    assert(0 && "GetFileAttributes returned INVALID_FILE_ATTRIBUTES");
./Support/Windows/Path.inc:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/Path.inc:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/Path.inc:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/Path.inc:    if (!GetFileAttributesEx(path.c_str(), GetFileExInfoStandard, &fi)) {
./Support/Windows/Path.inc:    status.mode = fi.dwFileAttributes & FILE_ATTRIBUTE_READONLY ? 0555 : 0777;
./Support/Windows/Path.inc:    status.isDir = fi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
./Support/Windows/Path.inc:  DWORD attr = GetFileAttributes(path.c_str());
./Support/Windows/Path.inc:    if (!SetFileAttributes(path.c_str(), attr & ~FILE_ATTRIBUTE_READONLY)) {
./Support/Windows/Path.inc:  if (!GetFileAttributesEx(path.c_str(), GetFileExInfoStandard, &fi)) {
./Support/Windows/Path.inc:  if (!(fi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
./Support/Windows/Path.inc:  if (!GetFileAttributesEx(path.c_str(), GetFileExInfoStandard, &fi))
./Support/Windows/Path.inc:  if (fi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
./Support/Windows/Path.inc:    if (fi.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
./Support/Windows/Path.inc:      if (!SetFileAttributes(path.c_str(),
./Support/Windows/Path.inc:                             fi.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY))
./Support/Windows/Path.inc:    if (bhfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
./Support/Windows/Path.inc:      if (!SetFileAttributes(path.c_str(),
./Support/Windows/Path.inc:              bhfi.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY))
./Support/Windows/Path.inc:        return MakeErrMsg(ErrMsg, path + ": SetFileAttributes: ");
./Support/Windows/Path.inc:    if (!(bhfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY)) {
./Support/Windows/Path.inc:      if (!SetFileAttributes(path.c_str(),
./Support/Windows/Path.inc:              bhfi.dwFileAttributes | FILE_ATTRIBUTE_READONLY))
./Support/Windows/Path.inc:        return MakeErrMsg(ErrMsg, path + ": SetFileAttributes: ");
./Support/Windows/Process.inc:        return csbi.wAttributes;
./Support/Windows/Process.inc:  SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), colors);
./Support/Windows/Process.inc:  SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), colors);
./Support/Windows/Process.inc:static WORD GetConsoleTextAttribute(HANDLE hConsoleOutput) {
./Support/Windows/Process.inc:  return info.wAttributes;
./Support/Windows/Process.inc:   = GetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE));
./Support/Windows/Process.inc:  SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), new_attributes);
./Support/Windows/Process.inc:  SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), defaultColors());
./Support/Windows/PathV2.inc:  DWORD attributes = ::GetFileAttributesW(path_utf16.begin());
./Support/Windows/PathV2.inc:  if (!::GetFileAttributesExW(path_utf16.begin(),
./Support/Windows/PathV2.inc:  DWORD attr = ::GetFileAttributesW(path_utf16.begin());
./Support/Windows/PathV2.inc:                    0, // Attributes only.
./Support/Windows/PathV2.inc:                    0, // Attributes only.
./Support/Windows/PathV2.inc:  DWORD attributes = ::GetFileAttributesW(path_utf16.begin());
./Support/Windows/PathV2.inc:  if ( ! ::SetFileAttributesW(path_utf16.begin(), attributes))
./Support/Dwarf.cpp:/// AttributeString - Return the string for the specified attribute.
./Support/Dwarf.cpp:const char *llvm::dwarf::AttributeString(unsigned Attribute) {
./Support/Dwarf.cpp:  switch (Attribute) {
./Support/Dwarf.cpp:/// AttributeEncodingString - Return the string for the specified attribute
./Support/Dwarf.cpp:const char *llvm::dwarf::AttributeEncodingString(unsigned Encoding) {
./tags:ALMutex	VMCore/Attributes.cpp	/^static ManagedStatic<sys::SmartMutex<true> > ALMutex;$/;"	m	namespace:llvm	file:
./tags:AddAttribute	CodeGen/AsmPrinter/DIE.h	/^    void AddAttribute(uint16_t Attribute, uint16_t Form) {$/;"	f	class:llvm::DIEAbbrev
./tags:AddFirstAttribute	CodeGen/AsmPrinter/DIE.h	/^    void AddFirstAttribute(uint16_t Attribute, uint16_t Form) {$/;"	f	class:llvm::DIEAbbrev
./tags:AddRef	VMCore/Attributes.cpp	/^  void AddRef() {$/;"	f	class:llvm::AttributeListImpl
./tags:ArgInfo	AsmParser/LLParser.h	/^      ArgInfo(LocTy L, Type *ty, Attributes Attr, const std::string &N)$/;"	f	struct:llvm::LLParser::ArgInfo
./tags:AsmAttributeEmitter	Target/ARM/ARMAsmPrinter.cpp	/^    AsmAttributeEmitter(MCStreamer &Streamer_) : Streamer(Streamer_) {}$/;"	f	class:__anon313::AsmAttributeEmitter
./tags:AsmAttributeEmitter	Target/ARM/ARMAsmPrinter.cpp	/^  class AsmAttributeEmitter : public AttributeEmitter {$/;"	c	namespace:__anon313	file:
./tags:AttrListPtr	VMCore/Attributes.cpp	/^AttrListPtr::AttrListPtr(AttributeListImpl *LI) : AttrList(LI) {$/;"	f	class:AttrListPtr
./tags:AttrListPtr	VMCore/Attributes.cpp	/^AttrListPtr::AttrListPtr(const AttrListPtr &P) : AttrList(P.AttrList) {$/;"	f	class:AttrListPtr
./tags:Attribute	CodeGen/AsmPrinter/DIE.h	/^    uint16_t Attribute;$/;"	m	class:llvm::DIEAbbrevData
./tags:Attribute	DebugInfo/DWARFAttribute.h	/^  uint16_t Attribute;$/;"	m	class:llvm::DWARFAttribute
./tags:AttributeEmitter	Target/ARM/ARMAsmPrinter.cpp	/^  class AttributeEmitter {$/;"	c	namespace:__anon313	file:
./tags:AttributeEncodingString	Support/Dwarf.cpp	/^const char *llvm::dwarf::AttributeEncodingString(unsigned Encoding) {$/;"	f	class:llvm::dwarf
./tags:AttributeItem	Target/ARM/ARMAsmPrinter.cpp	/^    } AttributeItem;$/;"	m	class:__anon313::ObjectAttributeEmitter	typeref:struct:__anon313::ObjectAttributeEmitter::AttributeItemType	file:
./tags:AttributeItemType	Target/ARM/ARMAsmPrinter.cpp	/^    struct AttributeItemType {$/;"	s	class:__anon313::ObjectAttributeEmitter	file:
./tags:AttributeListImpl	VMCore/Attributes.cpp	/^  AttributeListImpl(ArrayRef<AttributeWithIndex> attrs)$/;"	f	class:llvm::AttributeListImpl
./tags:AttributeListImpl	VMCore/Attributes.cpp	/^class AttributeListImpl : public FoldingSetNode {$/;"	c	namespace:llvm	file:
./tags:AttributeMap	Bitcode/Writer/ValueEnumerator.h	/^  AttributeMapType AttributeMap;$/;"	m	class:llvm::ValueEnumerator
./tags:AttributeMapType	Bitcode/Writer/ValueEnumerator.h	/^  typedef DenseMap<void*, unsigned> AttributeMapType;$/;"	t	class:llvm::ValueEnumerator
./tags:AttributeString	Support/Dwarf.cpp	/^const char *llvm::dwarf::AttributeString(unsigned Attribute) {$/;"	f	class:llvm::dwarf
./tags:Attributes	Bitcode/Writer/ValueEnumerator.h	/^  std::vector<AttrListPtr> Attributes;$/;"	m	class:llvm::ValueEnumerator
./tags:Attributes	DebugInfo/DWARFAbbreviationDeclaration.h	/^  SmallVector<DWARFAttribute, 8> Attributes;$/;"	m	class:llvm::DWARFAbbreviationDeclaration
./tags:AttributesImpl	VMCore/AttributesImpl.h	/^  AttributesImpl(uint64_t bits) : Bits(bits) {}$/;"	f	class:llvm::AttributesImpl
./tags:AttributesImpl	VMCore/AttributesImpl.h	/^class AttributesImpl : public FoldingSetNode {$/;"	c	namespace:llvm
./tags:AttributesLists	VMCore/Attributes.cpp	/^static ManagedStatic<FoldingSet<AttributeListImpl> > AttributesLists;$/;"	v	file:
./tags:AttributesSection	Target/ARM/ARMTargetObjectFile.h	/^  const MCSection *AttributesSection;$/;"	m	class:llvm::ARMElfTargetObjectFile
./tags:Attrs	AsmParser/LLParser.h	/^      Attributes Attrs;$/;"	m	struct:llvm::LLParser::ArgInfo
./tags:Attrs	AsmParser/LLParser.h	/^      Attributes Attrs;$/;"	m	struct:llvm::LLParser::ParamInfo
./tags:Attrs	VMCore/Attributes.cpp	/^  SmallVector<AttributeWithIndex, 4> Attrs;$/;"	m	class:llvm::AttributeListImpl	file:
./tags:AttrsSet	VMCore/LLVMContextImpl.h	/^  FoldingSet<AttributesImpl> AttrsSet;$/;"	m	class:llvm::LLVMContextImpl
./tags:Bits	VMCore/AttributesImpl.h	/^  uint64_t Bits;                \/\/ FIXME: We will be expanding this.$/;"	m	class:llvm::AttributesImpl
./tags:Contents	Target/ARM/ARMAsmPrinter.cpp	/^    SmallVector<AttributeItemType, 64> Contents;$/;"	m	class:__anon313::ObjectAttributeEmitter	file:
./tags:ContentsSize	Target/ARM/ARMAsmPrinter.cpp	/^    size_t ContentsSize;$/;"	m	class:__anon313::ObjectAttributeEmitter	file:
./tags:CurrentVendor	Target/ARM/ARMAsmPrinter.cpp	/^    StringRef CurrentVendor;$/;"	m	class:__anon313::ObjectAttributeEmitter	file:
./tags:DIEAbbrevData	CodeGen/AsmPrinter/DIE.h	/^    DIEAbbrevData(uint16_t A, uint16_t F) : Attribute(A), Form(F) {}$/;"	f	class:llvm::DIEAbbrevData
./tags:DWARFAttribute	DebugInfo/DWARFAttribute.h	/^  DWARFAttribute(uint16_t attr, uint16_t form)$/;"	f	class:llvm::DWARFAttribute
./tags:DWARFAttribute	DebugInfo/DWARFAttribute.h	/^class DWARFAttribute {$/;"	c	namespace:llvm
./tags:DropRef	VMCore/Attributes.cpp	/^  void DropRef() {$/;"	f	class:llvm::AttributeListImpl
./tags:EmitAttribute	Target/ARM/ARMAsmPrinter.cpp	/^    void EmitAttribute(unsigned Attribute, unsigned Value) {$/;"	f	class:__anon313::AsmAttributeEmitter
./tags:EmitAttribute	Target/ARM/ARMAsmPrinter.cpp	/^    void EmitAttribute(unsigned Attribute, unsigned Value) {$/;"	f	class:__anon313::ObjectAttributeEmitter
./tags:EmitEHSymAttributes	MC/MCAsmStreamer.cpp	/^void MCAsmStreamer::EmitEHSymAttributes(const MCSymbol *Symbol,$/;"	f	class:MCAsmStreamer
./tags:EmitEHSymAttributes	MC/MCMachOStreamer.cpp	/^void MCMachOStreamer::EmitEHSymAttributes(const MCSymbol *Symbol,$/;"	f	class:MCMachOStreamer
./tags:EmitEHSymAttributes	MC/MCStreamer.cpp	/^void MCStreamer::EmitEHSymAttributes(const MCSymbol *Symbol,$/;"	f	class:MCStreamer
./tags:EmitSymbolAttribute	MC/MCAsmStreamer.cpp	/^void MCAsmStreamer::EmitSymbolAttribute(MCSymbol *Symbol,$/;"	f	class:MCAsmStreamer
./tags:EmitSymbolAttribute	MC/MCELFStreamer.cpp	/^void MCELFStreamer::EmitSymbolAttribute(MCSymbol *Symbol,$/;"	f	class:MCELFStreamer
./tags:EmitSymbolAttribute	MC/MCMachOStreamer.cpp	/^void MCMachOStreamer::EmitSymbolAttribute(MCSymbol *Symbol,$/;"	f	class:MCMachOStreamer
./tags:EmitSymbolAttribute	MC/MCNullStreamer.cpp	/^    virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute){}$/;"	f	class:__anon217::MCNullStreamer
./tags:EmitSymbolAttribute	MC/MCPureStreamer.cpp	/^  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute) {$/;"	f	class:__anon219::MCPureStreamer
./tags:EmitSymbolAttribute	MC/WinCOFFStreamer.cpp	/^void WinCOFFStreamer::EmitSymbolAttribute(MCSymbol *Symbol,$/;"	f	class:WinCOFFStreamer
./tags:EmitTextAttribute	Target/ARM/ARMAsmPrinter.cpp	/^    void EmitTextAttribute(unsigned Attribute, StringRef String) {$/;"	f	class:__anon313::AsmAttributeEmitter
./tags:EmitTextAttribute	Target/ARM/ARMAsmPrinter.cpp	/^    void EmitTextAttribute(unsigned Attribute, StringRef String) {$/;"	f	class:__anon313::ObjectAttributeEmitter
./tags:EnumerateAttributes	Bitcode/Writer/ValueEnumerator.cpp	/^void ValueEnumerator::EnumerateAttributes(const AttrListPtr &PAL) {$/;"	f	class:ValueEnumerator
./tags:Finish	Target/ARM/ARMAsmPrinter.cpp	/^    void Finish() { }$/;"	f	class:__anon313::AsmAttributeEmitter
./tags:Finish	Target/ARM/ARMAsmPrinter.cpp	/^    void Finish() {$/;"	f	class:__anon313::ObjectAttributeEmitter
./tags:Form	DebugInfo/DWARFAttribute.h	/^  uint16_t Form;$/;"	m	class:llvm::DWARFAttribute
./tags:GetReturnInfo	CodeGen/SelectionDAG/TargetLowering.cpp	/^void llvm::GetReturnInfo(Type* ReturnType, Attributes attr,$/;"	f	class:llvm
./tags:HiddenAttribute	Target/ARM/ARMAsmPrinter.cpp	/^        HiddenAttribute = 0,$/;"	e	enum:__anon313::ObjectAttributeEmitter::AttributeItemType::__anon314	file:
./tags:IntValue	Target/ARM/ARMAsmPrinter.cpp	/^      unsigned IntValue;$/;"	m	struct:__anon313::ObjectAttributeEmitter::AttributeItemType	file:
./tags:LLVMAddAttribute	VMCore/Core.cpp	/^void LLVMAddAttribute(LLVMValueRef Arg, LLVMAttribute PA) {$/;"	f
./tags:LLVMAddFunctionAttr	VMCore/Core.cpp	/^void LLVMAddFunctionAttr(LLVMValueRef Fn, LLVMAttribute PA) {$/;"	f
./tags:LLVMAddInstrAttribute	VMCore/Core.cpp	/^void LLVMAddInstrAttribute(LLVMValueRef Instr, unsigned index, $/;"	f
./tags:LLVMGetAttribute	VMCore/Core.cpp	/^LLVMAttribute LLVMGetAttribute(LLVMValueRef Arg) {$/;"	f
./tags:LLVMGetFunctionAttr	VMCore/Core.cpp	/^LLVMAttribute LLVMGetFunctionAttr(LLVMValueRef Fn) {$/;"	f
./tags:LLVMRemoveAttribute	VMCore/Core.cpp	/^void LLVMRemoveAttribute(LLVMValueRef Arg, LLVMAttribute PA) {$/;"	f
./tags:LLVMRemoveFunctionAttr	VMCore/Core.cpp	/^void LLVMRemoveFunctionAttr(LLVMValueRef Fn, LLVMAttribute PA) {$/;"	f
./tags:LLVMRemoveInstrAttribute	VMCore/Core.cpp	/^void LLVMRemoveInstrAttribute(LLVMValueRef Instr, unsigned index, $/;"	f
./tags:LLVM_ATTRIBUTESIMPL_H	VMCore/AttributesImpl.h	16;"	d
./tags:LLVM_DEBUGINFO_DWARFATTRIBUTE_H	DebugInfo/DWARFAttribute.h	11;"	d
./tags:LLVM_DELETED_FUNCTION	VMCore/Attributes.cpp	/^  AttributeListImpl(const AttributeListImpl &) LLVM_DELETED_FUNCTION;$/;"	m	class:llvm::AttributeListImpl	file:
./tags:LLVM_DELETED_FUNCTION	VMCore/Attributes.cpp	/^  void operator=(const AttributeListImpl &) LLVM_DELETED_FUNCTION;$/;"	m	class:llvm::AttributeListImpl	file:
./tags:MAttributes	Bitcode/Reader/BitcodeReader.h	/^  std::vector<AttrListPtr> MAttributes;$/;"	m	class:llvm::BitcodeReader
./tags:MaybeSwitchVendor	Target/ARM/ARMAsmPrinter.cpp	/^    void MaybeSwitchVendor(StringRef Vendor) { }$/;"	f	class:__anon313::AsmAttributeEmitter
./tags:MaybeSwitchVendor	Target/ARM/ARMAsmPrinter.cpp	/^    void MaybeSwitchVendor(StringRef Vendor) {$/;"	f	class:__anon313::ObjectAttributeEmitter
./tags:NumericAttribute	Target/ARM/ARMAsmPrinter.cpp	/^        NumericAttribute,$/;"	e	enum:__anon313::ObjectAttributeEmitter::AttributeItemType::__anon314	file:
./tags:ObjectAttributeEmitter	Target/ARM/ARMAsmPrinter.cpp	/^    ObjectAttributeEmitter(MCObjectStreamer &Streamer_) :$/;"	f	class:__anon313::ObjectAttributeEmitter
./tags:ObjectAttributeEmitter	Target/ARM/ARMAsmPrinter.cpp	/^  class ObjectAttributeEmitter : public AttributeEmitter {$/;"	c	namespace:__anon313	file:
./tags:ParamInfo	AsmParser/LLParser.h	/^      ParamInfo(LocTy loc, Value *v, Attributes attrs)$/;"	f	struct:llvm::LLParser::ParamInfo
./tags:ParseAttributeBlock	Bitcode/Reader/BitcodeReader.cpp	/^bool BitcodeReader::ParseAttributeBlock() {$/;"	f	class:BitcodeReader
./tags:ParseDirectiveSymbolAttribute	MC/MCParser/AsmParser.cpp	/^bool AsmParser::ParseDirectiveSymbolAttribute(MCSymbolAttr Attr) {$/;"	f	class:AsmParser
./tags:ParseDirectiveSymbolAttribute	MC/MCParser/COFFAsmParser.cpp	/^bool COFFAsmParser::ParseDirectiveSymbolAttribute(StringRef Directive, SMLoc) {$/;"	f	class:COFFAsmParser
./tags:ParseDirectiveSymbolAttribute	MC/MCParser/ELFAsmParser.cpp	/^bool ELFAsmParser::ParseDirectiveSymbolAttribute(StringRef Directive, SMLoc) {$/;"	f	class:ELFAsmParser
./tags:Profile	VMCore/Attributes.cpp	/^  static void Profile(FoldingSetNodeID &ID, ArrayRef<AttributeWithIndex> Attrs){$/;"	f	class:llvm::AttributeListImpl
./tags:Profile	VMCore/Attributes.cpp	/^  void Profile(FoldingSetNodeID &ID) const {$/;"	f	class:llvm::AttributeListImpl
./tags:Profile	VMCore/AttributesImpl.h	/^  static void Profile(FoldingSetNodeID &ID, uint64_t Bits) {$/;"	f	class:llvm::AttributesImpl
./tags:Profile	VMCore/AttributesImpl.h	/^  void Profile(FoldingSetNodeID &ID) const {$/;"	f	class:llvm::AttributesImpl
./tags:Raw	VMCore/Attributes.cpp	/^uint64_t Attributes::Raw() const {$/;"	f	class:Attributes
./tags:Raw	VMCore/AttributesImpl.h	/^  uint64_t Raw() const { return Bits; } \/\/ FIXME: Remove.$/;"	f	class:llvm::AttributesImpl
./tags:RefCount	VMCore/Attributes.cpp	/^  sys::cas_flag RefCount;$/;"	m	class:llvm::AttributeListImpl	file:
./tags:RemoveNestAttribute	Transforms/IPO/GlobalOpt.cpp	/^static void RemoveNestAttribute(Function *F) {$/;"	f	file:
./tags:Streamer	Target/ARM/ARMAsmPrinter.cpp	/^    MCObjectStreamer &Streamer;$/;"	m	class:__anon313::ObjectAttributeEmitter	file:
./tags:Streamer	Target/ARM/ARMAsmPrinter.cpp	/^    MCStreamer &Streamer;$/;"	m	class:__anon313::AsmAttributeEmitter	file:
./tags:StringValue	Target/ARM/ARMAsmPrinter.cpp	/^      StringRef StringValue;$/;"	m	struct:__anon313::ObjectAttributeEmitter::AttributeItemType	file:
./tags:Tag	Target/ARM/ARMAsmPrinter.cpp	/^      unsigned Tag;$/;"	m	struct:__anon313::ObjectAttributeEmitter::AttributeItemType	file:
./tags:TextAttribute	Target/ARM/ARMAsmPrinter.cpp	/^        TextAttribute$/;"	e	enum:__anon313::ObjectAttributeEmitter::AttributeItemType::__anon314	file:
./tags:Type	Target/ARM/ARMAsmPrinter.cpp	/^      } Type;$/;"	m	struct:__anon313::ObjectAttributeEmitter::AttributeItemType	typeref:enum:__anon313::ObjectAttributeEmitter::AttributeItemType::__anon314	file:
./tags:VerifyAttributeCount	VMCore/Verifier.cpp	/^static bool VerifyAttributeCount(const AttrListPtr &Attrs, unsigned Params) {$/;"	f	file:
./tags:VerifyParameterAttrs	VMCore/Verifier.cpp	/^void Verifier::VerifyParameterAttrs(Attributes Attrs, Type *Ty,$/;"	f	class:Verifier
./tags:WriteAttributeTable	Bitcode/Writer/BitcodeWriter.cpp	/^static void WriteAttributeTable(const ValueEnumerator &VE,$/;"	f	file:
./tags:addAddress	CodeGen/AsmPrinter/DwarfCompileUnit.cpp	/^void CompileUnit::addAddress(DIE *Die, unsigned Attribute,$/;"	f	class:CompileUnit
./tags:addAlignmentAttr	VMCore/Attributes.cpp	/^AttrBuilder &AttrBuilder::addAlignmentAttr(unsigned Align) {$/;"	f	class:AttrBuilder
./tags:addAttr	VMCore/Attributes.cpp	/^AttrListPtr AttrListPtr::addAttr(LLVMContext &C, unsigned Idx,$/;"	f	class:AttrListPtr
./tags:addAttr	VMCore/Function.cpp	/^void Argument::addAttr(Attributes attr) {$/;"	f	class:Argument
./tags:addAttribute	VMCore/Attributes.cpp	/^AttrBuilder &AttrBuilder::addAttribute(Attributes::AttrVal Val){$/;"	f	class:AttrBuilder
./tags:addAttribute	VMCore/Function.cpp	/^void Function::addAttribute(unsigned i, Attributes attr) {$/;"	f	class:Function
./tags:addAttribute	VMCore/Instructions.cpp	/^void CallInst::addAttribute(unsigned i, Attributes attr) {$/;"	f	class:CallInst
./tags:addAttribute	VMCore/Instructions.cpp	/^void InvokeInst::addAttribute(unsigned i, Attributes attr) {$/;"	f	class:InvokeInst
./tags:addAttributes	VMCore/Attributes.cpp	/^AttrBuilder &AttrBuilder::addAttributes(const Attributes &A) {$/;"	f	class:AttrBuilder
./tags:addBlock	CodeGen/AsmPrinter/DwarfCompileUnit.cpp	/^void CompileUnit::addBlock(DIE *Die, unsigned Attribute, unsigned Form,$/;"	f	class:CompileUnit
./tags:addDIEEntry	CodeGen/AsmPrinter/DwarfCompileUnit.cpp	/^void CompileUnit::addDIEEntry(DIE *Die, unsigned Attribute, unsigned Form,$/;"	f	class:CompileUnit
./tags:addDelta	CodeGen/AsmPrinter/DwarfCompileUnit.cpp	/^void CompileUnit::addDelta(DIE *Die, unsigned Attribute, unsigned Form,$/;"	f	class:CompileUnit
./tags:addFlag	CodeGen/AsmPrinter/DwarfCompileUnit.cpp	/^void CompileUnit::addFlag(DIE *Die, unsigned Attribute) {$/;"	f	class:CompileUnit
./tags:addLabel	CodeGen/AsmPrinter/DwarfCompileUnit.cpp	/^void CompileUnit::addLabel(DIE *Die, unsigned Attribute, unsigned Form,$/;"	f	class:CompileUnit
./tags:addRawValue	VMCore/Attributes.cpp	/^AttrBuilder &AttrBuilder::addRawValue(uint64_t Val) {$/;"	f	class:AttrBuilder
./tags:addSInt	CodeGen/AsmPrinter/DwarfCompileUnit.cpp	/^void CompileUnit::addSInt(DIE *Die, unsigned Attribute,$/;"	f	class:CompileUnit
./tags:addStackAlignmentAttr	VMCore/Attributes.cpp	/^AttrBuilder &AttrBuilder::addStackAlignmentAttr(unsigned Align){$/;"	f	class:AttrBuilder
./tags:addString	CodeGen/AsmPrinter/DwarfCompileUnit.cpp	/^void CompileUnit::addString(DIE *Die, unsigned Attribute, StringRef String) {$/;"	f	class:CompileUnit
./tags:addType	CodeGen/AsmPrinter/DwarfCompileUnit.cpp	/^void CompileUnit::addType(DIE *Entity, DIType Ty, unsigned Attribute) {$/;"	f	class:CompileUnit
./tags:addUInt	CodeGen/AsmPrinter/DwarfCompileUnit.cpp	/^void CompileUnit::addUInt(DIE *Die, unsigned Attribute,$/;"	f	class:CompileUnit
./tags:addValue	CodeGen/AsmPrinter/DIE.h	/^    void addValue(unsigned Attribute, unsigned Form, DIEValue *Value) {$/;"	f	class:llvm::DIE
./tags:copyAttributesFrom	VMCore/Function.cpp	/^void Function::copyAttributesFrom(const GlobalValue *Src) {$/;"	f	class:Function
./tags:copyAttributesFrom	VMCore/Globals.cpp	/^void GlobalValue::copyAttributesFrom(const GlobalValue *Src) {$/;"	f	class:GlobalValue
./tags:copyAttributesFrom	VMCore/Globals.cpp	/^void GlobalVariable::copyAttributesFrom(const GlobalValue *Src) {$/;"	f	class:GlobalVariable
./tags:copyGVAttributes	Linker/LinkModules.cpp	/^static void copyGVAttributes(GlobalValue *DestGV, const GlobalValue *SrcGV) {$/;"	f	file:
./tags:decodeLLVMAttributesForBitcode	VMCore/Attributes.cpp	/^Attributes Attributes::decodeLLVMAttributesForBitcode(LLVMContext &C,$/;"	f	class:Attributes
./tags:dump	VMCore/Attributes.cpp	/^void AttrListPtr::dump() const {$/;"	f	class:AttrListPtr
./tags:dumpAttribute	DebugInfo/DWARFDebugInfoEntry.cpp	/^void DWARFDebugInfoEntryMinimal::dumpAttribute(raw_ostream &OS,$/;"	f	class:DWARFDebugInfoEntryMinimal
./tags:emitARMAttributeSection	Target/ARM/ARMAsmPrinter.cpp	/^void ARMAsmPrinter::emitARMAttributeSection() {$/;"	f	class:ARMAsmPrinter
./tags:emitAttributes	Target/ARM/ARMAsmPrinter.cpp	/^void ARMAsmPrinter::emitAttributes() {$/;"	f	class:ARMAsmPrinter
./tags:encodeLLVMAttributesForBitcode	VMCore/Attributes.cpp	/^uint64_t Attributes::encodeLLVMAttributesForBitcode(Attributes Attrs) {$/;"	f	class:Attributes
./tags:findAttributeIndex	DebugInfo/DWARFAbbreviationDeclaration.cpp	/^DWARFAbbreviationDeclaration::findAttributeIndex(uint16_t attr) const {$/;"	f	class:DWARFAbbreviationDeclaration
./tags:get	VMCore/Attributes.cpp	/^AttrListPtr AttrListPtr::get(ArrayRef<AttributeWithIndex> Attrs) {$/;"	f	class:AttrListPtr
./tags:get	VMCore/Attributes.cpp	/^Attributes Attributes::get(LLVMContext &Context, ArrayRef<AttrVal> Vals) {$/;"	f	class:Attributes
./tags:get	VMCore/Attributes.cpp	/^Attributes Attributes::get(LLVMContext &Context, AttrBuilder &B) {$/;"	f	class:Attributes
./tags:getAlignment	VMCore/Attributes.cpp	/^uint64_t AttrBuilder::getAlignment() const {$/;"	f	class:AttrBuilder
./tags:getAlignment	VMCore/Attributes.cpp	/^uint64_t AttributesImpl::getAlignment() const {$/;"	f	class:AttributesImpl
./tags:getAlignment	VMCore/Attributes.cpp	/^unsigned Attributes::getAlignment() const {$/;"	f	class:Attributes
./tags:getAsString	VMCore/Attributes.cpp	/^std::string Attributes::getAsString() const {$/;"	f	class:Attributes
./tags:getAttrMask	VMCore/Attributes.cpp	/^uint64_t AttributesImpl::getAttrMask(uint64_t Val) {$/;"	f	class:AttributesImpl
./tags:getAttribute	CodeGen/AsmPrinter/DIE.h	/^    uint16_t getAttribute() const { return Attribute; }$/;"	f	class:llvm::DIEAbbrevData
./tags:getAttribute	DebugInfo/DWARFAttribute.h	/^  uint16_t getAttribute() const { return Attribute; }$/;"	f	class:llvm::DWARFAttribute
./tags:getAttributeID	Bitcode/Writer/ValueEnumerator.h	/^  unsigned getAttributeID(const AttrListPtr &PAL) const {$/;"	f	class:llvm::ValueEnumerator
./tags:getAttributeValue	DebugInfo/DWARFDebugInfoEntry.cpp	/^DWARFDebugInfoEntryMinimal::getAttributeValue(const DWARFCompileUnit *cu,$/;"	f	class:DWARFDebugInfoEntryMinimal
./tags:getAttributeValueAsReference	DebugInfo/DWARFDebugInfoEntry.cpp	/^DWARFDebugInfoEntryMinimal::getAttributeValueAsReference($/;"	f	class:DWARFDebugInfoEntryMinimal
./tags:getAttributeValueAsSigned	DebugInfo/DWARFDebugInfoEntry.cpp	/^DWARFDebugInfoEntryMinimal::getAttributeValueAsSigned($/;"	f	class:DWARFDebugInfoEntryMinimal
./tags:getAttributeValueAsString	DebugInfo/DWARFDebugInfoEntry.cpp	/^DWARFDebugInfoEntryMinimal::getAttributeValueAsString($/;"	f	class:DWARFDebugInfoEntryMinimal
./tags:getAttributeValueAsUnsigned	DebugInfo/DWARFDebugInfoEntry.cpp	/^DWARFDebugInfoEntryMinimal::getAttributeValueAsUnsigned($/;"	f	class:DWARFDebugInfoEntryMinimal
./tags:getAttributes	Bitcode/Reader/BitcodeReader.h	/^  AttrListPtr getAttributes(unsigned i) const {$/;"	f	class:llvm::BitcodeReader
./tags:getAttributes	Bitcode/Writer/ValueEnumerator.h	/^  const std::vector<AttrListPtr> &getAttributes() const {$/;"	f	class:llvm::ValueEnumerator
./tags:getAttributes	DebugInfo/DWARFAbbreviationDeclaration.h	/^  const SmallVectorImpl<DWARFAttribute> &getAttributes() const {$/;"	f	class:llvm::DWARFAbbreviationDeclaration
./tags:getAttributes	VMCore/Attributes.cpp	/^Attributes AttrListPtr::getAttributes(unsigned Idx) const {$/;"	f	class:AttrListPtr
./tags:getAttributesAtIndex	VMCore/Attributes.cpp	/^Attributes &AttrListPtr::getAttributesAtIndex(unsigned i) const {$/;"	f	class:AttrListPtr
./tags:getAttributesSection	Target/ARM/ARMTargetObjectFile.h	/^  virtual const MCSection *getAttributesSection() const {$/;"	f	class:llvm::ARMElfTargetObjectFile
./tags:getEdgeAttributes	Analysis/RegionPrinter.cpp	/^  std::string getEdgeAttributes(RegionNode *srcNode,$/;"	f	struct:llvm::DOTGraphTraits
./tags:getEdgeAttributes	CodeGen/ScheduleDAGPrinter.cpp	/^    static std::string getEdgeAttributes(const SUnit *Node,$/;"	f	struct:llvm::DOTGraphTraits
./tags:getEdgeAttributes	CodeGen/SelectionDAG/SelectionDAGPrinter.cpp	/^    static std::string getEdgeAttributes(const void *Node, EdgeIter EI,$/;"	f	struct:llvm::DOTGraphTraits
./tags:getForm	DebugInfo/DWARFAttribute.h	/^  uint16_t getForm() const { return Form; }$/;"	f	class:llvm::DWARFAttribute
./tags:getNodeAttributes	CodeGen/ScheduleDAGPrinter.cpp	/^    static std::string getNodeAttributes(const SUnit *N,$/;"	f	struct:llvm::DOTGraphTraits
./tags:getNodeAttributes	CodeGen/SelectionDAG/SelectionDAGPrinter.cpp	/^    static std::string getNodeAttributes(const SDNode *N,$/;"	f	struct:llvm::DOTGraphTraits
./tags:getNumAttributes	DebugInfo/DWARFAbbreviationDeclaration.h	/^  uint32_t getNumAttributes() const { return Attributes.size(); }$/;"	f	class:llvm::DWARFAbbreviationDeclaration
./tags:getNumAttributes	DebugInfo/DWARFDebugInfoEntry.h	/^  uint32_t getNumAttributes() const {$/;"	f	class:llvm::DWARFDebugInfoEntryMinimal
./tags:getNumAttrs	VMCore/Attributes.cpp	/^unsigned AttrListPtr::getNumAttrs() const {$/;"	f	class:AttrListPtr
./tags:getNumSlots	VMCore/Attributes.cpp	/^unsigned AttrListPtr::getNumSlots() const {$/;"	f	class:AttrListPtr
./tags:getSlot	VMCore/Attributes.cpp	/^const AttributeWithIndex &AttrListPtr::getSlot(unsigned Slot) const {$/;"	f	class:AttrListPtr
./tags:getStackAlignment	VMCore/Attributes.cpp	/^uint64_t AttrBuilder::getStackAlignment() const {$/;"	f	class:AttrBuilder
./tags:getStackAlignment	VMCore/Attributes.cpp	/^uint64_t AttributesImpl::getStackAlignment() const {$/;"	f	class:AttributesImpl
./tags:getStackAlignment	VMCore/Attributes.cpp	/^unsigned Attributes::getStackAlignment() const {$/;"	f	class:Attributes
./tags:getULEBSize	Target/ARM/ARMAsmPrinter.cpp	/^    size_t getULEBSize(int Value) {$/;"	f	class:__anon313::ObjectAttributeEmitter	file:
./tags:hasAlignmentAttr	VMCore/Attributes.cpp	/^bool AttrBuilder::hasAlignmentAttr() const {$/;"	f	class:AttrBuilder
./tags:hasAttrSomewhere	VMCore/Attributes.cpp	/^bool AttrListPtr::hasAttrSomewhere(Attributes::AttrVal Attr) const {$/;"	f	class:AttrListPtr
./tags:hasAttribute	VMCore/Attributes.cpp	/^bool AttrBuilder::hasAttribute(Attributes::AttrVal A) const {$/;"	f	class:AttrBuilder
./tags:hasAttribute	VMCore/Attributes.cpp	/^bool Attributes::hasAttribute(AttrVal Val) const {$/;"	f	class:Attributes
./tags:hasAttribute	VMCore/Attributes.cpp	/^bool AttributesImpl::hasAttribute(uint64_t A) const {$/;"	f	class:AttributesImpl
./tags:hasAttributes	VMCore/Attributes.cpp	/^bool AttrBuilder::hasAttributes() const {$/;"	f	class:AttrBuilder
./tags:hasAttributes	VMCore/Attributes.cpp	/^bool AttrBuilder::hasAttributes(const Attributes &A) const {$/;"	f	class:AttrBuilder
./tags:hasAttributes	VMCore/Attributes.cpp	/^bool Attributes::hasAttributes() const {$/;"	f	class:Attributes
./tags:hasAttributes	VMCore/Attributes.cpp	/^bool Attributes::hasAttributes(const Attributes &A) const {$/;"	f	class:Attributes
./tags:hasAttributes	VMCore/Attributes.cpp	/^bool AttributesImpl::hasAttributes() const {$/;"	f	class:AttributesImpl
./tags:hasAttributes	VMCore/Attributes.cpp	/^bool AttributesImpl::hasAttributes(const Attributes &A) const {$/;"	f	class:AttributesImpl
./tags:hasFnAttr	VMCore/Instructions.cpp	/^bool CallInst::hasFnAttr(Attributes::AttrVal A) const {$/;"	f	class:CallInst
./tags:hasFnAttr	VMCore/Instructions.cpp	/^bool InvokeInst::hasFnAttr(Attributes::AttrVal A) const {$/;"	f	class:InvokeInst
./tags:inferPrototypeAttributes	Transforms/Scalar/SimplifyLibCalls.cpp	/^void SimplifyLibCalls::inferPrototypeAttributes(Function &F) {$/;"	f	class:SimplifyLibCalls
./tags:isInTailCallPosition	CodeGen/Analysis.cpp	/^bool llvm::isInTailCallPosition(ImmutableCallSite CS, Attributes CalleeRetAttr,$/;"	f	class:llvm
./tags:llvm	DebugInfo/DWARFAttribute.h	/^namespace llvm {$/;"	n
./tags:llvm	VMCore/Attributes.cpp	/^namespace llvm {$/;"	n	file:
./tags:llvm	VMCore/AttributesImpl.h	/^namespace llvm {$/;"	n
./tags:operator =	VMCore/Attributes.cpp	/^const AttrListPtr &AttrListPtr::operator=(const AttrListPtr &RHS) {$/;"	f	class:AttrListPtr
./tags:paramHasAttr	VMCore/Instructions.cpp	/^bool CallInst::paramHasAttr(unsigned i, Attributes::AttrVal A) const {$/;"	f	class:CallInst
./tags:paramHasAttr	VMCore/Instructions.cpp	/^bool InvokeInst::paramHasAttr(unsigned i, Attributes::AttrVal A) const {$/;"	f	class:InvokeInst
./tags:printAttributes	Target/CppBackend/CPPBackend.cpp	/^void CppWriter::printAttributes(const AttrListPtr &PAL,$/;"	f	class:CppWriter
./tags:removeAttr	VMCore/Attributes.cpp	/^AttrListPtr AttrListPtr::removeAttr(LLVMContext &C, unsigned Idx,$/;"	f	class:AttrListPtr
./tags:removeAttr	VMCore/Function.cpp	/^void Argument::removeAttr(Attributes attr) {$/;"	f	class:Argument
./tags:removeAttribute	VMCore/Attributes.cpp	/^AttrBuilder &AttrBuilder::removeAttribute(Attributes::AttrVal Val) {$/;"	f	class:AttrBuilder
./tags:removeAttribute	VMCore/Function.cpp	/^void Function::removeAttribute(unsigned i, Attributes attr) {$/;"	f	class:Function
./tags:removeAttribute	VMCore/Instructions.cpp	/^void CallInst::removeAttribute(unsigned i, Attributes attr) {$/;"	f	class:CallInst
./tags:removeAttribute	VMCore/Instructions.cpp	/^void InvokeInst::removeAttribute(unsigned i, Attributes attr) {$/;"	f	class:InvokeInst
./tags:removeAttributes	VMCore/Attributes.cpp	/^AttrBuilder &AttrBuilder::removeAttributes(const Attributes &A){$/;"	f	class:AttrBuilder
./tags:typeIncompatible	VMCore/Attributes.cpp	/^Attributes Attributes::typeIncompatible(Type *Ty) {$/;"	f	class:Attributes
./tags:~AttrListPtr	VMCore/Attributes.cpp	/^AttrListPtr::~AttrListPtr() {$/;"	f	class:AttrListPtr
./tags:~AttributeEmitter	Target/ARM/ARMAsmPrinter.cpp	/^    virtual ~AttributeEmitter() {}$/;"	f	class:__anon313::AttributeEmitter
./tags:~AttributeListImpl	VMCore/Attributes.cpp	/^AttributeListImpl::~AttributeListImpl() {$/;"	f	class:AttributeListImpl
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:  class AttributeEmitter {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    virtual void EmitAttribute(unsigned Attribute, unsigned Value) = 0;
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    virtual void EmitTextAttribute(unsigned Attribute, StringRef String) = 0;
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    virtual ~AttributeEmitter() {}
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:  class AsmAttributeEmitter : public AttributeEmitter {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AsmAttributeEmitter(MCStreamer &Streamer_) : Streamer(Streamer_) {}
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    void EmitAttribute(unsigned Attribute, unsigned Value) {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:                           Twine(Attribute) + ", " + Twine(Value));
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    void EmitTextAttribute(unsigned Attribute, StringRef String) {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:      switch (Attribute) {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:  class ObjectAttributeEmitter : public AttributeEmitter {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    struct AttributeItemType {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:        HiddenAttribute = 0,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:        NumericAttribute,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:        TextAttribute
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    } AttributeItem;
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    SmallVector<AttributeItemType, 64> Contents;
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    ObjectAttributeEmitter(MCObjectStreamer &Streamer_) :
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    void EmitAttribute(unsigned Attribute, unsigned Value) {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:      AttributeItemType attr = {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:        AttributeItemType::NumericAttribute,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:        Attribute,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:      ContentsSize += getULEBSize(Attribute);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    void EmitTextAttribute(unsigned Attribute, StringRef String) {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:      AttributeItemType attr = {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:        AttributeItemType::TextAttribute,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:        Attribute,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:      ContentsSize += getULEBSize(Attribute);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:        AttributeItemType item = Contents[i];
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:        case AttributeItemType::NumericAttribute:
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:        case AttributeItemType::TextAttribute:
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:  // Emit ARM Build Attributes
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    emitAttributes();
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:        OutStreamer.EmitSymbolAttribute(MCSym.getPointer(),MCSA_IndirectSymbol);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:void ARMAsmPrinter::emitAttributes() {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:  emitARMAttributeSection();
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:  AttributeEmitter *AttrEmitter;
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter = new AsmAttributeEmitter(OutStreamer);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter = new ObjectAttributeEmitter(O);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitTextAttribute(ARMBuildAttrs::CPU_name, "cortex-a8");
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::CPU_arch, ARMBuildAttrs::v7);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::CPU_arch_profile,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ARM_ISA_use,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::THUMB_ISA_use,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    //AttrEmitter->EmitAttribute(ARMBuildAttrs::WMMX_arch,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::CPU_arch, ARMBuildAttrs::v5TEJ);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ARM_ISA_use,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::THUMB_ISA_use,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::CPU_arch, ARMBuildAttrs::v4T);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ARM_ISA_use,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::THUMB_ISA_use,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:      AttrEmitter->EmitTextAttribute(ARMBuildAttrs::Advanced_SIMD_arch,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:      AttrEmitter->EmitTextAttribute(ARMBuildAttrs::Advanced_SIMD_arch, "neon");
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::VFP_arch,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:      AttrEmitter->EmitTextAttribute(ARMBuildAttrs::VFP_arch, "vfpv4");
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::VFP_arch,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:      AttrEmitter->EmitTextAttribute(ARMBuildAttrs::VFP_arch, "vfpv3");
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::VFP_arch,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:      AttrEmitter->EmitTextAttribute(ARMBuildAttrs::VFP_arch, "vfpv2");
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::Advanced_SIMD_arch,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_FP_denormal,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_FP_exceptions,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_FP_number_model,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_FP_number_model,
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:  AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_align8_needed, 1);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:  AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_align8_preserved, 1);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_HardFP_use, 3);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_VFP_args, 1);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:    AttrEmitter->EmitAttribute(ARMBuildAttrs::DIV_use, 1);
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:void ARMAsmPrinter::emitARMAttributeSection() {
./Target/ARM/.svn/text-base/ARMAsmPrinter.cpp.svn-base:  OutStreamer.SwitchSection(TLOFELF.getAttributesSection());
./Target/ARM/.svn/text-base/ARMAsmPrinter.h.svn-base:  void emitAttributes();
./Target/ARM/.svn/text-base/ARMAsmPrinter.h.svn-base:  void emitARMAttributeSection();
./Target/ARM/.svn/text-base/ARMBaseInstrInfo.cpp.svn-base:      if (MF->getFunction()->getFnAttributes().
./Target/ARM/.svn/text-base/ARMBaseInstrInfo.cpp.svn-base:            hasAttribute(Attributes::OptimizeForSize))
./Target/ARM/.svn/text-base/ARMBaseRegisterInfo.cpp.svn-base:     F->getFnAttributes().hasAttribute(Attributes::StackAlignment));
./Target/ARM/.svn/text-base/ARMBuildAttrs.h.svn-base://===-- ARMBuildAttrs.h - ARM Build Attributes ------------------*- C++ -*-===//
./Target/ARM/.svn/text-base/ARMFastISel.cpp.svn-base:    GetReturnInfo(F.getReturnType(), F.getAttributes().getRetAttributes(),
./Target/ARM/.svn/text-base/ARMFastISel.cpp.svn-base:    if (CS.paramHasAttr(AttrInd, Attributes::SExt))
./Target/ARM/.svn/text-base/ARMFastISel.cpp.svn-base:    if (CS.paramHasAttr(AttrInd, Attributes::ZExt))
./Target/ARM/.svn/text-base/ARMFastISel.cpp.svn-base:    if (CS.paramHasAttr(AttrInd, Attributes::InReg) ||
./Target/ARM/.svn/text-base/ARMFastISel.cpp.svn-base:        CS.paramHasAttr(AttrInd, Attributes::StructRet) ||
./Target/ARM/.svn/text-base/ARMFastISel.cpp.svn-base:        CS.paramHasAttr(AttrInd, Attributes::Nest) ||
./Target/ARM/.svn/text-base/ARMFastISel.cpp.svn-base:        CS.paramHasAttr(AttrInd, Attributes::ByVal))
./Target/ARM/.svn/text-base/ARMFrameLowering.cpp.svn-base:  if (MF.getFunction()->getFnAttributes().hasAttribute(Attributes::Naked))
./Target/ARM/.svn/text-base/ARMISelLowering.cpp.svn-base:    if (!MF->getFunction()->getFnAttributes().
./Target/ARM/.svn/text-base/ARMISelLowering.cpp.svn-base:          hasAttribute(Attributes::NoImplicitFloat) &&
./Target/ARM/.svn/text-base/ARMISelLowering.cpp.svn-base:      !F->getFnAttributes().hasAttribute(Attributes::NoImplicitFloat) &&
./Target/ARM/.svn/text-base/ARMTargetObjectFile.cpp.svn-base:  AttributesSection =
./Target/ARM/.svn/text-base/ARMTargetObjectFile.h.svn-base:  const MCSection *AttributesSection;
./Target/ARM/.svn/text-base/ARMTargetObjectFile.h.svn-base:    AttributesSection(NULL)
./Target/ARM/.svn/text-base/ARMTargetObjectFile.h.svn-base:  virtual const MCSection *getAttributesSection() const {
./Target/ARM/.svn/text-base/ARMTargetObjectFile.h.svn-base:    return AttributesSection;
./Target/ARM/ARMFrameLowering.cpp:  if (MF.getFunction()->getFnAttributes().hasAttribute(Attributes::Naked))
./Target/ARM/ARMBuildAttrs.h://===-- ARMBuildAttrs.h - ARM Build Attributes ------------------*- C++ -*-===//
./Target/ARM/ARMTargetObjectFile.h:  const MCSection *AttributesSection;
./Target/ARM/ARMTargetObjectFile.h:    AttributesSection(NULL)
./Target/ARM/ARMTargetObjectFile.h:  virtual const MCSection *getAttributesSection() const {
./Target/ARM/ARMTargetObjectFile.h:    return AttributesSection;
./Target/ARM/ARMAsmPrinter.h:  void emitAttributes();
./Target/ARM/ARMAsmPrinter.h:  void emitARMAttributeSection();
./Target/ARM/ARMISelLowering.cpp:    if (!MF->getFunction()->getFnAttributes().
./Target/ARM/ARMISelLowering.cpp:          hasAttribute(Attributes::NoImplicitFloat) &&
./Target/ARM/ARMISelLowering.cpp:      !F->getFnAttributes().hasAttribute(Attributes::NoImplicitFloat) &&
./Target/ARM/ARMTargetObjectFile.cpp:  AttributesSection =
./Target/ARM/ARMBaseRegisterInfo.cpp:     F->getFnAttributes().hasAttribute(Attributes::StackAlignment));
./Target/ARM/ARMBaseInstrInfo.cpp:      if (MF->getFunction()->getFnAttributes().
./Target/ARM/ARMBaseInstrInfo.cpp:            hasAttribute(Attributes::OptimizeForSize))
./Target/ARM/ARMFastISel.cpp:    GetReturnInfo(F.getReturnType(), F.getAttributes().getRetAttributes(),
./Target/ARM/ARMFastISel.cpp:    if (CS.paramHasAttr(AttrInd, Attributes::SExt))
./Target/ARM/ARMFastISel.cpp:    if (CS.paramHasAttr(AttrInd, Attributes::ZExt))
./Target/ARM/ARMFastISel.cpp:    if (CS.paramHasAttr(AttrInd, Attributes::InReg) ||
./Target/ARM/ARMFastISel.cpp:        CS.paramHasAttr(AttrInd, Attributes::StructRet) ||
./Target/ARM/ARMFastISel.cpp:        CS.paramHasAttr(AttrInd, Attributes::Nest) ||
./Target/ARM/ARMFastISel.cpp:        CS.paramHasAttr(AttrInd, Attributes::ByVal))
./Target/ARM/ARMAsmPrinter.cpp:  class AttributeEmitter {
./Target/ARM/ARMAsmPrinter.cpp:    virtual void EmitAttribute(unsigned Attribute, unsigned Value) = 0;
./Target/ARM/ARMAsmPrinter.cpp:    virtual void EmitTextAttribute(unsigned Attribute, StringRef String) = 0;
./Target/ARM/ARMAsmPrinter.cpp:    virtual ~AttributeEmitter() {}
./Target/ARM/ARMAsmPrinter.cpp:  class AsmAttributeEmitter : public AttributeEmitter {
./Target/ARM/ARMAsmPrinter.cpp:    AsmAttributeEmitter(MCStreamer &Streamer_) : Streamer(Streamer_) {}
./Target/ARM/ARMAsmPrinter.cpp:    void EmitAttribute(unsigned Attribute, unsigned Value) {
./Target/ARM/ARMAsmPrinter.cpp:                           Twine(Attribute) + ", " + Twine(Value));
./Target/ARM/ARMAsmPrinter.cpp:    void EmitTextAttribute(unsigned Attribute, StringRef String) {
./Target/ARM/ARMAsmPrinter.cpp:      switch (Attribute) {
./Target/ARM/ARMAsmPrinter.cpp:  class ObjectAttributeEmitter : public AttributeEmitter {
./Target/ARM/ARMAsmPrinter.cpp:    struct AttributeItemType {
./Target/ARM/ARMAsmPrinter.cpp:        HiddenAttribute = 0,
./Target/ARM/ARMAsmPrinter.cpp:        NumericAttribute,
./Target/ARM/ARMAsmPrinter.cpp:        TextAttribute
./Target/ARM/ARMAsmPrinter.cpp:    } AttributeItem;
./Target/ARM/ARMAsmPrinter.cpp:    SmallVector<AttributeItemType, 64> Contents;
./Target/ARM/ARMAsmPrinter.cpp:    ObjectAttributeEmitter(MCObjectStreamer &Streamer_) :
./Target/ARM/ARMAsmPrinter.cpp:    void EmitAttribute(unsigned Attribute, unsigned Value) {
./Target/ARM/ARMAsmPrinter.cpp:      AttributeItemType attr = {
./Target/ARM/ARMAsmPrinter.cpp:        AttributeItemType::NumericAttribute,
./Target/ARM/ARMAsmPrinter.cpp:        Attribute,
./Target/ARM/ARMAsmPrinter.cpp:      ContentsSize += getULEBSize(Attribute);
./Target/ARM/ARMAsmPrinter.cpp:    void EmitTextAttribute(unsigned Attribute, StringRef String) {
./Target/ARM/ARMAsmPrinter.cpp:      AttributeItemType attr = {
./Target/ARM/ARMAsmPrinter.cpp:        AttributeItemType::TextAttribute,
./Target/ARM/ARMAsmPrinter.cpp:        Attribute,
./Target/ARM/ARMAsmPrinter.cpp:      ContentsSize += getULEBSize(Attribute);
./Target/ARM/ARMAsmPrinter.cpp:        AttributeItemType item = Contents[i];
./Target/ARM/ARMAsmPrinter.cpp:        case AttributeItemType::NumericAttribute:
./Target/ARM/ARMAsmPrinter.cpp:        case AttributeItemType::TextAttribute:
./Target/ARM/ARMAsmPrinter.cpp:  // Emit ARM Build Attributes
./Target/ARM/ARMAsmPrinter.cpp:    emitAttributes();
./Target/ARM/ARMAsmPrinter.cpp:        OutStreamer.EmitSymbolAttribute(MCSym.getPointer(),MCSA_IndirectSymbol);
./Target/ARM/ARMAsmPrinter.cpp:void ARMAsmPrinter::emitAttributes() {
./Target/ARM/ARMAsmPrinter.cpp:  emitARMAttributeSection();
./Target/ARM/ARMAsmPrinter.cpp:  AttributeEmitter *AttrEmitter;
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter = new AsmAttributeEmitter(OutStreamer);
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter = new ObjectAttributeEmitter(O);
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitTextAttribute(ARMBuildAttrs::CPU_name, "cortex-a8");
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::CPU_arch, ARMBuildAttrs::v7);
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::CPU_arch_profile,
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ARM_ISA_use,
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::THUMB_ISA_use,
./Target/ARM/ARMAsmPrinter.cpp:    //AttrEmitter->EmitAttribute(ARMBuildAttrs::WMMX_arch,
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::CPU_arch, ARMBuildAttrs::v5TEJ);
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ARM_ISA_use,
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::THUMB_ISA_use,
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::CPU_arch, ARMBuildAttrs::v4T);
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ARM_ISA_use,
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::THUMB_ISA_use,
./Target/ARM/ARMAsmPrinter.cpp:      AttrEmitter->EmitTextAttribute(ARMBuildAttrs::Advanced_SIMD_arch,
./Target/ARM/ARMAsmPrinter.cpp:      AttrEmitter->EmitTextAttribute(ARMBuildAttrs::Advanced_SIMD_arch, "neon");
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::VFP_arch,
./Target/ARM/ARMAsmPrinter.cpp:      AttrEmitter->EmitTextAttribute(ARMBuildAttrs::VFP_arch, "vfpv4");
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::VFP_arch,
./Target/ARM/ARMAsmPrinter.cpp:      AttrEmitter->EmitTextAttribute(ARMBuildAttrs::VFP_arch, "vfpv3");
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::VFP_arch,
./Target/ARM/ARMAsmPrinter.cpp:      AttrEmitter->EmitTextAttribute(ARMBuildAttrs::VFP_arch, "vfpv2");
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::Advanced_SIMD_arch,
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_FP_denormal,
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_FP_exceptions,
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_FP_number_model,
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_FP_number_model,
./Target/ARM/ARMAsmPrinter.cpp:  AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_align8_needed, 1);
./Target/ARM/ARMAsmPrinter.cpp:  AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_align8_preserved, 1);
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_HardFP_use, 3);
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::ABI_VFP_args, 1);
./Target/ARM/ARMAsmPrinter.cpp:    AttrEmitter->EmitAttribute(ARMBuildAttrs::DIV_use, 1);
./Target/ARM/ARMAsmPrinter.cpp:void ARMAsmPrinter::emitARMAttributeSection() {
./Target/ARM/ARMAsmPrinter.cpp:  OutStreamer.SwitchSection(TLOFELF.getAttributesSection());
./Target/NVPTX/.svn/text-base/NVPTXAsmPrinter.cpp.svn-base:  const AttrListPtr &PAL = F->getAttributes();
./Target/NVPTX/.svn/text-base/NVPTXAsmPrinter.cpp.svn-base:    if (PAL.getParamAttributes(paramIndex+1).
./Target/NVPTX/.svn/text-base/NVPTXAsmPrinter.cpp.svn-base:          hasAttribute(Attributes::ByVal) == false) {
./Target/NVPTX/.svn/text-base/NVPTXISelLowering.cpp.svn-base:  const AttrListPtr &PAL = F->getAttributes();
./Target/NVPTX/.svn/text-base/NVPTXISelLowering.cpp.svn-base:    if (PAL.getParamAttributes(i+1).hasAttribute(Attributes::ByVal) == false) {
./Target/NVPTX/NVPTXISelLowering.cpp:  const AttrListPtr &PAL = F->getAttributes();
./Target/NVPTX/NVPTXISelLowering.cpp:    if (PAL.getParamAttributes(i+1).hasAttribute(Attributes::ByVal) == false) {
./Target/NVPTX/NVPTXAsmPrinter.cpp:  const AttrListPtr &PAL = F->getAttributes();
./Target/NVPTX/NVPTXAsmPrinter.cpp:    if (PAL.getParamAttributes(paramIndex+1).
./Target/NVPTX/NVPTXAsmPrinter.cpp:          hasAttribute(Attributes::ByVal) == false) {
./Target/PowerPC/.svn/text-base/PPCAsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(RawSym, MCSA_IndirectSymbol);
./Target/PowerPC/.svn/text-base/PPCAsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(RawSym, MCSA_IndirectSymbol);
./Target/PowerPC/.svn/text-base/PPCAsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(RawSym, MCSA_IndirectSymbol);
./Target/PowerPC/.svn/text-base/PPCAsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(RawSym, MCSA_IndirectSymbol);
./Target/PowerPC/.svn/text-base/PPCAsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(MCSym.getPointer(), MCSA_IndirectSymbol);
./Target/PowerPC/.svn/text-base/PPCFrameLowering.cpp.svn-base:  bool DisableRedZone = MF.getFunction()->getFnAttributes().
./Target/PowerPC/.svn/text-base/PPCFrameLowering.cpp.svn-base:    hasAttribute(Attributes::NoRedZone);
./Target/PowerPC/.svn/text-base/PPCFrameLowering.cpp.svn-base:  if (MF.getFunction()->getFnAttributes().hasAttribute(Attributes::Naked))
./Target/PowerPC/.svn/text-base/PPCISelLowering.cpp.svn-base:                  !MF.getFunction()->getFnAttributes().
./Target/PowerPC/.svn/text-base/PPCISelLowering.cpp.svn-base:                    hasAttribute(Attributes::Naked);
./Target/PowerPC/.svn/text-base/PPCRegisterInfo.cpp.svn-base:  if (!MF.getFunction()->getFnAttributes().hasAttribute(Attributes::Naked))
./Target/PowerPC/PPCRegisterInfo.cpp:  if (!MF.getFunction()->getFnAttributes().hasAttribute(Attributes::Naked))
./Target/PowerPC/PPCFrameLowering.cpp:  bool DisableRedZone = MF.getFunction()->getFnAttributes().
./Target/PowerPC/PPCFrameLowering.cpp:    hasAttribute(Attributes::NoRedZone);
./Target/PowerPC/PPCFrameLowering.cpp:  if (MF.getFunction()->getFnAttributes().hasAttribute(Attributes::Naked))
./Target/PowerPC/PPCISelLowering.cpp:                  !MF.getFunction()->getFnAttributes().
./Target/PowerPC/PPCISelLowering.cpp:                    hasAttribute(Attributes::Naked);
./Target/PowerPC/PPCAsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(RawSym, MCSA_IndirectSymbol);
./Target/PowerPC/PPCAsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(RawSym, MCSA_IndirectSymbol);
./Target/PowerPC/PPCAsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(RawSym, MCSA_IndirectSymbol);
./Target/PowerPC/PPCAsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(RawSym, MCSA_IndirectSymbol);
./Target/PowerPC/PPCAsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(MCSym.getPointer(), MCSA_IndirectSymbol);
./Target/XCore/.svn/text-base/XCoreAsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(Sym, MCSA_Global);
./Target/XCore/.svn/text-base/XCoreAsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
./Target/XCore/.svn/text-base/XCoreAsmPrinter.cpp.svn-base:      OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Weak);
./Target/XCore/.svn/text-base/XCoreAsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_ELF_TypeObject);
./Target/XCore/.svn/text-base/XCoreFrameLowering.cpp.svn-base:  const AttrListPtr &PAL = MF.getFunction()->getAttributes();
./Target/XCore/.svn/text-base/XCoreFrameLowering.cpp.svn-base:    if (PAL.getAttributesAtIndex(I).hasAttribute(Attributes::Nest)) {
./Target/XCore/XCoreFrameLowering.cpp:  const AttrListPtr &PAL = MF.getFunction()->getAttributes();
./Target/XCore/XCoreFrameLowering.cpp:    if (PAL.getAttributesAtIndex(I).hasAttribute(Attributes::Nest)) {
./Target/XCore/XCoreAsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(Sym, MCSA_Global);
./Target/XCore/XCoreAsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Global);
./Target/XCore/XCoreAsmPrinter.cpp:      OutStreamer.EmitSymbolAttribute(GVSym, MCSA_Weak);
./Target/XCore/XCoreAsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(GVSym, MCSA_ELF_TypeObject);
./Target/X86/.svn/text-base/X86AsmPrinter.cpp.svn-base:        OutStreamer.EmitSymbolAttribute(Stubs[i].second.getPointer(),
./Target/X86/.svn/text-base/X86AsmPrinter.cpp.svn-base:        OutStreamer.EmitSymbolAttribute(MCSym.getPointer(),
./Target/X86/.svn/text-base/X86AsmPrinter.cpp.svn-base:    OutStreamer.EmitSymbolAttribute(S, MCSA_Global);
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:    GetReturnInfo(F.getReturnType(), F.getAttributes().getRetAttributes(),
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:  if (!CS.paramHasAttr(1, Attributes::StructRet))
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:  if (CS.paramHasAttr(1, Attributes::InReg))
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:  GetReturnInfo(I->getType(), CS.getAttributes().getRetAttributes(),
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:    if (CS.paramHasAttr(AttrInd, Attributes::SExt))
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:    if (CS.paramHasAttr(AttrInd, Attributes::ZExt))
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:    if (CS.paramHasAttr(AttrInd, Attributes::ByVal)) {
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:    if (CS.paramHasAttr(AttrInd, Attributes::InReg))
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:    if (CS.paramHasAttr(AttrInd, Attributes::Nest))
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:      if (CS.paramHasAttr(0, Attributes::SExt))
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:      if (CS.paramHasAttr(0, Attributes::ZExt))
./Target/X86/.svn/text-base/X86FastISel.cpp.svn-base:      if (CS.paramHasAttr(0, Attributes::InReg))
./Target/X86/.svn/text-base/X86FrameLowering.cpp.svn-base:  if (Is64Bit && !Fn->getFnAttributes().hasAttribute(Attributes::NoRedZone) &&
./Target/X86/.svn/text-base/X86ISelDAGToDAG.cpp.svn-base:  OptForSize = MF->getFunction()->getFnAttributes().
./Target/X86/.svn/text-base/X86ISelDAGToDAG.cpp.svn-base:    hasAttribute(Attributes::OptimizeForSize);
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:      !F->getFnAttributes().hasAttribute(Attributes::NoImplicitFloat)) {
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:      bool NoImplicitFloatOps = Fn->getFnAttributes().
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:        hasAttribute(Attributes::NoImplicitFloat);
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:                 cast<Function>(GV)->getFnAttributes().
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:                   hasAttribute(Attributes::NonLazyBind)) {
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:  bool OptForSize = MF.getFunction()->getFnAttributes().
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:    hasAttribute(Attributes::OptimizeForSize);
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:                .getFunction()->getFnAttributes()
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:                .hasAttribute(Attributes::NoImplicitFloat)) &&
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:      const AttrListPtr &Attrs = Func->getAttributes();
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:          if (Attrs.getParamAttributes(Idx).hasAttribute(Attributes::InReg))
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:  bool NoImplicitFloatOps = F->getFnAttributes().
./Target/X86/.svn/text-base/X86ISelLowering.cpp.svn-base:    hasAttribute(Attributes::NoImplicitFloat);
./Target/X86/.svn/text-base/X86InstrFormats.td.svn-base:  // Attributes specific to X86 instructions...
./Target/X86/.svn/text-base/X86InstrInfo.cpp.svn-base:  if (!MF.getFunction()->getFnAttributes().
./Target/X86/.svn/text-base/X86InstrInfo.cpp.svn-base:        hasAttribute(Attributes::OptimizeForSize) &&
./Target/X86/.svn/text-base/X86InstrInfo.cpp.svn-base:  if (!MF.getFunction()->getFnAttributes().
./Target/X86/.svn/text-base/X86InstrInfo.cpp.svn-base:        hasAttribute(Attributes::OptimizeForSize) &&
./Target/X86/.svn/text-base/X86RegisterInfo.cpp.svn-base:     F->getFnAttributes().hasAttribute(Attributes::StackAlignment));
./Target/X86/MCTargetDesc/.svn/text-base/X86MachObjectWriter.cpp.svn-base:      if (Section.hasAttribute(MCSectionMachO::S_ATTR_DEBUG))
./Target/X86/MCTargetDesc/X86MachObjectWriter.cpp:      if (Section.hasAttribute(MCSectionMachO::S_ATTR_DEBUG))
./Target/X86/Disassembler/.svn/text-base/X86DisassemblerDecoder.c.svn-base: * @param attrMask  - Attributes, from the enumeration attributeBits.
./Target/X86/Disassembler/.svn/text-base/X86DisassemblerDecoderCommon.h.svn-base: * Attributes of an instruction that must be known before the opcode can be
./Target/X86/Disassembler/X86DisassemblerDecoderCommon.h: * Attributes of an instruction that must be known before the opcode can be
./Target/X86/Disassembler/X86DisassemblerDecoder.c: * @param attrMask  - Attributes, from the enumeration attributeBits.
./Target/X86/X86ISelLowering.cpp:      !F->getFnAttributes().hasAttribute(Attributes::NoImplicitFloat)) {
./Target/X86/X86ISelLowering.cpp:      bool NoImplicitFloatOps = Fn->getFnAttributes().
./Target/X86/X86ISelLowering.cpp:        hasAttribute(Attributes::NoImplicitFloat);
./Target/X86/X86ISelLowering.cpp:                 cast<Function>(GV)->getFnAttributes().
./Target/X86/X86ISelLowering.cpp:                   hasAttribute(Attributes::NonLazyBind)) {
./Target/X86/X86ISelLowering.cpp:  bool OptForSize = MF.getFunction()->getFnAttributes().
./Target/X86/X86ISelLowering.cpp:    hasAttribute(Attributes::OptimizeForSize);
./Target/X86/X86ISelLowering.cpp:                .getFunction()->getFnAttributes()
./Target/X86/X86ISelLowering.cpp:                .hasAttribute(Attributes::NoImplicitFloat)) &&
./Target/X86/X86ISelLowering.cpp:      const AttrListPtr &Attrs = Func->getAttributes();
./Target/X86/X86ISelLowering.cpp:          if (Attrs.getParamAttributes(Idx).hasAttribute(Attributes::InReg))
./Target/X86/X86ISelLowering.cpp:  bool NoImplicitFloatOps = F->getFnAttributes().
./Target/X86/X86ISelLowering.cpp:    hasAttribute(Attributes::NoImplicitFloat);
./Target/X86/X86ISelDAGToDAG.cpp:  OptForSize = MF->getFunction()->getFnAttributes().
./Target/X86/X86ISelDAGToDAG.cpp:    hasAttribute(Attributes::OptimizeForSize);
./Target/X86/X86FrameLowering.cpp:  if (Is64Bit && !Fn->getFnAttributes().hasAttribute(Attributes::NoRedZone) &&
./Target/X86/X86InstrInfo.cpp:  if (!MF.getFunction()->getFnAttributes().
./Target/X86/X86InstrInfo.cpp:        hasAttribute(Attributes::OptimizeForSize) &&
./Target/X86/X86InstrInfo.cpp:  if (!MF.getFunction()->getFnAttributes().
./Target/X86/X86InstrInfo.cpp:        hasAttribute(Attributes::OptimizeForSize) &&
./Target/X86/X86RegisterInfo.cpp:     F->getFnAttributes().hasAttribute(Attributes::StackAlignment));
./Target/X86/X86FastISel.cpp:    GetReturnInfo(F.getReturnType(), F.getAttributes().getRetAttributes(),
./Target/X86/X86FastISel.cpp:  if (!CS.paramHasAttr(1, Attributes::StructRet))
./Target/X86/X86FastISel.cpp:  if (CS.paramHasAttr(1, Attributes::InReg))
./Target/X86/X86FastISel.cpp:  GetReturnInfo(I->getType(), CS.getAttributes().getRetAttributes(),
./Target/X86/X86FastISel.cpp:    if (CS.paramHasAttr(AttrInd, Attributes::SExt))
./Target/X86/X86FastISel.cpp:    if (CS.paramHasAttr(AttrInd, Attributes::ZExt))
./Target/X86/X86FastISel.cpp:    if (CS.paramHasAttr(AttrInd, Attributes::ByVal)) {
./Target/X86/X86FastISel.cpp:    if (CS.paramHasAttr(AttrInd, Attributes::InReg))
./Target/X86/X86FastISel.cpp:    if (CS.paramHasAttr(AttrInd, Attributes::Nest))
./Target/X86/X86FastISel.cpp:      if (CS.paramHasAttr(0, Attributes::SExt))
./Target/X86/X86FastISel.cpp:      if (CS.paramHasAttr(0, Attributes::ZExt))
./Target/X86/X86FastISel.cpp:      if (CS.paramHasAttr(0, Attributes::InReg))
./Target/X86/X86AsmPrinter.cpp:        OutStreamer.EmitSymbolAttribute(Stubs[i].second.getPointer(),
./Target/X86/X86AsmPrinter.cpp:        OutStreamer.EmitSymbolAttribute(MCSym.getPointer(),
./Target/X86/X86AsmPrinter.cpp:    OutStreamer.EmitSymbolAttribute(S, MCSA_Global);
./Target/X86/X86InstrFormats.td:  // Attributes specific to X86 instructions...
./Target/Hexagon/.svn/text-base/HexagonRemoveSZExtArgs.cpp.svn-base:    if (F.getParamAttributes(Idx).hasAttribute(Attributes::SExt)) {
./Target/Hexagon/HexagonRemoveSZExtArgs.cpp:    if (F.getParamAttributes(Idx).hasAttribute(Attributes::SExt)) {
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:    void printAttributes(const AttrListPtr &PAL, const std::string &name);
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:void CppWriter::printAttributes(const AttrListPtr &PAL,
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:    Out << "SmallVector<AttributeWithIndex, 4> Attrs;"; nl(Out);
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:    Out << "AttributeWithIndex PAWI;"; nl(Out);
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:      if (attrs.hasAttribute(Attributes::X))               \
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:        Out << "   B.addAttribute(Attributes::" #X ");\n"; \
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:      attrs.removeAttribute(Attributes::X);
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:      if (attrs.hasAttribute(Attributes::StackAlignment))
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:      attrs.removeAttribute(Attributes::StackAlignment);
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:      assert(!attrs.hasAttributes() && "Unhandled attribute!");
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:      Out << "PAWI.Attrs = Attributes::get(mod->getContext(), B);";
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:    printAttributes(inv->getAttributes(), iName);
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:    Out << iName << "->setAttributes(" << iName << "_PAL);";
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:    printAttributes(call->getAttributes(), iName);
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:    Out << iName << "->setAttributes(" << iName << "_PAL);";
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:  printAttributes(F->getAttributes(), getCppName(F));
./Target/CppBackend/.svn/text-base/CPPBackend.cpp.svn-base:  Out << "->setAttributes(" << getCppName(F) << "_PAL);";
./Target/CppBackend/CPPBackend.cpp:    void printAttributes(const AttrListPtr &PAL, const std::string &name);
./Target/CppBackend/CPPBackend.cpp:void CppWriter::printAttributes(const AttrListPtr &PAL,
./Target/CppBackend/CPPBackend.cpp:    Out << "SmallVector<AttributeWithIndex, 4> Attrs;"; nl(Out);
./Target/CppBackend/CPPBackend.cpp:    Out << "AttributeWithIndex PAWI;"; nl(Out);
./Target/CppBackend/CPPBackend.cpp:      if (attrs.hasAttribute(Attributes::X))               \
./Target/CppBackend/CPPBackend.cpp:        Out << "   B.addAttribute(Attributes::" #X ");\n"; \
./Target/CppBackend/CPPBackend.cpp:      attrs.removeAttribute(Attributes::X);
./Target/CppBackend/CPPBackend.cpp:      if (attrs.hasAttribute(Attributes::StackAlignment))
./Target/CppBackend/CPPBackend.cpp:      attrs.removeAttribute(Attributes::StackAlignment);
./Target/CppBackend/CPPBackend.cpp:      assert(!attrs.hasAttributes() && "Unhandled attribute!");
./Target/CppBackend/CPPBackend.cpp:      Out << "PAWI.Attrs = Attributes::get(mod->getContext(), B);";
./Target/CppBackend/CPPBackend.cpp:    printAttributes(inv->getAttributes(), iName);
./Target/CppBackend/CPPBackend.cpp:    Out << iName << "->setAttributes(" << iName << "_PAL);";
./Target/CppBackend/CPPBackend.cpp:    printAttributes(call->getAttributes(), iName);
./Target/CppBackend/CPPBackend.cpp:    Out << iName << "->setAttributes(" << iName << "_PAL);";
./Target/CppBackend/CPPBackend.cpp:  printAttributes(F->getAttributes(), getCppName(F));
./Target/CppBackend/CPPBackend.cpp:  Out << "->setAttributes(" << getCppName(F) << "_PAL);";
./Target/Mips/.svn/text-base/Mips16InstrFormats.td.svn-base:  // Attributes specific to Mips instructions...
./Target/Mips/.svn/text-base/MipsInstrFormats.td.svn-base:  // Attributes specific to Mips instructions...
./Target/Mips/MipsInstrFormats.td:  // Attributes specific to Mips instructions...
./Target/Mips/Mips16InstrFormats.td:  // Attributes specific to Mips instructions...
./Target/MBlaze/.svn/text-base/MBlazeIntrinsicInfo.cpp.svn-base:/// This defines the "getAttributes(LLVMContext &C, ID id)" method.
./Target/MBlaze/.svn/text-base/MBlazeIntrinsicInfo.cpp.svn-base:  AttrListPtr AList = getAttributes(M->getContext(),
./Target/MBlaze/MBlazeIntrinsicInfo.cpp:/// This defines the "getAttributes(LLVMContext &C, ID id)" method.
./Target/MBlaze/MBlazeIntrinsicInfo.cpp:  AttrListPtr AList = getAttributes(M->getContext(),
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI[2];
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                   ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI[2];
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                   ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI =
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:    AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                            ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI[3];
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[1] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[2] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                   ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI[2];
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[0] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                   Attributes::NoUnwind);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI[2];
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[0] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                   Attributes::NoUnwind);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI;
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                Attributes::NoUnwind);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI;
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI[3];
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[1] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[2] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                   ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  CI->setAttributes(Attrs);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI[2];
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                   Attributes::NoUnwind);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI[2];
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[0] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                   Attributes::NoUnwind);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI[3];
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[1] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[2] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                   Attributes::NoUnwind);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AttributeWithIndex AWI[3];
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[1] = AttributeWithIndex::get(M->getContext(), 4, Attributes::NoCapture);
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:  AWI[2] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/.svn/text-base/BuildLibCalls.cpp.svn-base:                                   Attributes::NoUnwind);
./Transforms/Utils/.svn/text-base/CloneFunction.cpp.svn-base:    NewFunc->copyAttributesFrom(OldFunc);
./Transforms/Utils/.svn/text-base/CloneFunction.cpp.svn-base:        Anew->addAttr( OldFunc->getAttributes()
./Transforms/Utils/.svn/text-base/CloneFunction.cpp.svn-base:                       .getParamAttributes(I->getArgNo() + 1));
./Transforms/Utils/.svn/text-base/CloneFunction.cpp.svn-base:    NewFunc->setAttributes(NewFunc->getAttributes()
./Transforms/Utils/.svn/text-base/CloneFunction.cpp.svn-base:                                    OldFunc->getAttributes()
./Transforms/Utils/.svn/text-base/CloneFunction.cpp.svn-base:                                     .getRetAttributes()));
./Transforms/Utils/.svn/text-base/CloneFunction.cpp.svn-base:    NewFunc->setAttributes(NewFunc->getAttributes()
./Transforms/Utils/.svn/text-base/CloneFunction.cpp.svn-base:                                    OldFunc->getAttributes()
./Transforms/Utils/.svn/text-base/CloneFunction.cpp.svn-base:                                     .getFnAttributes()));
./Transforms/Utils/.svn/text-base/CloneModule.cpp.svn-base:    GV->copyAttributesFrom(I);
./Transforms/Utils/.svn/text-base/CloneModule.cpp.svn-base:    NF->copyAttributesFrom(I);
./Transforms/Utils/.svn/text-base/CloneModule.cpp.svn-base:    GA->copyAttributesFrom(I);
./Transforms/Utils/.svn/text-base/InlineFunction.cpp.svn-base:#include "llvm/Attributes.h"
./Transforms/Utils/.svn/text-base/InlineFunction.cpp.svn-base:    II->setAttributes(CI->getAttributes());
./Transforms/Utils/.svn/text-base/LowerInvoke.cpp.svn-base:      NewCall->setAttributes(II->getAttributes());
./Transforms/Utils/.svn/text-base/LowerInvoke.cpp.svn-base:  NewCall->setAttributes(II->getAttributes());
./Transforms/Utils/.svn/text-base/SimplifyCFG.cpp.svn-base:    Call->setAttributes(II->getAttributes());
./Transforms/Utils/.svn/text-base/SimplifyCFG.cpp.svn-base:        CI->setAttributes(II->getAttributes());
./Transforms/Utils/CloneFunction.cpp:    NewFunc->copyAttributesFrom(OldFunc);
./Transforms/Utils/CloneFunction.cpp:        Anew->addAttr( OldFunc->getAttributes()
./Transforms/Utils/CloneFunction.cpp:                       .getParamAttributes(I->getArgNo() + 1));
./Transforms/Utils/CloneFunction.cpp:    NewFunc->setAttributes(NewFunc->getAttributes()
./Transforms/Utils/CloneFunction.cpp:                                    OldFunc->getAttributes()
./Transforms/Utils/CloneFunction.cpp:                                     .getRetAttributes()));
./Transforms/Utils/CloneFunction.cpp:    NewFunc->setAttributes(NewFunc->getAttributes()
./Transforms/Utils/CloneFunction.cpp:                                    OldFunc->getAttributes()
./Transforms/Utils/CloneFunction.cpp:                                     .getFnAttributes()));
./Transforms/Utils/InlineFunction.cpp:#include "llvm/Attributes.h"
./Transforms/Utils/InlineFunction.cpp:    II->setAttributes(CI->getAttributes());
./Transforms/Utils/LowerInvoke.cpp:      NewCall->setAttributes(II->getAttributes());
./Transforms/Utils/LowerInvoke.cpp:  NewCall->setAttributes(II->getAttributes());
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI[2];
./Transforms/Utils/BuildLibCalls.cpp:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/BuildLibCalls.cpp:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                   ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI[2];
./Transforms/Utils/BuildLibCalls.cpp:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/BuildLibCalls.cpp:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                   ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/BuildLibCalls.cpp:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI =
./Transforms/Utils/BuildLibCalls.cpp:    AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                            ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI[3];
./Transforms/Utils/BuildLibCalls.cpp:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  AWI[1] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/BuildLibCalls.cpp:  AWI[2] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                   ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI[2];
./Transforms/Utils/BuildLibCalls.cpp:  AWI[0] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                   Attributes::NoUnwind);
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI[2];
./Transforms/Utils/BuildLibCalls.cpp:  AWI[0] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                   Attributes::NoUnwind);
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI;
./Transforms/Utils/BuildLibCalls.cpp:  AWI = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                Attributes::NoUnwind);
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI;
./Transforms/Utils/BuildLibCalls.cpp:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/BuildLibCalls.cpp:  AWI = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI[3];
./Transforms/Utils/BuildLibCalls.cpp:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  AWI[1] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  Attributes::AttrVal AVs[2] = { Attributes::ReadOnly, Attributes::NoUnwind };
./Transforms/Utils/BuildLibCalls.cpp:  AWI[2] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                   ArrayRef<Attributes::AttrVal>(AVs, 2));
./Transforms/Utils/BuildLibCalls.cpp:  CI->setAttributes(Attrs);
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI[2];
./Transforms/Utils/BuildLibCalls.cpp:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                   Attributes::NoUnwind);
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI[2];
./Transforms/Utils/BuildLibCalls.cpp:  AWI[0] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  AWI[1] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                   Attributes::NoUnwind);
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI[3];
./Transforms/Utils/BuildLibCalls.cpp:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  AWI[1] = AttributeWithIndex::get(M->getContext(), 2, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  AWI[2] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                   Attributes::NoUnwind);
./Transforms/Utils/BuildLibCalls.cpp:  AttributeWithIndex AWI[3];
./Transforms/Utils/BuildLibCalls.cpp:  AWI[0] = AttributeWithIndex::get(M->getContext(), 1, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  AWI[1] = AttributeWithIndex::get(M->getContext(), 4, Attributes::NoCapture);
./Transforms/Utils/BuildLibCalls.cpp:  AWI[2] = AttributeWithIndex::get(M->getContext(), AttrListPtr::FunctionIndex,
./Transforms/Utils/BuildLibCalls.cpp:                                   Attributes::NoUnwind);
./Transforms/Utils/CloneModule.cpp:    GV->copyAttributesFrom(I);
./Transforms/Utils/CloneModule.cpp:    NF->copyAttributesFrom(I);
./Transforms/Utils/CloneModule.cpp:    GA->copyAttributesFrom(I);
./Transforms/Utils/SimplifyCFG.cpp:    Call->setAttributes(II->getAttributes());
./Transforms/Utils/SimplifyCFG.cpp:        CI->setAttributes(II->getAttributes());
./Transforms/Instrumentation/.svn/text-base/AddressSanitizer.cpp.svn-base:    NewGlobal->copyAttributesFrom(G);
./Transforms/Instrumentation/.svn/text-base/AddressSanitizer.cpp.svn-base:  if (!F.getFnAttributes().hasAttribute(Attributes::AddressSafety))
./Transforms/Instrumentation/.svn/text-base/GCOVProfiling.cpp.svn-base:  F->addFnAttr(Attributes::NoInline);
./Transforms/Instrumentation/.svn/text-base/GCOVProfiling.cpp.svn-base:  Fn->addFnAttr(Attributes::NoInline);
./Transforms/Instrumentation/GCOVProfiling.cpp:  F->addFnAttr(Attributes::NoInline);
./Transforms/Instrumentation/GCOVProfiling.cpp:  Fn->addFnAttr(Attributes::NoInline);
./Transforms/Instrumentation/AddressSanitizer.cpp:    NewGlobal->copyAttributesFrom(G);
./Transforms/Instrumentation/AddressSanitizer.cpp:  if (!F.getFnAttributes().hasAttribute(Attributes::AddressSafety))
./Transforms/Scalar/.svn/text-base/CodeGenPrepare.cpp.svn-base:  OptSize = F.getFnAttributes().hasAttribute(Attributes::OptimizeForSize);
./Transforms/Scalar/.svn/text-base/CodeGenPrepare.cpp.svn-base:  Attributes CallerRetAttr = F->getAttributes().getRetAttributes();
./Transforms/Scalar/.svn/text-base/CodeGenPrepare.cpp.svn-base:  if (CallerRetAttr.hasAttribute(Attributes::ZExt) ||
./Transforms/Scalar/.svn/text-base/CodeGenPrepare.cpp.svn-base:      CallerRetAttr.hasAttribute(Attributes::SExt))
./Transforms/Scalar/.svn/text-base/CodeGenPrepare.cpp.svn-base:    Attributes CalleeRetAttr = CS.getAttributes().getRetAttributes();
./Transforms/Scalar/.svn/text-base/CodeGenPrepare.cpp.svn-base:          removeAttribute(Attributes::NoAlias) !=
./Transforms/Scalar/.svn/text-base/CodeGenPrepare.cpp.svn-base:          removeAttribute(Attributes::NoAlias))
./Transforms/Scalar/.svn/text-base/GlobalMerge.cpp.svn-base:#include "llvm/Attributes.h"
./Transforms/Scalar/.svn/text-base/LoopUnrollPass.cpp.svn-base:      Header->getParent()->getFnAttributes().
./Transforms/Scalar/.svn/text-base/LoopUnrollPass.cpp.svn-base:        hasAttribute(Attributes::OptimizeForSize))
./Transforms/Scalar/.svn/text-base/LoopUnswitch.cpp.svn-base:      F->getFnAttributes().hasAttribute(Attributes::OptimizeForSize))
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:    AttrListPtr Attributes =
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:                             Attributes);
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:    AttrListPtr Attributes =
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:                             Attributes);
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:    AttrListPtr Attributes =
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:        Attributes);
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:    AttrListPtr Attributes =
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:        Attributes);
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:    AttrListPtr Attributes =
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:        Attributes);
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:    AttrListPtr Attributes = AttrListPtr()
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:               Attributes::get(C, Attributes::NoUnwind))
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:      .addAttr(M->getContext(), 1, Attributes::get(C, Attributes::NoCapture));
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:        Attributes);
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:    AttrListPtr Attributes =
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:      M->getOrInsertFunction("objc_retainAutorelease", FTy, Attributes);
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:    AttrListPtr Attributes =
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/.svn/text-base/ObjCARC.cpp.svn-base:                             Attributes);
./Transforms/Scalar/.svn/text-base/SimplifyCFGPass.cpp.svn-base:#include "llvm/Attributes.h"
./Transforms/Scalar/.svn/text-base/SimplifyCFGPass.cpp.svn-base:  NewCall->setAttributes(II->getAttributes());
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:      CI->addAttribute(1, Attributes::get(Callee->getContext(),
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:                                          Attributes::NoCapture));
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:    V = EmitUnaryFloatFnCall(V, Callee->getName(), B, Callee->getAttributes());
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:        return EmitUnaryFloatFnCall(Op2, "exp2", B, Callee->getAttributes());
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:                                         Callee->getAttributes());
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:                                         Callee->getAttributes());
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:        M->getOrInsertFunction("iprintf", FT, Callee->getAttributes());
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:        M->getOrInsertFunction("siprintf", FT, Callee->getAttributes());
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:        M->getOrInsertFunction("fiprintf", FT, Callee->getAttributes());
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:    void inferPrototypeAttributes(Function &F);
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:void SimplifyLibCalls::inferPrototypeAttributes(Function &F) {
./Transforms/Scalar/.svn/text-base/SimplifyLibCalls.cpp.svn-base:      inferPrototypeAttributes(F);
./Transforms/Scalar/LoopUnswitch.cpp:      F->getFnAttributes().hasAttribute(Attributes::OptimizeForSize))
./Transforms/Scalar/ObjCARC.cpp:    AttrListPtr Attributes =
./Transforms/Scalar/ObjCARC.cpp:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/ObjCARC.cpp:                             Attributes);
./Transforms/Scalar/ObjCARC.cpp:    AttrListPtr Attributes =
./Transforms/Scalar/ObjCARC.cpp:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/ObjCARC.cpp:                             Attributes);
./Transforms/Scalar/ObjCARC.cpp:    AttrListPtr Attributes =
./Transforms/Scalar/ObjCARC.cpp:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/ObjCARC.cpp:        Attributes);
./Transforms/Scalar/ObjCARC.cpp:    AttrListPtr Attributes =
./Transforms/Scalar/ObjCARC.cpp:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/ObjCARC.cpp:        Attributes);
./Transforms/Scalar/ObjCARC.cpp:    AttrListPtr Attributes =
./Transforms/Scalar/ObjCARC.cpp:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/ObjCARC.cpp:        Attributes);
./Transforms/Scalar/ObjCARC.cpp:    AttrListPtr Attributes = AttrListPtr()
./Transforms/Scalar/ObjCARC.cpp:               Attributes::get(C, Attributes::NoUnwind))
./Transforms/Scalar/ObjCARC.cpp:      .addAttr(M->getContext(), 1, Attributes::get(C, Attributes::NoCapture));
./Transforms/Scalar/ObjCARC.cpp:        Attributes);
./Transforms/Scalar/ObjCARC.cpp:    AttrListPtr Attributes =
./Transforms/Scalar/ObjCARC.cpp:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/ObjCARC.cpp:      M->getOrInsertFunction("objc_retainAutorelease", FTy, Attributes);
./Transforms/Scalar/ObjCARC.cpp:    AttrListPtr Attributes =
./Transforms/Scalar/ObjCARC.cpp:                            Attributes::get(C, Attributes::NoUnwind));
./Transforms/Scalar/ObjCARC.cpp:                             Attributes);
./Transforms/Scalar/CodeGenPrepare.cpp:  OptSize = F.getFnAttributes().hasAttribute(Attributes::OptimizeForSize);
./Transforms/Scalar/CodeGenPrepare.cpp:  Attributes CallerRetAttr = F->getAttributes().getRetAttributes();
./Transforms/Scalar/CodeGenPrepare.cpp:  if (CallerRetAttr.hasAttribute(Attributes::ZExt) ||
./Transforms/Scalar/CodeGenPrepare.cpp:      CallerRetAttr.hasAttribute(Attributes::SExt))
./Transforms/Scalar/CodeGenPrepare.cpp:    Attributes CalleeRetAttr = CS.getAttributes().getRetAttributes();
./Transforms/Scalar/CodeGenPrepare.cpp:          removeAttribute(Attributes::NoAlias) !=
./Transforms/Scalar/CodeGenPrepare.cpp:          removeAttribute(Attributes::NoAlias))
./Transforms/Scalar/SimplifyLibCalls.cpp:      CI->addAttribute(1, Attributes::get(Callee->getContext(),
./Transforms/Scalar/SimplifyLibCalls.cpp:                                          Attributes::NoCapture));
./Transforms/Scalar/SimplifyLibCalls.cpp:    V = EmitUnaryFloatFnCall(V, Callee->getName(), B, Callee->getAttributes());
./Transforms/Scalar/SimplifyLibCalls.cpp:        return EmitUnaryFloatFnCall(Op2, "exp2", B, Callee->getAttributes());
./Transforms/Scalar/SimplifyLibCalls.cpp:                                         Callee->getAttributes());
./Transforms/Scalar/SimplifyLibCalls.cpp:                                         Callee->getAttributes());
./Transforms/Scalar/SimplifyLibCalls.cpp:        M->getOrInsertFunction("iprintf", FT, Callee->getAttributes());
./Transforms/Scalar/SimplifyLibCalls.cpp:        M->getOrInsertFunction("siprintf", FT, Callee->getAttributes());
./Transforms/Scalar/SimplifyLibCalls.cpp:        M->getOrInsertFunction("fiprintf", FT, Callee->getAttributes());
./Transforms/Scalar/SimplifyLibCalls.cpp:    void inferPrototypeAttributes(Function &F);
./Transforms/Scalar/SimplifyLibCalls.cpp:void SimplifyLibCalls::inferPrototypeAttributes(Function &F) {
./Transforms/Scalar/SimplifyLibCalls.cpp:      inferPrototypeAttributes(F);
./Transforms/Scalar/SimplifyCFGPass.cpp:#include "llvm/Attributes.h"
./Transforms/Scalar/SimplifyCFGPass.cpp:  NewCall->setAttributes(II->getAttributes());
./Transforms/Scalar/GlobalMerge.cpp:#include "llvm/Attributes.h"
./Transforms/Scalar/LoopUnrollPass.cpp:      Header->getParent()->getFnAttributes().
./Transforms/Scalar/LoopUnrollPass.cpp:        hasAttribute(Attributes::OptimizeForSize))
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:    bool isByVal=F->getParamAttributes(PointerArgs[i].second+1).
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:      hasAttribute(Attributes::ByVal);
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:  // Attributes - Keep track of the parameter attributes for the arguments
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:  SmallVector<AttributeWithIndex, 8> AttributesVec;
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:  const AttrListPtr &PAL = F->getAttributes();
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:  Attributes attrs = PAL.getRetAttributes();
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:  if (attrs.hasAttributes())
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:    AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:      Attributes attrs = PAL.getParamAttributes(ArgIndex);
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:      if (attrs.hasAttributes())
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:        AttributesVec.push_back(AttributeWithIndex::get(Params.size(), attrs));
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:  attrs = PAL.getFnAttributes();
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:  if (attrs.hasAttributes())
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:    AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:  NF->copyAttributesFrom(F);
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:  NF->setAttributes(AttrListPtr::get(AttributesVec));
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:  AttributesVec.clear();
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:    const AttrListPtr &CallPAL = CS.getAttributes();
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:    Attributes attrs = CallPAL.getRetAttributes();
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:    if (attrs.hasAttributes())
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:      AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:        Attributes Attrs = CallPAL.getParamAttributes(ArgIndex);
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:        if (Attrs.hasAttributes())
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:          AttributesVec.push_back(AttributeWithIndex::get(Args.size(), Attrs));
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:      Attributes Attrs = CallPAL.getParamAttributes(ArgIndex);
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:      if (Attrs.hasAttributes())
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:        AttributesVec.push_back(AttributeWithIndex::get(Args.size(), Attrs));
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:    attrs = CallPAL.getFnAttributes();
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:    if (attrs.hasAttributes())
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:      AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:      cast<InvokeInst>(New)->setAttributes(AttrListPtr::get(AttributesVec));
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:      cast<CallInst>(New)->setAttributes(AttrListPtr::get(AttributesVec));
./Transforms/IPO/.svn/text-base/ArgumentPromotion.cpp.svn-base:    AttributesVec.clear();
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:  NF->copyAttributesFrom(&Fn);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:    AttrListPtr PAL = CS.getAttributes();
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      SmallVector<AttributeWithIndex, 8> AttributesVec;
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:        AttributesVec.push_back(PAL.getSlot(i));
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      Attributes FnAttrs = PAL.getFnAttributes();
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      if (FnAttrs.hasAttributes())
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:        AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      PAL = AttrListPtr::get(AttributesVec);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      cast<InvokeInst>(New)->setAttributes(PAL);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      cast<CallInst>(New)->setAttributes(PAL);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:  SmallVector<AttributeWithIndex, 8> AttributesVec;
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:  const AttrListPtr &PAL = F->getAttributes();
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:  Attributes RAttrs = PAL.getRetAttributes();
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:  Attributes FnAttrs = PAL.getFnAttributes();
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      Attributes::get(NRetTy->getContext(), AttrBuilder(RAttrs).
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:                      removeAttributes(Attributes::typeIncompatible(NRetTy)));
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:             hasAttributes(Attributes::typeIncompatible(NRetTy)) &&
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:  if (RAttrs.hasAttributes())
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:    AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      Attributes Attrs = PAL.getParamAttributes(i + 1);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      if (Attrs.hasAttributes())
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:        AttributesVec.push_back(AttributeWithIndex::get(Params.size(), Attrs));
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:  if (FnAttrs.hasAttributes())
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:    AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:  // Reconstruct the AttributesList based on the vector we constructed.
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:  AttrListPtr NewPAL = AttrListPtr::get(AttributesVec);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:  NF->copyAttributesFrom(F);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:  NF->setAttributes(NewPAL);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:    AttributesVec.clear();
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:    const AttrListPtr &CallPAL = CS.getAttributes();
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:    Attributes RAttrs = CallPAL.getRetAttributes();
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:    Attributes FnAttrs = CallPAL.getFnAttributes();
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      Attributes::get(NF->getContext(), AttrBuilder(RAttrs).
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:           removeAttributes(Attributes::typeIncompatible(NF->getReturnType())));
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:    if (RAttrs.hasAttributes())
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:        Attributes Attrs = CallPAL.getParamAttributes(i + 1);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:        if (Attrs.hasAttributes())
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:          AttributesVec.push_back(AttributeWithIndex::get(Args.size(), Attrs));
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      Attributes Attrs = CallPAL.getParamAttributes(i + 1);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      if (Attrs.hasAttributes())
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:        AttributesVec.push_back(AttributeWithIndex::get(Args.size(), Attrs));
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:    if (FnAttrs.hasAttributes())
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:    // Reconstruct the AttributesList based on the vector we constructed.
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:    AttrListPtr NewCallPAL = AttrListPtr::get(AttributesVec);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      cast<InvokeInst>(New)->setAttributes(NewCallPAL);
./Transforms/IPO/.svn/text-base/DeadArgumentElimination.cpp.svn-base:      cast<CallInst>(New)->setAttributes(NewCallPAL);
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:    B.addAttribute(Attributes::ReadOnly)
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:      .addAttribute(Attributes::ReadNone);
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:    F->removeAttribute(AttrListPtr::FunctionIndex,
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:                       Attributes::get(F->getContext(), B));
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:    B.addAttribute(ReadsMemory ? Attributes::ReadOnly : Attributes::ReadNone);
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:    F->addAttribute(AttrListPtr::FunctionIndex,
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:                    Attributes::get(F->getContext(), B));
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:  B.addAttribute(Attributes::NoCapture);
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:          A->addAttr(Attributes::get(F->getContext(), B));
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:            A->addAttr(Attributes::get(F->getContext(), B));
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:          addAttr(Attributes::get(ArgumentSCC[0]->Definition->getContext(), B));
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:      A->addAttr(Attributes::get(A->getContext(), B));
./Transforms/IPO/.svn/text-base/FunctionAttrs.cpp.svn-base:          if (CS.paramHasAttr(0, Attributes::NoAlias))
./Transforms/IPO/.svn/text-base/GlobalOpt.cpp.svn-base:    if (!Attrs.getSlot(i).Attrs.hasAttribute(Attributes::Nest))
./Transforms/IPO/.svn/text-base/GlobalOpt.cpp.svn-base:                            Attributes::get(C, Attributes::Nest));
./Transforms/IPO/.svn/text-base/GlobalOpt.cpp.svn-base:static void RemoveNestAttribute(Function *F) {
./Transforms/IPO/.svn/text-base/GlobalOpt.cpp.svn-base:  F->setAttributes(StripNest(F->getContext(), F->getAttributes()));
./Transforms/IPO/.svn/text-base/GlobalOpt.cpp.svn-base:    User.setAttributes(StripNest(F->getContext(), User.getAttributes()));
./Transforms/IPO/.svn/text-base/GlobalOpt.cpp.svn-base:      if (F->getAttributes().hasAttrSomewhere(Attributes::Nest) &&
./Transforms/IPO/.svn/text-base/GlobalOpt.cpp.svn-base:        RemoveNestAttribute(F);
./Transforms/IPO/.svn/text-base/GlobalOpt.cpp.svn-base:      Target->GlobalValue::copyAttributesFrom(J);
./Transforms/IPO/.svn/text-base/InlineAlways.cpp.svn-base:  bool ReturnsTwice =F.getFnAttributes().hasAttribute(Attributes::ReturnsTwice);
./Transforms/IPO/.svn/text-base/InlineAlways.cpp.svn-base:  if (!Callee->getFnAttributes().hasAttribute(Attributes::AlwaysInline))
./Transforms/IPO/.svn/text-base/Inliner.cpp.svn-base:  if (Callee->getFnAttributes().hasAttribute(Attributes::StackProtectReq))
./Transforms/IPO/.svn/text-base/Inliner.cpp.svn-base:    Caller->addFnAttr(Attributes::StackProtectReq);
./Transforms/IPO/.svn/text-base/Inliner.cpp.svn-base:  else if (Callee->getFnAttributes().hasAttribute(Attributes::StackProtect) &&
./Transforms/IPO/.svn/text-base/Inliner.cpp.svn-base:           !Caller->getFnAttributes().hasAttribute(Attributes::StackProtectReq))
./Transforms/IPO/.svn/text-base/Inliner.cpp.svn-base:    Caller->addFnAttr(Attributes::StackProtect);
./Transforms/IPO/.svn/text-base/Inliner.cpp.svn-base:    Caller->getFnAttributes().hasAttribute(Attributes::OptimizeForSize);
./Transforms/IPO/.svn/text-base/Inliner.cpp.svn-base:    Callee->getFnAttributes().hasAttribute(Attributes::InlineHint);
./Transforms/IPO/.svn/text-base/Inliner.cpp.svn-base:        !F->getFnAttributes().hasAttribute(Attributes::AlwaysInline))
./Transforms/IPO/.svn/text-base/MergeFunctions.cpp.svn-base:           CI->getAttributes() == cast<CallInst>(I2)->getAttributes();
./Transforms/IPO/.svn/text-base/MergeFunctions.cpp.svn-base:           CI->getAttributes() == cast<InvokeInst>(I2)->getAttributes();
./Transforms/IPO/.svn/text-base/MergeFunctions.cpp.svn-base:  if (F1->getAttributes() != F2->getAttributes())
./Transforms/IPO/.svn/text-base/MergeFunctions.cpp.svn-base:  NewG->copyAttributesFrom(G);
./Transforms/IPO/.svn/text-base/MergeFunctions.cpp.svn-base:      H->copyAttributesFrom(F);
./Transforms/IPO/.svn/text-base/PruneEH.cpp.svn-base:      AttrBuilder NewAttributes;
./Transforms/IPO/.svn/text-base/PruneEH.cpp.svn-base:        NewAttributes.addAttribute(Attributes::NoUnwind);
./Transforms/IPO/.svn/text-base/PruneEH.cpp.svn-base:        NewAttributes.addAttribute(Attributes::NoReturn);
./Transforms/IPO/.svn/text-base/PruneEH.cpp.svn-base:      const AttrListPtr &PAL = F->getAttributes();
./Transforms/IPO/.svn/text-base/PruneEH.cpp.svn-base:                                            Attributes::get(F->getContext(),
./Transforms/IPO/.svn/text-base/PruneEH.cpp.svn-base:                                                            NewAttributes));
./Transforms/IPO/.svn/text-base/PruneEH.cpp.svn-base:        F->setAttributes(NPAL);
./Transforms/IPO/.svn/text-base/PruneEH.cpp.svn-base:        Call->setAttributes(II->getAttributes());
./Transforms/IPO/InlineAlways.cpp:  bool ReturnsTwice =F.getFnAttributes().hasAttribute(Attributes::ReturnsTwice);
./Transforms/IPO/InlineAlways.cpp:  if (!Callee->getFnAttributes().hasAttribute(Attributes::AlwaysInline))
./Transforms/IPO/Inliner.cpp:  if (Callee->getFnAttributes().hasAttribute(Attributes::StackProtectReq))
./Transforms/IPO/Inliner.cpp:    Caller->addFnAttr(Attributes::StackProtectReq);
./Transforms/IPO/Inliner.cpp:  else if (Callee->getFnAttributes().hasAttribute(Attributes::StackProtect) &&
./Transforms/IPO/Inliner.cpp:           !Caller->getFnAttributes().hasAttribute(Attributes::StackProtectReq))
./Transforms/IPO/Inliner.cpp:    Caller->addFnAttr(Attributes::StackProtect);
./Transforms/IPO/Inliner.cpp:    Caller->getFnAttributes().hasAttribute(Attributes::OptimizeForSize);
./Transforms/IPO/Inliner.cpp:    Callee->getFnAttributes().hasAttribute(Attributes::InlineHint);
./Transforms/IPO/Inliner.cpp:        !F->getFnAttributes().hasAttribute(Attributes::AlwaysInline))
./Transforms/IPO/FunctionAttrs.cpp:    B.addAttribute(Attributes::ReadOnly)
./Transforms/IPO/FunctionAttrs.cpp:      .addAttribute(Attributes::ReadNone);
./Transforms/IPO/FunctionAttrs.cpp:    F->removeAttribute(AttrListPtr::FunctionIndex,
./Transforms/IPO/FunctionAttrs.cpp:                       Attributes::get(F->getContext(), B));
./Transforms/IPO/FunctionAttrs.cpp:    B.addAttribute(ReadsMemory ? Attributes::ReadOnly : Attributes::ReadNone);
./Transforms/IPO/FunctionAttrs.cpp:    F->addAttribute(AttrListPtr::FunctionIndex,
./Transforms/IPO/FunctionAttrs.cpp:                    Attributes::get(F->getContext(), B));
./Transforms/IPO/FunctionAttrs.cpp:  B.addAttribute(Attributes::NoCapture);
./Transforms/IPO/FunctionAttrs.cpp:          A->addAttr(Attributes::get(F->getContext(), B));
./Transforms/IPO/FunctionAttrs.cpp:            A->addAttr(Attributes::get(F->getContext(), B));
./Transforms/IPO/FunctionAttrs.cpp:          addAttr(Attributes::get(ArgumentSCC[0]->Definition->getContext(), B));
./Transforms/IPO/FunctionAttrs.cpp:      A->addAttr(Attributes::get(A->getContext(), B));
./Transforms/IPO/FunctionAttrs.cpp:          if (CS.paramHasAttr(0, Attributes::NoAlias))
./Transforms/IPO/PruneEH.cpp:      AttrBuilder NewAttributes;
./Transforms/IPO/PruneEH.cpp:        NewAttributes.addAttribute(Attributes::NoUnwind);
./Transforms/IPO/PruneEH.cpp:        NewAttributes.addAttribute(Attributes::NoReturn);
./Transforms/IPO/PruneEH.cpp:      const AttrListPtr &PAL = F->getAttributes();
./Transforms/IPO/PruneEH.cpp:                                            Attributes::get(F->getContext(),
./Transforms/IPO/PruneEH.cpp:                                                            NewAttributes));
./Transforms/IPO/PruneEH.cpp:        F->setAttributes(NPAL);
./Transforms/IPO/PruneEH.cpp:        Call->setAttributes(II->getAttributes());
./Transforms/IPO/GlobalOpt.cpp:    if (!Attrs.getSlot(i).Attrs.hasAttribute(Attributes::Nest))
./Transforms/IPO/GlobalOpt.cpp:                            Attributes::get(C, Attributes::Nest));
./Transforms/IPO/GlobalOpt.cpp:static void RemoveNestAttribute(Function *F) {
./Transforms/IPO/GlobalOpt.cpp:  F->setAttributes(StripNest(F->getContext(), F->getAttributes()));
./Transforms/IPO/GlobalOpt.cpp:    User.setAttributes(StripNest(F->getContext(), User.getAttributes()));
./Transforms/IPO/GlobalOpt.cpp:      if (F->getAttributes().hasAttrSomewhere(Attributes::Nest) &&
./Transforms/IPO/GlobalOpt.cpp:        RemoveNestAttribute(F);
./Transforms/IPO/GlobalOpt.cpp:      Target->GlobalValue::copyAttributesFrom(J);
./Transforms/IPO/MergeFunctions.cpp:           CI->getAttributes() == cast<CallInst>(I2)->getAttributes();
./Transforms/IPO/MergeFunctions.cpp:           CI->getAttributes() == cast<InvokeInst>(I2)->getAttributes();
./Transforms/IPO/MergeFunctions.cpp:  if (F1->getAttributes() != F2->getAttributes())
./Transforms/IPO/MergeFunctions.cpp:  NewG->copyAttributesFrom(G);
./Transforms/IPO/MergeFunctions.cpp:      H->copyAttributesFrom(F);
./Transforms/IPO/DeadArgumentElimination.cpp:  NF->copyAttributesFrom(&Fn);
./Transforms/IPO/DeadArgumentElimination.cpp:    AttrListPtr PAL = CS.getAttributes();
./Transforms/IPO/DeadArgumentElimination.cpp:      SmallVector<AttributeWithIndex, 8> AttributesVec;
./Transforms/IPO/DeadArgumentElimination.cpp:        AttributesVec.push_back(PAL.getSlot(i));
./Transforms/IPO/DeadArgumentElimination.cpp:      Attributes FnAttrs = PAL.getFnAttributes();
./Transforms/IPO/DeadArgumentElimination.cpp:      if (FnAttrs.hasAttributes())
./Transforms/IPO/DeadArgumentElimination.cpp:        AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/IPO/DeadArgumentElimination.cpp:      PAL = AttrListPtr::get(AttributesVec);
./Transforms/IPO/DeadArgumentElimination.cpp:      cast<InvokeInst>(New)->setAttributes(PAL);
./Transforms/IPO/DeadArgumentElimination.cpp:      cast<CallInst>(New)->setAttributes(PAL);
./Transforms/IPO/DeadArgumentElimination.cpp:  SmallVector<AttributeWithIndex, 8> AttributesVec;
./Transforms/IPO/DeadArgumentElimination.cpp:  const AttrListPtr &PAL = F->getAttributes();
./Transforms/IPO/DeadArgumentElimination.cpp:  Attributes RAttrs = PAL.getRetAttributes();
./Transforms/IPO/DeadArgumentElimination.cpp:  Attributes FnAttrs = PAL.getFnAttributes();
./Transforms/IPO/DeadArgumentElimination.cpp:      Attributes::get(NRetTy->getContext(), AttrBuilder(RAttrs).
./Transforms/IPO/DeadArgumentElimination.cpp:                      removeAttributes(Attributes::typeIncompatible(NRetTy)));
./Transforms/IPO/DeadArgumentElimination.cpp:             hasAttributes(Attributes::typeIncompatible(NRetTy)) &&
./Transforms/IPO/DeadArgumentElimination.cpp:  if (RAttrs.hasAttributes())
./Transforms/IPO/DeadArgumentElimination.cpp:    AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/IPO/DeadArgumentElimination.cpp:      Attributes Attrs = PAL.getParamAttributes(i + 1);
./Transforms/IPO/DeadArgumentElimination.cpp:      if (Attrs.hasAttributes())
./Transforms/IPO/DeadArgumentElimination.cpp:        AttributesVec.push_back(AttributeWithIndex::get(Params.size(), Attrs));
./Transforms/IPO/DeadArgumentElimination.cpp:  if (FnAttrs.hasAttributes())
./Transforms/IPO/DeadArgumentElimination.cpp:    AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/IPO/DeadArgumentElimination.cpp:  // Reconstruct the AttributesList based on the vector we constructed.
./Transforms/IPO/DeadArgumentElimination.cpp:  AttrListPtr NewPAL = AttrListPtr::get(AttributesVec);
./Transforms/IPO/DeadArgumentElimination.cpp:  NF->copyAttributesFrom(F);
./Transforms/IPO/DeadArgumentElimination.cpp:  NF->setAttributes(NewPAL);
./Transforms/IPO/DeadArgumentElimination.cpp:    AttributesVec.clear();
./Transforms/IPO/DeadArgumentElimination.cpp:    const AttrListPtr &CallPAL = CS.getAttributes();
./Transforms/IPO/DeadArgumentElimination.cpp:    Attributes RAttrs = CallPAL.getRetAttributes();
./Transforms/IPO/DeadArgumentElimination.cpp:    Attributes FnAttrs = CallPAL.getFnAttributes();
./Transforms/IPO/DeadArgumentElimination.cpp:      Attributes::get(NF->getContext(), AttrBuilder(RAttrs).
./Transforms/IPO/DeadArgumentElimination.cpp:           removeAttributes(Attributes::typeIncompatible(NF->getReturnType())));
./Transforms/IPO/DeadArgumentElimination.cpp:    if (RAttrs.hasAttributes())
./Transforms/IPO/DeadArgumentElimination.cpp:      AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/IPO/DeadArgumentElimination.cpp:        Attributes Attrs = CallPAL.getParamAttributes(i + 1);
./Transforms/IPO/DeadArgumentElimination.cpp:        if (Attrs.hasAttributes())
./Transforms/IPO/DeadArgumentElimination.cpp:          AttributesVec.push_back(AttributeWithIndex::get(Args.size(), Attrs));
./Transforms/IPO/DeadArgumentElimination.cpp:      Attributes Attrs = CallPAL.getParamAttributes(i + 1);
./Transforms/IPO/DeadArgumentElimination.cpp:      if (Attrs.hasAttributes())
./Transforms/IPO/DeadArgumentElimination.cpp:        AttributesVec.push_back(AttributeWithIndex::get(Args.size(), Attrs));
./Transforms/IPO/DeadArgumentElimination.cpp:    if (FnAttrs.hasAttributes())
./Transforms/IPO/DeadArgumentElimination.cpp:      AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/IPO/DeadArgumentElimination.cpp:    // Reconstruct the AttributesList based on the vector we constructed.
./Transforms/IPO/DeadArgumentElimination.cpp:    AttrListPtr NewCallPAL = AttrListPtr::get(AttributesVec);
./Transforms/IPO/DeadArgumentElimination.cpp:      cast<InvokeInst>(New)->setAttributes(NewCallPAL);
./Transforms/IPO/DeadArgumentElimination.cpp:      cast<CallInst>(New)->setAttributes(NewCallPAL);
./Transforms/IPO/ArgumentPromotion.cpp:    bool isByVal=F->getParamAttributes(PointerArgs[i].second+1).
./Transforms/IPO/ArgumentPromotion.cpp:      hasAttribute(Attributes::ByVal);
./Transforms/IPO/ArgumentPromotion.cpp:  // Attributes - Keep track of the parameter attributes for the arguments
./Transforms/IPO/ArgumentPromotion.cpp:  SmallVector<AttributeWithIndex, 8> AttributesVec;
./Transforms/IPO/ArgumentPromotion.cpp:  const AttrListPtr &PAL = F->getAttributes();
./Transforms/IPO/ArgumentPromotion.cpp:  Attributes attrs = PAL.getRetAttributes();
./Transforms/IPO/ArgumentPromotion.cpp:  if (attrs.hasAttributes())
./Transforms/IPO/ArgumentPromotion.cpp:    AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/IPO/ArgumentPromotion.cpp:      Attributes attrs = PAL.getParamAttributes(ArgIndex);
./Transforms/IPO/ArgumentPromotion.cpp:      if (attrs.hasAttributes())
./Transforms/IPO/ArgumentPromotion.cpp:        AttributesVec.push_back(AttributeWithIndex::get(Params.size(), attrs));
./Transforms/IPO/ArgumentPromotion.cpp:  attrs = PAL.getFnAttributes();
./Transforms/IPO/ArgumentPromotion.cpp:  if (attrs.hasAttributes())
./Transforms/IPO/ArgumentPromotion.cpp:    AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/IPO/ArgumentPromotion.cpp:  NF->copyAttributesFrom(F);
./Transforms/IPO/ArgumentPromotion.cpp:  NF->setAttributes(AttrListPtr::get(AttributesVec));
./Transforms/IPO/ArgumentPromotion.cpp:  AttributesVec.clear();
./Transforms/IPO/ArgumentPromotion.cpp:    const AttrListPtr &CallPAL = CS.getAttributes();
./Transforms/IPO/ArgumentPromotion.cpp:    Attributes attrs = CallPAL.getRetAttributes();
./Transforms/IPO/ArgumentPromotion.cpp:    if (attrs.hasAttributes())
./Transforms/IPO/ArgumentPromotion.cpp:      AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/IPO/ArgumentPromotion.cpp:        Attributes Attrs = CallPAL.getParamAttributes(ArgIndex);
./Transforms/IPO/ArgumentPromotion.cpp:        if (Attrs.hasAttributes())
./Transforms/IPO/ArgumentPromotion.cpp:          AttributesVec.push_back(AttributeWithIndex::get(Args.size(), Attrs));
./Transforms/IPO/ArgumentPromotion.cpp:      Attributes Attrs = CallPAL.getParamAttributes(ArgIndex);
./Transforms/IPO/ArgumentPromotion.cpp:      if (Attrs.hasAttributes())
./Transforms/IPO/ArgumentPromotion.cpp:        AttributesVec.push_back(AttributeWithIndex::get(Args.size(), Attrs));
./Transforms/IPO/ArgumentPromotion.cpp:    attrs = CallPAL.getFnAttributes();
./Transforms/IPO/ArgumentPromotion.cpp:    if (attrs.hasAttributes())
./Transforms/IPO/ArgumentPromotion.cpp:      AttributesVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/IPO/ArgumentPromotion.cpp:      cast<InvokeInst>(New)->setAttributes(AttrListPtr::get(AttributesVec));
./Transforms/IPO/ArgumentPromotion.cpp:      cast<CallInst>(New)->setAttributes(AttrListPtr::get(AttributesVec));
./Transforms/IPO/ArgumentPromotion.cpp:    AttributesVec.clear();
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:  const AttrListPtr &CallerPAL = CS.getAttributes();
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      AttrBuilder RAttrs = CallerPAL.getRetAttributes();
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      if (RAttrs.hasAttributes(Attributes::typeIncompatible(NewRetTy)))
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:        return false;   // Attribute not compatible with transformed value.
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:    Attributes Attrs = CallerPAL.getParamAttributes(i + 1);
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:          hasAttributes(Attributes::typeIncompatible(ParamTy)))
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      return false;   // Attribute not compatible with transformed value.
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:    if (ParamTy != ActTy && Attrs.hasAttribute(Attributes::ByVal)) {
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      Attributes PAttrs = CallerPAL.getSlot(i - 1).Attrs;
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:  SmallVector<AttributeWithIndex, 8> attrVec;
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:  AttrBuilder RAttrs = CallerPAL.getRetAttributes();
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:  RAttrs.removeAttributes(Attributes::typeIncompatible(NewRetTy));
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:  if (RAttrs.hasAttributes())
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:                              Attributes::get(FT->getContext(), RAttrs)));
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:    Attributes PAttrs = CallerPAL.getParamAttributes(i + 1);
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:    if (PAttrs.hasAttributes())
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      attrVec.push_back(AttributeWithIndex::get(i + 1, PAttrs));
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:        Attributes PAttrs = CallerPAL.getParamAttributes(i + 1);
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:        if (PAttrs.hasAttributes())
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:          attrVec.push_back(AttributeWithIndex::get(i + 1, PAttrs));
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:  Attributes FnAttrs = CallerPAL.getFnAttributes();
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:  if (FnAttrs.hasAttributes())
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:    attrVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:    cast<InvokeInst>(NC)->setAttributes(NewCallerPAL);
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:    cast<CallInst>(NC)->setAttributes(NewCallerPAL);
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:  const AttrListPtr &Attrs = CS.getAttributes();
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:    if (Attrs.getAttributesAtIndex(I).hasAttribute(Attributes::Nest))
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:  const AttrListPtr &NestAttrs = NestF->getAttributes();
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:    Attributes NestAttr;
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      if (NestAttrs.getParamAttributes(NestIdx).hasAttribute(Attributes::Nest)){
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:        NestAttr = NestAttrs.getParamAttributes(NestIdx);
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      SmallVector<AttributeWithIndex, 8> NewAttrs;
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      Attributes Attr = Attrs.getRetAttributes();
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      if (Attr.hasAttributes())
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:        NewAttrs.push_back(AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:            NewAttrs.push_back(AttributeWithIndex::get(NestIdx, NestAttr));
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:          Attr = Attrs.getParamAttributes(Idx);
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:          if (Attr.hasAttributes())
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:              (AttributeWithIndex::get(Idx + (Idx >= NestIdx), Attr));
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      Attr = Attrs.getFnAttributes();
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:      if (Attr.hasAttributes())
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:        NewAttrs.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:        cast<InvokeInst>(NewCaller)->setAttributes(NewPAL);
./Transforms/InstCombine/.svn/text-base/InstCombineCalls.cpp.svn-base:        cast<CallInst>(NewCaller)->setAttributes(NewPAL);
./Transforms/InstCombine/.svn/text-base/InstCombineCasts.cpp.svn-base:                                                   Callee->getAttributes(),
./Transforms/InstCombine/.svn/text-base/InstCombineCasts.cpp.svn-base:      ret->setAttributes(Callee->getAttributes());
./Transforms/InstCombine/InstCombineCasts.cpp:                                                   Callee->getAttributes(),
./Transforms/InstCombine/InstCombineCasts.cpp:      ret->setAttributes(Callee->getAttributes());
./Transforms/InstCombine/InstCombineCalls.cpp:  const AttrListPtr &CallerPAL = CS.getAttributes();
./Transforms/InstCombine/InstCombineCalls.cpp:      AttrBuilder RAttrs = CallerPAL.getRetAttributes();
./Transforms/InstCombine/InstCombineCalls.cpp:      if (RAttrs.hasAttributes(Attributes::typeIncompatible(NewRetTy)))
./Transforms/InstCombine/InstCombineCalls.cpp:        return false;   // Attribute not compatible with transformed value.
./Transforms/InstCombine/InstCombineCalls.cpp:    Attributes Attrs = CallerPAL.getParamAttributes(i + 1);
./Transforms/InstCombine/InstCombineCalls.cpp:          hasAttributes(Attributes::typeIncompatible(ParamTy)))
./Transforms/InstCombine/InstCombineCalls.cpp:      return false;   // Attribute not compatible with transformed value.
./Transforms/InstCombine/InstCombineCalls.cpp:    if (ParamTy != ActTy && Attrs.hasAttribute(Attributes::ByVal)) {
./Transforms/InstCombine/InstCombineCalls.cpp:      Attributes PAttrs = CallerPAL.getSlot(i - 1).Attrs;
./Transforms/InstCombine/InstCombineCalls.cpp:  SmallVector<AttributeWithIndex, 8> attrVec;
./Transforms/InstCombine/InstCombineCalls.cpp:  AttrBuilder RAttrs = CallerPAL.getRetAttributes();
./Transforms/InstCombine/InstCombineCalls.cpp:  RAttrs.removeAttributes(Attributes::typeIncompatible(NewRetTy));
./Transforms/InstCombine/InstCombineCalls.cpp:  if (RAttrs.hasAttributes())
./Transforms/InstCombine/InstCombineCalls.cpp:      AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/InstCombine/InstCombineCalls.cpp:                              Attributes::get(FT->getContext(), RAttrs)));
./Transforms/InstCombine/InstCombineCalls.cpp:    Attributes PAttrs = CallerPAL.getParamAttributes(i + 1);
./Transforms/InstCombine/InstCombineCalls.cpp:    if (PAttrs.hasAttributes())
./Transforms/InstCombine/InstCombineCalls.cpp:      attrVec.push_back(AttributeWithIndex::get(i + 1, PAttrs));
./Transforms/InstCombine/InstCombineCalls.cpp:        Attributes PAttrs = CallerPAL.getParamAttributes(i + 1);
./Transforms/InstCombine/InstCombineCalls.cpp:        if (PAttrs.hasAttributes())
./Transforms/InstCombine/InstCombineCalls.cpp:          attrVec.push_back(AttributeWithIndex::get(i + 1, PAttrs));
./Transforms/InstCombine/InstCombineCalls.cpp:  Attributes FnAttrs = CallerPAL.getFnAttributes();
./Transforms/InstCombine/InstCombineCalls.cpp:  if (FnAttrs.hasAttributes())
./Transforms/InstCombine/InstCombineCalls.cpp:    attrVec.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/InstCombine/InstCombineCalls.cpp:    cast<InvokeInst>(NC)->setAttributes(NewCallerPAL);
./Transforms/InstCombine/InstCombineCalls.cpp:    cast<CallInst>(NC)->setAttributes(NewCallerPAL);
./Transforms/InstCombine/InstCombineCalls.cpp:  const AttrListPtr &Attrs = CS.getAttributes();
./Transforms/InstCombine/InstCombineCalls.cpp:    if (Attrs.getAttributesAtIndex(I).hasAttribute(Attributes::Nest))
./Transforms/InstCombine/InstCombineCalls.cpp:  const AttrListPtr &NestAttrs = NestF->getAttributes();
./Transforms/InstCombine/InstCombineCalls.cpp:    Attributes NestAttr;
./Transforms/InstCombine/InstCombineCalls.cpp:      if (NestAttrs.getParamAttributes(NestIdx).hasAttribute(Attributes::Nest)){
./Transforms/InstCombine/InstCombineCalls.cpp:        NestAttr = NestAttrs.getParamAttributes(NestIdx);
./Transforms/InstCombine/InstCombineCalls.cpp:      SmallVector<AttributeWithIndex, 8> NewAttrs;
./Transforms/InstCombine/InstCombineCalls.cpp:      Attributes Attr = Attrs.getRetAttributes();
./Transforms/InstCombine/InstCombineCalls.cpp:      if (Attr.hasAttributes())
./Transforms/InstCombine/InstCombineCalls.cpp:        NewAttrs.push_back(AttributeWithIndex::get(AttrListPtr::ReturnIndex,
./Transforms/InstCombine/InstCombineCalls.cpp:            NewAttrs.push_back(AttributeWithIndex::get(NestIdx, NestAttr));
./Transforms/InstCombine/InstCombineCalls.cpp:          Attr = Attrs.getParamAttributes(Idx);
./Transforms/InstCombine/InstCombineCalls.cpp:          if (Attr.hasAttributes())
./Transforms/InstCombine/InstCombineCalls.cpp:              (AttributeWithIndex::get(Idx + (Idx >= NestIdx), Attr));
./Transforms/InstCombine/InstCombineCalls.cpp:      Attr = Attrs.getFnAttributes();
./Transforms/InstCombine/InstCombineCalls.cpp:      if (Attr.hasAttributes())
./Transforms/InstCombine/InstCombineCalls.cpp:        NewAttrs.push_back(AttributeWithIndex::get(AttrListPtr::FunctionIndex,
./Transforms/InstCombine/InstCombineCalls.cpp:        cast<InvokeInst>(NewCaller)->setAttributes(NewPAL);
./Transforms/InstCombine/InstCombineCalls.cpp:        cast<CallInst>(NewCaller)->setAttributes(NewPAL);
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:  void writeParamOperand(const Value *Operand, Attributes Attrs);
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:  void printArgument(const Argument *FA, Attributes Attrs);
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:                                       Attributes Attrs) {
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:  if (Attrs.hasAttributes())
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:  const AttrListPtr &Attrs = F->getAttributes();
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:  Attributes RetAttrs = Attrs.getRetAttributes();
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:  if (RetAttrs.hasAttributes())
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:    Out <<  Attrs.getRetAttributes().getAsString() << ' ';
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:      printArgument(I, Attrs.getParamAttributes(Idx));
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:      Attributes ArgAttrs = Attrs.getParamAttributes(i+1);
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:      if (ArgAttrs.hasAttributes())
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:  Attributes FnAttrs = Attrs.getFnAttributes();
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:  if (FnAttrs.hasAttributes())
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:    Out << ' ' << Attrs.getFnAttributes().getAsString();
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:                                   Attributes Attrs) {
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:  if (Attrs.hasAttributes())
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:    const AttrListPtr &PAL = CI->getAttributes();
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:    if (PAL.getRetAttributes().hasAttributes())
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:      Out << ' ' << PAL.getRetAttributes().getAsString();
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:      writeParamOperand(CI->getArgOperand(op), PAL.getParamAttributes(op + 1));
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:    if (PAL.getFnAttributes().hasAttributes())
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:      Out << ' ' << PAL.getFnAttributes().getAsString();
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:    const AttrListPtr &PAL = II->getAttributes();
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:    if (PAL.getRetAttributes().hasAttributes())
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:      Out << ' ' << PAL.getRetAttributes().getAsString();
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:      writeParamOperand(II->getArgOperand(op), PAL.getParamAttributes(op + 1));
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:    if (PAL.getFnAttributes().hasAttributes())
./VMCore/.svn/text-base/AsmWriter.cpp.svn-base:      Out << ' ' << PAL.getFnAttributes().getAsString();
./VMCore/.svn/text-base/Attributes.cpp.svn-base://===-- Attributes.cpp - Implement AttributesList -------------------------===//
./VMCore/.svn/text-base/Attributes.cpp.svn-base:// This file implements the Attributes, AttributeImpl, AttrBuilder,
./VMCore/.svn/text-base/Attributes.cpp.svn-base:// AttributeListImpl, and AttrListPtr classes.
./VMCore/.svn/text-base/Attributes.cpp.svn-base:#include "llvm/Attributes.h"
./VMCore/.svn/text-base/Attributes.cpp.svn-base:#include "AttributesImpl.h"
./VMCore/.svn/text-base/Attributes.cpp.svn-base:// Attributes Implementation
./VMCore/.svn/text-base/Attributes.cpp.svn-base:Attributes Attributes::get(LLVMContext &Context, ArrayRef<AttrVal> Vals) {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    B.addAttribute(*I);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Attributes::get(Context, B);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:Attributes Attributes::get(LLVMContext &Context, AttrBuilder &B) {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  // If there are no attributes, return an empty Attributes class.
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (!B.hasAttributes())
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    return Attributes();
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  AttributesImpl *PA = pImpl->AttrsSet.FindNodeOrInsertPos(ID, InsertPoint);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    PA = new AttributesImpl(B.Raw());
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  // Return the AttributesList that we found or created.
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Attributes(PA);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:bool Attributes::hasAttribute(AttrVal Val) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Attrs && Attrs->hasAttribute(Val);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:bool Attributes::hasAttributes() const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Attrs && Attrs->hasAttributes();
./VMCore/.svn/text-base/Attributes.cpp.svn-base:bool Attributes::hasAttributes(const Attributes &A) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Attrs && Attrs->hasAttributes(A);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:unsigned Attributes::getAlignment() const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (!hasAttribute(Attributes::Alignment))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:unsigned Attributes::getStackAlignment() const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (!hasAttribute(Attributes::StackAlignment))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:uint64_t Attributes::Raw() const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:Attributes Attributes::typeIncompatible(Type *Ty) {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    // Attributes that only apply to integers.
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    Incompatible.addAttribute(Attributes::SExt)
./VMCore/.svn/text-base/Attributes.cpp.svn-base:      .addAttribute(Attributes::ZExt);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    // Attributes that only apply to pointers.
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    Incompatible.addAttribute(Attributes::ByVal)
./VMCore/.svn/text-base/Attributes.cpp.svn-base:      .addAttribute(Attributes::Nest)
./VMCore/.svn/text-base/Attributes.cpp.svn-base:      .addAttribute(Attributes::NoAlias)
./VMCore/.svn/text-base/Attributes.cpp.svn-base:      .addAttribute(Attributes::NoCapture)
./VMCore/.svn/text-base/Attributes.cpp.svn-base:      .addAttribute(Attributes::StructRet);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Attributes::get(Ty->getContext(), Incompatible);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:/// encodeLLVMAttributesForBitcode - This returns an integer containing an
./VMCore/.svn/text-base/Attributes.cpp.svn-base:uint64_t Attributes::encodeLLVMAttributesForBitcode(Attributes Attrs) {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (Attrs.hasAttribute(Attributes::Alignment))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:/// decodeLLVMAttributesForBitcode - This returns an attribute bitset containing
./VMCore/.svn/text-base/Attributes.cpp.svn-base:/// function must stay in sync with 'encodeLLVMAttributesForBitcode'.
./VMCore/.svn/text-base/Attributes.cpp.svn-base:Attributes Attributes::decodeLLVMAttributesForBitcode(LLVMContext &C,
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Attributes::get(C, B);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:std::string Attributes::getAsString() const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::ZExt))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::SExt))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::NoReturn))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::NoUnwind))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::UWTable))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::ReturnsTwice))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::InReg))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::NoAlias))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::NoCapture))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::StructRet))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::ByVal))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::Nest))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::ReadNone))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::ReadOnly))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::OptimizeForSize))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::NoInline))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::InlineHint))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::AlwaysInline))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::StackProtect))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::StackProtectReq))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::NoRedZone))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::NoImplicitFloat))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::Naked))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::NonLazyBind))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::AddressSafety))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::StackAlignment)) {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (hasAttribute(Attributes::Alignment)) {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:AttrBuilder &AttrBuilder::addAttribute(Attributes::AttrVal Val){
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  Bits |= AttributesImpl::getAttrMask(Val);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:AttrBuilder &AttrBuilder::removeAttribute(Attributes::AttrVal Val) {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  Bits &= ~AttributesImpl::getAttrMask(Val);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:AttrBuilder &AttrBuilder::addAttributes(const Attributes &A) {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:AttrBuilder &AttrBuilder::removeAttributes(const Attributes &A){
./VMCore/.svn/text-base/Attributes.cpp.svn-base:bool AttrBuilder::hasAttribute(Attributes::AttrVal A) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Bits & AttributesImpl::getAttrMask(A);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:bool AttrBuilder::hasAttributes() const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:bool AttrBuilder::hasAttributes(const Attributes &A) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Bits & AttributesImpl::getAttrMask(Attributes::Alignment);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    (((Bits & AttributesImpl::getAttrMask(Attributes::Alignment)) >> 16) - 1);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    (((Bits & AttributesImpl::getAttrMask(Attributes::StackAlignment))>>26)-1);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:// AttributeImpl Definition
./VMCore/.svn/text-base/Attributes.cpp.svn-base:uint64_t AttributesImpl::getAttrMask(uint64_t Val) {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::None:            return 0;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::ZExt:            return 1 << 0;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::SExt:            return 1 << 1;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::NoReturn:        return 1 << 2;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::InReg:           return 1 << 3;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::StructRet:       return 1 << 4;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::NoUnwind:        return 1 << 5;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::NoAlias:         return 1 << 6;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::ByVal:           return 1 << 7;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::Nest:            return 1 << 8;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::ReadNone:        return 1 << 9;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::ReadOnly:        return 1 << 10;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::NoInline:        return 1 << 11;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::AlwaysInline:    return 1 << 12;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::OptimizeForSize: return 1 << 13;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::StackProtect:    return 1 << 14;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::StackProtectReq: return 1 << 15;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::Alignment:       return 31 << 16;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::NoCapture:       return 1 << 21;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::NoRedZone:       return 1 << 22;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::NoImplicitFloat: return 1 << 23;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::Naked:           return 1 << 24;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::InlineHint:      return 1 << 25;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::StackAlignment:  return 7 << 26;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::ReturnsTwice:    return 1 << 29;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::UWTable:         return 1 << 30;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::NonLazyBind:     return 1U << 31;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  case Attributes::AddressSafety:   return 1ULL << 32;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:bool AttributesImpl::hasAttribute(uint64_t A) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:bool AttributesImpl::hasAttributes() const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:bool AttributesImpl::hasAttributes(const Attributes &A) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:uint64_t AttributesImpl::getAlignment() const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Bits & getAttrMask(Attributes::Alignment);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:uint64_t AttributesImpl::getStackAlignment() const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Bits & getAttrMask(Attributes::StackAlignment);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:// AttributeListImpl Definition
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  class AttributeListImpl;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:static ManagedStatic<FoldingSet<AttributeListImpl> > AttributesLists;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:class AttributeListImpl : public FoldingSetNode {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  // AttributesList is uniqued, these should not be publicly available.
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  void operator=(const AttributeListImpl &) LLVM_DELETED_FUNCTION;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  AttributeListImpl(const AttributeListImpl &) LLVM_DELETED_FUNCTION;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  ~AttributeListImpl();                        // Private implementation
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  SmallVector<AttributeWithIndex, 4> Attrs;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  AttributeListImpl(ArrayRef<AttributeWithIndex> attrs)
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    if (!AttributesLists.isConstructed())
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  static void Profile(FoldingSetNodeID &ID, ArrayRef<AttributeWithIndex> Attrs){
./VMCore/.svn/text-base/Attributes.cpp.svn-base:AttributeListImpl::~AttributeListImpl() {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  AttributesLists->RemoveNode(this);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:AttrListPtr AttrListPtr::get(ArrayRef<AttributeWithIndex> Attrs) {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  // If there are no attributes then return a null AttributesList pointer.
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    assert(Attrs[i].Attrs.hasAttributes() &&
./VMCore/.svn/text-base/Attributes.cpp.svn-base:           "Misordered AttributesList!");
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  AttributeListImpl::Profile(ID, Attrs);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  AttributeListImpl *PAL =
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    AttributesLists->FindNodeOrInsertPos(ID, InsertPos);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    PAL = new AttributeListImpl(Attrs);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    AttributesLists->InsertNode(PAL, InsertPos);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  // Return the AttributesList that we found or created.
./VMCore/.svn/text-base/Attributes.cpp.svn-base:AttrListPtr::AttrListPtr(AttributeListImpl *LI) : AttrList(LI) {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:/// getSlot - Return the AttributeWithIndex at the specified slot.  This
./VMCore/.svn/text-base/Attributes.cpp.svn-base:const AttributeWithIndex &AttrListPtr::getSlot(unsigned Slot) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:/// getAttributes - The attributes for the specified index are returned.
./VMCore/.svn/text-base/Attributes.cpp.svn-base:/// Attributes for the result are denoted with Idx = 0.  Function notes are
./VMCore/.svn/text-base/Attributes.cpp.svn-base:Attributes AttrListPtr::getAttributes(unsigned Idx) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (AttrList == 0) return Attributes();
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  const SmallVector<AttributeWithIndex, 4> &Attrs = AttrList->Attrs;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  return Attributes();
./VMCore/.svn/text-base/Attributes.cpp.svn-base:bool AttrListPtr::hasAttrSomewhere(Attributes::AttrVal Attr) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  const SmallVector<AttributeWithIndex, 4> &Attrs = AttrList->Attrs;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    if (Attrs[i].Attrs.hasAttribute(Attr))
./VMCore/.svn/text-base/Attributes.cpp.svn-base:Attributes &AttrListPtr::getAttributesAtIndex(unsigned i) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:                                 Attributes Attrs) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  Attributes OldAttrs = getAttributes(Idx);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    AttrBuilder(OldAttrs).addAttributes(Attrs);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  SmallVector<AttributeWithIndex, 8> NewAttrList;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    NewAttrList.push_back(AttributeWithIndex::get(Idx, Attrs));
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    const SmallVector<AttributeWithIndex, 4> &OldAttrList = AttrList->Attrs;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:        Attributes::get(C, AttrBuilder(Attrs).
./VMCore/.svn/text-base/Attributes.cpp.svn-base:                        addAttributes(OldAttrList[i].Attrs));
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    NewAttrList.push_back(AttributeWithIndex::get(Idx, Attrs));
./VMCore/.svn/text-base/Attributes.cpp.svn-base:                                    Attributes Attrs) const {
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  assert(!Attrs.hasAttribute(Attributes::Alignment) &&
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  Attributes OldAttrs = getAttributes(Idx);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    AttrBuilder(OldAttrs).removeAttributes(Attrs);
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  SmallVector<AttributeWithIndex, 8> NewAttrList;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  const SmallVector<AttributeWithIndex, 4> &OldAttrList = AttrList->Attrs;
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  assert(OldAttrList[i].Index == Idx && "Attribute isn't set?");
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  Attrs = Attributes::get(C, AttrBuilder(OldAttrList[i].Attrs).
./VMCore/.svn/text-base/Attributes.cpp.svn-base:                          removeAttributes(Attrs));
./VMCore/.svn/text-base/Attributes.cpp.svn-base:  if (Attrs.hasAttributes()) // If any attributes left for this param, add them.
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    NewAttrList.push_back(AttributeWithIndex::get(Idx, Attrs));
./VMCore/.svn/text-base/Attributes.cpp.svn-base:    const AttributeWithIndex &PAWI = getSlot(i);
./VMCore/.svn/text-base/AttributesImpl.h.svn-base://===-- AttributesImpl.h - Attributes Internals -----------------*- C++ -*-===//
./VMCore/.svn/text-base/AttributesImpl.h.svn-base:class Attributes;
./VMCore/.svn/text-base/AttributesImpl.h.svn-base:class AttributesImpl : public FoldingSetNode {
./VMCore/.svn/text-base/AttributesImpl.h.svn-base:  AttributesImpl(uint64_t bits) : Bits(bits) {}
./VMCore/.svn/text-base/AttributesImpl.h.svn-base:  bool hasAttribute(uint64_t A) const;
./VMCore/.svn/text-base/AttributesImpl.h.svn-base:  bool hasAttributes() const;
./VMCore/.svn/text-base/AttributesImpl.h.svn-base:  bool hasAttributes(const Attributes &A) const;
./VMCore/.svn/text-base/AutoUpgrade.cpp.svn-base:    F->setAttributes(Intrinsic::getAttributes(F->getContext(),
./VMCore/.svn/text-base/CMakeLists.txt.svn-base:  Attributes.cpp
./VMCore/.svn/text-base/Core.cpp.svn-base:#include "llvm/Attributes.h"
./VMCore/.svn/text-base/Core.cpp.svn-base:void LLVMAddFunctionAttr(LLVMValueRef Fn, LLVMAttribute PA) {
./VMCore/.svn/text-base/Core.cpp.svn-base:  const AttrListPtr PAL = Func->getAttributes();
./VMCore/.svn/text-base/Core.cpp.svn-base:                Attributes::get(Func->getContext(), B));
./VMCore/.svn/text-base/Core.cpp.svn-base:  Func->setAttributes(PALnew);
./VMCore/.svn/text-base/Core.cpp.svn-base:void LLVMRemoveFunctionAttr(LLVMValueRef Fn, LLVMAttribute PA) {
./VMCore/.svn/text-base/Core.cpp.svn-base:  const AttrListPtr PAL = Func->getAttributes();
./VMCore/.svn/text-base/Core.cpp.svn-base:                   Attributes::get(Func->getContext(), B));
./VMCore/.svn/text-base/Core.cpp.svn-base:  Func->setAttributes(PALnew);
./VMCore/.svn/text-base/Core.cpp.svn-base:LLVMAttribute LLVMGetFunctionAttr(LLVMValueRef Fn) {
./VMCore/.svn/text-base/Core.cpp.svn-base:  const AttrListPtr PAL = Func->getAttributes();
./VMCore/.svn/text-base/Core.cpp.svn-base:  Attributes attr = PAL.getFnAttributes();
./VMCore/.svn/text-base/Core.cpp.svn-base:  return (LLVMAttribute)attr.Raw();
./VMCore/.svn/text-base/Core.cpp.svn-base:void LLVMAddAttribute(LLVMValueRef Arg, LLVMAttribute PA) {
./VMCore/.svn/text-base/Core.cpp.svn-base:  A->addAttr(Attributes::get(A->getContext(), B));
./VMCore/.svn/text-base/Core.cpp.svn-base:void LLVMRemoveAttribute(LLVMValueRef Arg, LLVMAttribute PA) {
./VMCore/.svn/text-base/Core.cpp.svn-base:  A->removeAttr(Attributes::get(A->getContext(), B));
./VMCore/.svn/text-base/Core.cpp.svn-base:LLVMAttribute LLVMGetAttribute(LLVMValueRef Arg) {
./VMCore/.svn/text-base/Core.cpp.svn-base:  Attributes attr = A->getParent()->getAttributes().getParamAttributes(
./VMCore/.svn/text-base/Core.cpp.svn-base:  return (LLVMAttribute)attr.Raw();
./VMCore/.svn/text-base/Core.cpp.svn-base:  unwrap<Argument>(Arg)->addAttr(Attributes::
./VMCore/.svn/text-base/Core.cpp.svn-base:void LLVMAddInstrAttribute(LLVMValueRef Instr, unsigned index, 
./VMCore/.svn/text-base/Core.cpp.svn-base:                           LLVMAttribute PA) {
./VMCore/.svn/text-base/Core.cpp.svn-base:  Call.setAttributes(
./VMCore/.svn/text-base/Core.cpp.svn-base:    Call.getAttributes().addAttr(Call->getContext(), index,
./VMCore/.svn/text-base/Core.cpp.svn-base:                                 Attributes::get(Call->getContext(), B)));
./VMCore/.svn/text-base/Core.cpp.svn-base:void LLVMRemoveInstrAttribute(LLVMValueRef Instr, unsigned index, 
./VMCore/.svn/text-base/Core.cpp.svn-base:                              LLVMAttribute PA) {
./VMCore/.svn/text-base/Core.cpp.svn-base:  Call.setAttributes(
./VMCore/.svn/text-base/Core.cpp.svn-base:    Call.getAttributes().removeAttr(Call->getContext(), index,
./VMCore/.svn/text-base/Core.cpp.svn-base:                                    Attributes::get(Call->getContext(), B)));
./VMCore/.svn/text-base/Core.cpp.svn-base:  Call.setAttributes(Call.getAttributes().addAttr(Call->getContext(), index,
./VMCore/.svn/text-base/Core.cpp.svn-base:                                       Attributes::get(Call->getContext(), B)));
./VMCore/.svn/text-base/DIBuilder.cpp.svn-base:                                 unsigned PropertyAttributes) {
./VMCore/.svn/text-base/DIBuilder.cpp.svn-base:    ConstantInt::get(Type::getInt32Ty(VMContext), PropertyAttributes)
./VMCore/.svn/text-base/DIBuilder.cpp.svn-base:                                             unsigned PropertyAttributes,
./VMCore/.svn/text-base/DIBuilder.cpp.svn-base:    ConstantInt::get(Type::getInt32Ty(VMContext), PropertyAttributes),
./VMCore/.svn/text-base/DebugInfo.cpp.svn-base:        dwarf::AttributeEncodingString(DIBasicType(DbgNode).getEncoding()))
./VMCore/.svn/text-base/Function.cpp.svn-base:  return getParent()->getParamAttributes(getArgNo()+1).
./VMCore/.svn/text-base/Function.cpp.svn-base:    hasAttribute(Attributes::ByVal);
./VMCore/.svn/text-base/Function.cpp.svn-base:  return getParent()->getParamAttributes(getArgNo()+1).
./VMCore/.svn/text-base/Function.cpp.svn-base:    hasAttribute(Attributes::Nest);
./VMCore/.svn/text-base/Function.cpp.svn-base:  return getParent()->getParamAttributes(getArgNo()+1).
./VMCore/.svn/text-base/Function.cpp.svn-base:    hasAttribute(Attributes::NoAlias);
./VMCore/.svn/text-base/Function.cpp.svn-base:  return getParent()->getParamAttributes(getArgNo()+1).
./VMCore/.svn/text-base/Function.cpp.svn-base:    hasAttribute(Attributes::NoCapture);
./VMCore/.svn/text-base/Function.cpp.svn-base:  return getParent()->getParamAttributes(1).
./VMCore/.svn/text-base/Function.cpp.svn-base:    hasAttribute(Attributes::StructRet);
./VMCore/.svn/text-base/Function.cpp.svn-base:/// addAttr - Add a Attribute to an argument
./VMCore/.svn/text-base/Function.cpp.svn-base:void Argument::addAttr(Attributes attr) {
./VMCore/.svn/text-base/Function.cpp.svn-base:  getParent()->addAttribute(getArgNo() + 1, attr);
./VMCore/.svn/text-base/Function.cpp.svn-base:/// removeAttr - Remove a Attribute from an argument
./VMCore/.svn/text-base/Function.cpp.svn-base:void Argument::removeAttr(Attributes attr) {
./VMCore/.svn/text-base/Function.cpp.svn-base:  getParent()->removeAttribute(getArgNo() + 1, attr);
./VMCore/.svn/text-base/Function.cpp.svn-base:    setAttributes(Intrinsic::getAttributes(getContext(), Intrinsic::ID(IID)));
./VMCore/.svn/text-base/Function.cpp.svn-base:void Function::addAttribute(unsigned i, Attributes attr) {
./VMCore/.svn/text-base/Function.cpp.svn-base:  AttrListPtr PAL = getAttributes();
./VMCore/.svn/text-base/Function.cpp.svn-base:  setAttributes(PAL);
./VMCore/.svn/text-base/Function.cpp.svn-base:void Function::removeAttribute(unsigned i, Attributes attr) {
./VMCore/.svn/text-base/Function.cpp.svn-base:  AttrListPtr PAL = getAttributes();
./VMCore/.svn/text-base/Function.cpp.svn-base:  setAttributes(PAL);
./VMCore/.svn/text-base/Function.cpp.svn-base:/// copyAttributesFrom - copy all additional attributes (those not needed to
./VMCore/.svn/text-base/Function.cpp.svn-base:void Function::copyAttributesFrom(const GlobalValue *Src) {
./VMCore/.svn/text-base/Function.cpp.svn-base:  GlobalValue::copyAttributesFrom(Src);
./VMCore/.svn/text-base/Function.cpp.svn-base:  setAttributes(SrcF->getAttributes());
./VMCore/.svn/text-base/Function.cpp.svn-base:/// This defines the "Intrinsic::getAttributes(ID id)" method.
./VMCore/.svn/text-base/Globals.cpp.svn-base:/// copyAttributesFrom - copy all additional attributes (those not needed to
./VMCore/.svn/text-base/Globals.cpp.svn-base:void GlobalValue::copyAttributesFrom(const GlobalValue *Src) {
./VMCore/.svn/text-base/Globals.cpp.svn-base:/// copyAttributesFrom - copy all additional attributes (those not needed to
./VMCore/.svn/text-base/Globals.cpp.svn-base:void GlobalVariable::copyAttributesFrom(const GlobalValue *Src) {
./VMCore/.svn/text-base/Globals.cpp.svn-base:  GlobalValue::copyAttributesFrom(Src);
./VMCore/.svn/text-base/Instruction.cpp.svn-base:           CI->getAttributes() == cast<CallInst>(I)->getAttributes();
./VMCore/.svn/text-base/Instruction.cpp.svn-base:           CI->getAttributes() == cast<InvokeInst>(I)->getAttributes();
./VMCore/.svn/text-base/Instruction.cpp.svn-base:           CI->getAttributes() == cast<CallInst>(I)->getAttributes();
./VMCore/.svn/text-base/Instruction.cpp.svn-base:           CI->getAttributes() ==
./VMCore/.svn/text-base/Instruction.cpp.svn-base:             cast<InvokeInst>(I)->getAttributes();
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  setAttributes(CI.getAttributes());
./VMCore/.svn/text-base/Instructions.cpp.svn-base:void CallInst::addAttribute(unsigned i, Attributes attr) {
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  AttrListPtr PAL = getAttributes();
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  setAttributes(PAL);
./VMCore/.svn/text-base/Instructions.cpp.svn-base:void CallInst::removeAttribute(unsigned i, Attributes attr) {
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  AttrListPtr PAL = getAttributes();
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  setAttributes(PAL);
./VMCore/.svn/text-base/Instructions.cpp.svn-base:bool CallInst::hasFnAttr(Attributes::AttrVal A) const {
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  if (AttributeList.getParamAttributes(AttrListPtr::FunctionIndex)
./VMCore/.svn/text-base/Instructions.cpp.svn-base:      .hasAttribute(A))
./VMCore/.svn/text-base/Instructions.cpp.svn-base:    return F->getParamAttributes(AttrListPtr::FunctionIndex).hasAttribute(A);
./VMCore/.svn/text-base/Instructions.cpp.svn-base:bool CallInst::paramHasAttr(unsigned i, Attributes::AttrVal A) const {
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  if (AttributeList.getParamAttributes(i).hasAttribute(A))
./VMCore/.svn/text-base/Instructions.cpp.svn-base:    return F->getParamAttributes(i).hasAttribute(A);
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  setAttributes(II.getAttributes());
./VMCore/.svn/text-base/Instructions.cpp.svn-base:bool InvokeInst::hasFnAttr(Attributes::AttrVal A) const {
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  if (AttributeList.getParamAttributes(AttrListPtr::FunctionIndex).
./VMCore/.svn/text-base/Instructions.cpp.svn-base:      hasAttribute(A))
./VMCore/.svn/text-base/Instructions.cpp.svn-base:    return F->getParamAttributes(AttrListPtr::FunctionIndex).hasAttribute(A);
./VMCore/.svn/text-base/Instructions.cpp.svn-base:bool InvokeInst::paramHasAttr(unsigned i, Attributes::AttrVal A) const {
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  if (AttributeList.getParamAttributes(i).hasAttribute(A))
./VMCore/.svn/text-base/Instructions.cpp.svn-base:    return F->getParamAttributes(i).hasAttribute(A);
./VMCore/.svn/text-base/Instructions.cpp.svn-base:void InvokeInst::addAttribute(unsigned i, Attributes attr) {
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  AttrListPtr PAL = getAttributes();
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  setAttributes(PAL);
./VMCore/.svn/text-base/Instructions.cpp.svn-base:void InvokeInst::removeAttribute(unsigned i, Attributes attr) {
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  AttrListPtr PAL = getAttributes();
./VMCore/.svn/text-base/Instructions.cpp.svn-base:  setAttributes(PAL);
./VMCore/.svn/text-base/LLVMContextImpl.cpp.svn-base:#include "llvm/Attributes.h"
./VMCore/.svn/text-base/LLVMContextImpl.cpp.svn-base:  for (FoldingSetIterator<AttributesImpl> I = AttrsSet.begin(),
./VMCore/.svn/text-base/LLVMContextImpl.cpp.svn-base:    FoldingSetIterator<AttributesImpl> Elem = I++;
./VMCore/.svn/text-base/LLVMContextImpl.h.svn-base:#include "AttributesImpl.h"
./VMCore/.svn/text-base/LLVMContextImpl.h.svn-base:  FoldingSet<AttributesImpl> AttrsSet;
./VMCore/.svn/text-base/Module.cpp.svn-base:                                      AttrListPtr AttributeList) {
./VMCore/.svn/text-base/Module.cpp.svn-base:      New->setAttributes(AttributeList);
./VMCore/.svn/text-base/Module.cpp.svn-base:                                             AttrListPtr AttributeList) {
./VMCore/.svn/text-base/Module.cpp.svn-base:    New->setAttributes(AttributeList);
./VMCore/.svn/text-base/Module.cpp.svn-base:                                      AttrListPtr AttributeList,
./VMCore/.svn/text-base/Module.cpp.svn-base:                             AttributeList);
./VMCore/.svn/text-base/Verifier.cpp.svn-base:    void VerifyParameterAttrs(Attributes Attrs, Type *Ty,
./VMCore/.svn/text-base/Verifier.cpp.svn-base:void Verifier::VerifyParameterAttrs(Attributes Attrs, Type *Ty,
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  if (!Attrs.hasAttributes())
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            "Attributes 'byval', 'nest', 'sret', and 'nocapture' "
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(!((Attrs.hasAttribute(Attributes::ByVal) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             Attrs.hasAttribute(Attributes::Nest)) ||
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            (Attrs.hasAttribute(Attributes::ByVal) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             Attrs.hasAttribute(Attributes::StructRet)) ||
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            (Attrs.hasAttribute(Attributes::Nest) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             Attrs.hasAttribute(Attributes::StructRet))), "Attributes "
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(!((Attrs.hasAttribute(Attributes::ByVal) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             Attrs.hasAttribute(Attributes::Nest)) ||
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            (Attrs.hasAttribute(Attributes::ByVal) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             Attrs.hasAttribute(Attributes::InReg)) ||
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            (Attrs.hasAttribute(Attributes::Nest) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             Attrs.hasAttribute(Attributes::InReg))), "Attributes "
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(!(Attrs.hasAttribute(Attributes::ZExt) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            Attrs.hasAttribute(Attributes::SExt)), "Attributes "
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(!(Attrs.hasAttribute(Attributes::ReadNone) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            Attrs.hasAttribute(Attributes::ReadOnly)), "Attributes "
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(!(Attrs.hasAttribute(Attributes::NoInline) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            Attrs.hasAttribute(Attributes::AlwaysInline)), "Attributes "
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            hasAttributes(Attributes::typeIncompatible(Ty)),
./VMCore/.svn/text-base/Verifier.cpp.svn-base:          Attributes::typeIncompatible(Ty).getAsString(), V);
./VMCore/.svn/text-base/Verifier.cpp.svn-base:    Assert1(!Attrs.hasAttribute(Attributes::ByVal) ||
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            "Attribute 'byval' does not support unsized types!", V);
./VMCore/.svn/text-base/Verifier.cpp.svn-base:    Assert1(!Attrs.hasAttribute(Attributes::ByVal),
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            "Attribute 'byval' only applies to parameters with pointer type!",
./VMCore/.svn/text-base/Verifier.cpp.svn-base:    const AttributeWithIndex &Attr = Attrs.getSlot(i);
./VMCore/.svn/text-base/Verifier.cpp.svn-base:    if (Attr.Attrs.hasAttribute(Attributes::Nest)) {
./VMCore/.svn/text-base/Verifier.cpp.svn-base:    if (Attr.Attrs.hasAttribute(Attributes::StructRet))
./VMCore/.svn/text-base/Verifier.cpp.svn-base:      Assert1(Attr.Index == 1, "Attribute sret not on first parameter!", V);
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Attributes FAttrs = Attrs.getFnAttributes();
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(!NotFn.hasAttributes(), "Attributes '" +
./VMCore/.svn/text-base/Verifier.cpp.svn-base:          Attributes::get(V->getContext(), NotFn).getAsString() +
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(!((FAttrs.hasAttribute(Attributes::ByVal) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             FAttrs.hasAttribute(Attributes::Nest)) ||
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            (FAttrs.hasAttribute(Attributes::ByVal) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             FAttrs.hasAttribute(Attributes::StructRet)) ||
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            (FAttrs.hasAttribute(Attributes::Nest) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             FAttrs.hasAttribute(Attributes::StructRet))), "Attributes "
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(!((FAttrs.hasAttribute(Attributes::ByVal) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             FAttrs.hasAttribute(Attributes::Nest)) ||
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            (FAttrs.hasAttribute(Attributes::ByVal) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             FAttrs.hasAttribute(Attributes::InReg)) ||
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            (FAttrs.hasAttribute(Attributes::Nest) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:             FAttrs.hasAttribute(Attributes::InReg))), "Attributes "
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(!(FAttrs.hasAttribute(Attributes::ZExt) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            FAttrs.hasAttribute(Attributes::SExt)), "Attributes "
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(!(FAttrs.hasAttribute(Attributes::ReadNone) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            FAttrs.hasAttribute(Attributes::ReadOnly)), "Attributes "
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(!(FAttrs.hasAttribute(Attributes::NoInline) &&
./VMCore/.svn/text-base/Verifier.cpp.svn-base:            FAttrs.hasAttribute(Attributes::AlwaysInline)), "Attributes "
./VMCore/.svn/text-base/Verifier.cpp.svn-base:static bool VerifyAttributeCount(const AttrListPtr &Attrs, unsigned Params) {
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  const AttrListPtr &Attrs = F.getAttributes();
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(VerifyAttributeCount(Attrs, FT->getNumParams()),
./VMCore/.svn/text-base/Verifier.cpp.svn-base:          "Attributes after last parameter!", &F);
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  const AttrListPtr &Attrs = CS.getAttributes();
./VMCore/.svn/text-base/Verifier.cpp.svn-base:  Assert1(VerifyAttributeCount(Attrs, CS.arg_size()),
./VMCore/.svn/text-base/Verifier.cpp.svn-base:          "Attributes after last parameter!", I);
./VMCore/.svn/text-base/Verifier.cpp.svn-base:      Attributes Attr = Attrs.getParamAttributes(Idx);
./VMCore/.svn/text-base/Verifier.cpp.svn-base:              "Attribute 'sret' cannot be used for vararg call arguments!", I);
./VMCore/.svn/entries:Attributes.cpp
./VMCore/.svn/entries:AttributesImpl.h
./VMCore/LLVMContextImpl.cpp:#include "llvm/Attributes.h"
./VMCore/LLVMContextImpl.cpp:  for (FoldingSetIterator<AttributesImpl> I = AttrsSet.begin(),
./VMCore/LLVMContextImpl.cpp:    FoldingSetIterator<AttributesImpl> Elem = I++;
./VMCore/DebugInfo.cpp:        dwarf::AttributeEncodingString(DIBasicType(DbgNode).getEncoding()))
./VMCore/Instructions.cpp:  setAttributes(CI.getAttributes());
./VMCore/Instructions.cpp:void CallInst::addAttribute(unsigned i, Attributes attr) {
./VMCore/Instructions.cpp:  AttrListPtr PAL = getAttributes();
./VMCore/Instructions.cpp:  setAttributes(PAL);
./VMCore/Instructions.cpp:void CallInst::removeAttribute(unsigned i, Attributes attr) {
./VMCore/Instructions.cpp:  AttrListPtr PAL = getAttributes();
./VMCore/Instructions.cpp:  setAttributes(PAL);
./VMCore/Instructions.cpp:bool CallInst::hasFnAttr(Attributes::AttrVal A) const {
./VMCore/Instructions.cpp:  if (AttributeList.getParamAttributes(AttrListPtr::FunctionIndex)
./VMCore/Instructions.cpp:      .hasAttribute(A))
./VMCore/Instructions.cpp:    return F->getParamAttributes(AttrListPtr::FunctionIndex).hasAttribute(A);
./VMCore/Instructions.cpp:bool CallInst::paramHasAttr(unsigned i, Attributes::AttrVal A) const {
./VMCore/Instructions.cpp:  if (AttributeList.getParamAttributes(i).hasAttribute(A))
./VMCore/Instructions.cpp:    return F->getParamAttributes(i).hasAttribute(A);
./VMCore/Instructions.cpp:  setAttributes(II.getAttributes());
./VMCore/Instructions.cpp:bool InvokeInst::hasFnAttr(Attributes::AttrVal A) const {
./VMCore/Instructions.cpp:  if (AttributeList.getParamAttributes(AttrListPtr::FunctionIndex).
./VMCore/Instructions.cpp:      hasAttribute(A))
./VMCore/Instructions.cpp:    return F->getParamAttributes(AttrListPtr::FunctionIndex).hasAttribute(A);
./VMCore/Instructions.cpp:bool InvokeInst::paramHasAttr(unsigned i, Attributes::AttrVal A) const {
./VMCore/Instructions.cpp:  if (AttributeList.getParamAttributes(i).hasAttribute(A))
./VMCore/Instructions.cpp:    return F->getParamAttributes(i).hasAttribute(A);
./VMCore/Instructions.cpp:void InvokeInst::addAttribute(unsigned i, Attributes attr) {
./VMCore/Instructions.cpp:  AttrListPtr PAL = getAttributes();
./VMCore/Instructions.cpp:  setAttributes(PAL);
./VMCore/Instructions.cpp:void InvokeInst::removeAttribute(unsigned i, Attributes attr) {
./VMCore/Instructions.cpp:  AttrListPtr PAL = getAttributes();
./VMCore/Instructions.cpp:  setAttributes(PAL);
./VMCore/Verifier.cpp:    void VerifyParameterAttrs(Attributes Attrs, Type *Ty,
./VMCore/Verifier.cpp:void Verifier::VerifyParameterAttrs(Attributes Attrs, Type *Ty,
./VMCore/Verifier.cpp:  if (!Attrs.hasAttributes())
./VMCore/Verifier.cpp:            "Attributes 'byval', 'nest', 'sret', and 'nocapture' "
./VMCore/Verifier.cpp:  Assert1(!((Attrs.hasAttribute(Attributes::ByVal) &&
./VMCore/Verifier.cpp:             Attrs.hasAttribute(Attributes::Nest)) ||
./VMCore/Verifier.cpp:            (Attrs.hasAttribute(Attributes::ByVal) &&
./VMCore/Verifier.cpp:             Attrs.hasAttribute(Attributes::StructRet)) ||
./VMCore/Verifier.cpp:            (Attrs.hasAttribute(Attributes::Nest) &&
./VMCore/Verifier.cpp:             Attrs.hasAttribute(Attributes::StructRet))), "Attributes "
./VMCore/Verifier.cpp:  Assert1(!((Attrs.hasAttribute(Attributes::ByVal) &&
./VMCore/Verifier.cpp:             Attrs.hasAttribute(Attributes::Nest)) ||
./VMCore/Verifier.cpp:            (Attrs.hasAttribute(Attributes::ByVal) &&
./VMCore/Verifier.cpp:             Attrs.hasAttribute(Attributes::InReg)) ||
./VMCore/Verifier.cpp:            (Attrs.hasAttribute(Attributes::Nest) &&
./VMCore/Verifier.cpp:             Attrs.hasAttribute(Attributes::InReg))), "Attributes "
./VMCore/Verifier.cpp:  Assert1(!(Attrs.hasAttribute(Attributes::ZExt) &&
./VMCore/Verifier.cpp:            Attrs.hasAttribute(Attributes::SExt)), "Attributes "
./VMCore/Verifier.cpp:  Assert1(!(Attrs.hasAttribute(Attributes::ReadNone) &&
./VMCore/Verifier.cpp:            Attrs.hasAttribute(Attributes::ReadOnly)), "Attributes "
./VMCore/Verifier.cpp:  Assert1(!(Attrs.hasAttribute(Attributes::NoInline) &&
./VMCore/Verifier.cpp:            Attrs.hasAttribute(Attributes::AlwaysInline)), "Attributes "
./VMCore/Verifier.cpp:            hasAttributes(Attributes::typeIncompatible(Ty)),
./VMCore/Verifier.cpp:          Attributes::typeIncompatible(Ty).getAsString(), V);
./VMCore/Verifier.cpp:    Assert1(!Attrs.hasAttribute(Attributes::ByVal) ||
./VMCore/Verifier.cpp:            "Attribute 'byval' does not support unsized types!", V);
./VMCore/Verifier.cpp:    Assert1(!Attrs.hasAttribute(Attributes::ByVal),
./VMCore/Verifier.cpp:            "Attribute 'byval' only applies to parameters with pointer type!",
./VMCore/Verifier.cpp:    const AttributeWithIndex &Attr = Attrs.getSlot(i);
./VMCore/Verifier.cpp:    if (Attr.Attrs.hasAttribute(Attributes::Nest)) {
./VMCore/Verifier.cpp:    if (Attr.Attrs.hasAttribute(Attributes::StructRet))
./VMCore/Verifier.cpp:      Assert1(Attr.Index == 1, "Attribute sret not on first parameter!", V);
./VMCore/Verifier.cpp:  Attributes FAttrs = Attrs.getFnAttributes();
./VMCore/Verifier.cpp:  Assert1(!NotFn.hasAttributes(), "Attributes '" +
./VMCore/Verifier.cpp:          Attributes::get(V->getContext(), NotFn).getAsString() +
./VMCore/Verifier.cpp:  Assert1(!((FAttrs.hasAttribute(Attributes::ByVal) &&
./VMCore/Verifier.cpp:             FAttrs.hasAttribute(Attributes::Nest)) ||
./VMCore/Verifier.cpp:            (FAttrs.hasAttribute(Attributes::ByVal) &&
./VMCore/Verifier.cpp:             FAttrs.hasAttribute(Attributes::StructRet)) ||
./VMCore/Verifier.cpp:            (FAttrs.hasAttribute(Attributes::Nest) &&
./VMCore/Verifier.cpp:             FAttrs.hasAttribute(Attributes::StructRet))), "Attributes "
./VMCore/Verifier.cpp:  Assert1(!((FAttrs.hasAttribute(Attributes::ByVal) &&
./VMCore/Verifier.cpp:             FAttrs.hasAttribute(Attributes::Nest)) ||
./VMCore/Verifier.cpp:            (FAttrs.hasAttribute(Attributes::ByVal) &&
./VMCore/Verifier.cpp:             FAttrs.hasAttribute(Attributes::InReg)) ||
./VMCore/Verifier.cpp:            (FAttrs.hasAttribute(Attributes::Nest) &&
./VMCore/Verifier.cpp:             FAttrs.hasAttribute(Attributes::InReg))), "Attributes "
./VMCore/Verifier.cpp:  Assert1(!(FAttrs.hasAttribute(Attributes::ZExt) &&
./VMCore/Verifier.cpp:            FAttrs.hasAttribute(Attributes::SExt)), "Attributes "
./VMCore/Verifier.cpp:  Assert1(!(FAttrs.hasAttribute(Attributes::ReadNone) &&
./VMCore/Verifier.cpp:            FAttrs.hasAttribute(Attributes::ReadOnly)), "Attributes "
./VMCore/Verifier.cpp:  Assert1(!(FAttrs.hasAttribute(Attributes::NoInline) &&
./VMCore/Verifier.cpp:            FAttrs.hasAttribute(Attributes::AlwaysInline)), "Attributes "
./VMCore/Verifier.cpp:static bool VerifyAttributeCount(const AttrListPtr &Attrs, unsigned Params) {
./VMCore/Verifier.cpp:  const AttrListPtr &Attrs = F.getAttributes();
./VMCore/Verifier.cpp:  Assert1(VerifyAttributeCount(Attrs, FT->getNumParams()),
./VMCore/Verifier.cpp:          "Attributes after last parameter!", &F);
./VMCore/Verifier.cpp:  const AttrListPtr &Attrs = CS.getAttributes();
./VMCore/Verifier.cpp:  Assert1(VerifyAttributeCount(Attrs, CS.arg_size()),
./VMCore/Verifier.cpp:          "Attributes after last parameter!", I);
./VMCore/Verifier.cpp:      Attributes Attr = Attrs.getParamAttributes(Idx);
./VMCore/Verifier.cpp:              "Attribute 'sret' cannot be used for vararg call arguments!", I);
./VMCore/AsmWriter.cpp:  void writeParamOperand(const Value *Operand, Attributes Attrs);
./VMCore/AsmWriter.cpp:  void printArgument(const Argument *FA, Attributes Attrs);
./VMCore/AsmWriter.cpp:                                       Attributes Attrs) {
./VMCore/AsmWriter.cpp:  if (Attrs.hasAttributes())
./VMCore/AsmWriter.cpp:  const AttrListPtr &Attrs = F->getAttributes();
./VMCore/AsmWriter.cpp:  Attributes RetAttrs = Attrs.getRetAttributes();
./VMCore/AsmWriter.cpp:  if (RetAttrs.hasAttributes())
./VMCore/AsmWriter.cpp:    Out <<  Attrs.getRetAttributes().getAsString() << ' ';
./VMCore/AsmWriter.cpp:      printArgument(I, Attrs.getParamAttributes(Idx));
./VMCore/AsmWriter.cpp:      Attributes ArgAttrs = Attrs.getParamAttributes(i+1);
./VMCore/AsmWriter.cpp:      if (ArgAttrs.hasAttributes())
./VMCore/AsmWriter.cpp:  Attributes FnAttrs = Attrs.getFnAttributes();
./VMCore/AsmWriter.cpp:  if (FnAttrs.hasAttributes())
./VMCore/AsmWriter.cpp:    Out << ' ' << Attrs.getFnAttributes().getAsString();
./VMCore/AsmWriter.cpp:                                   Attributes Attrs) {
./VMCore/AsmWriter.cpp:  if (Attrs.hasAttributes())
./VMCore/AsmWriter.cpp:    const AttrListPtr &PAL = CI->getAttributes();
./VMCore/AsmWriter.cpp:    if (PAL.getRetAttributes().hasAttributes())
./VMCore/AsmWriter.cpp:      Out << ' ' << PAL.getRetAttributes().getAsString();
./VMCore/AsmWriter.cpp:      writeParamOperand(CI->getArgOperand(op), PAL.getParamAttributes(op + 1));
./VMCore/AsmWriter.cpp:    if (PAL.getFnAttributes().hasAttributes())
./VMCore/AsmWriter.cpp:      Out << ' ' << PAL.getFnAttributes().getAsString();
./VMCore/AsmWriter.cpp:    const AttrListPtr &PAL = II->getAttributes();
./VMCore/AsmWriter.cpp:    if (PAL.getRetAttributes().hasAttributes())
./VMCore/AsmWriter.cpp:      Out << ' ' << PAL.getRetAttributes().getAsString();
./VMCore/AsmWriter.cpp:      writeParamOperand(II->getArgOperand(op), PAL.getParamAttributes(op + 1));
./VMCore/AsmWriter.cpp:    if (PAL.getFnAttributes().hasAttributes())
./VMCore/AsmWriter.cpp:      Out << ' ' << PAL.getFnAttributes().getAsString();
./VMCore/AutoUpgrade.cpp:    F->setAttributes(Intrinsic::getAttributes(F->getContext(),
./VMCore/Instruction.cpp:           CI->getAttributes() == cast<CallInst>(I)->getAttributes();
./VMCore/Instruction.cpp:           CI->getAttributes() == cast<InvokeInst>(I)->getAttributes();
./VMCore/Instruction.cpp:           CI->getAttributes() == cast<CallInst>(I)->getAttributes();
./VMCore/Instruction.cpp:           CI->getAttributes() ==
./VMCore/Instruction.cpp:             cast<InvokeInst>(I)->getAttributes();
./VMCore/Function.cpp:  return getParent()->getParamAttributes(getArgNo()+1).
./VMCore/Function.cpp:    hasAttribute(Attributes::ByVal);
./VMCore/Function.cpp:  return getParent()->getParamAttributes(getArgNo()+1).
./VMCore/Function.cpp:    hasAttribute(Attributes::Nest);
./VMCore/Function.cpp:  return getParent()->getParamAttributes(getArgNo()+1).
./VMCore/Function.cpp:    hasAttribute(Attributes::NoAlias);
./VMCore/Function.cpp:  return getParent()->getParamAttributes(getArgNo()+1).
./VMCore/Function.cpp:    hasAttribute(Attributes::NoCapture);
./VMCore/Function.cpp:  return getParent()->getParamAttributes(1).
./VMCore/Function.cpp:    hasAttribute(Attributes::StructRet);
./VMCore/Function.cpp:/// addAttr - Add a Attribute to an argument
./VMCore/Function.cpp:void Argument::addAttr(Attributes attr) {
./VMCore/Function.cpp:  getParent()->addAttribute(getArgNo() + 1, attr);
./VMCore/Function.cpp:/// removeAttr - Remove a Attribute from an argument
./VMCore/Function.cpp:void Argument::removeAttr(Attributes attr) {
./VMCore/Function.cpp:  getParent()->removeAttribute(getArgNo() + 1, attr);
./VMCore/Function.cpp:    setAttributes(Intrinsic::getAttributes(getContext(), Intrinsic::ID(IID)));
./VMCore/Function.cpp:void Function::addAttribute(unsigned i, Attributes attr) {
./VMCore/Function.cpp:  AttrListPtr PAL = getAttributes();
./VMCore/Function.cpp:  setAttributes(PAL);
./VMCore/Function.cpp:void Function::removeAttribute(unsigned i, Attributes attr) {
./VMCore/Function.cpp:  AttrListPtr PAL = getAttributes();
./VMCore/Function.cpp:  setAttributes(PAL);
./VMCore/Function.cpp:/// copyAttributesFrom - copy all additional attributes (those not needed to
./VMCore/Function.cpp:void Function::copyAttributesFrom(const GlobalValue *Src) {
./VMCore/Function.cpp:  GlobalValue::copyAttributesFrom(Src);
./VMCore/Function.cpp:  setAttributes(SrcF->getAttributes());
./VMCore/Function.cpp:/// This defines the "Intrinsic::getAttributes(ID id)" method.
./VMCore/Attributes.cpp://===-- Attributes.cpp - Implement AttributesList -------------------------===//
./VMCore/Attributes.cpp:// This file implements the Attributes, AttributeImpl, AttrBuilder,
./VMCore/Attributes.cpp:// AttributeListImpl, and AttrListPtr classes.
./VMCore/Attributes.cpp:#include "llvm/Attributes.h"
./VMCore/Attributes.cpp:#include "AttributesImpl.h"
./VMCore/Attributes.cpp:// Attributes Implementation
./VMCore/Attributes.cpp:Attributes Attributes::get(LLVMContext &Context, ArrayRef<AttrVal> Vals) {
./VMCore/Attributes.cpp:    B.addAttribute(*I);
./VMCore/Attributes.cpp:  return Attributes::get(Context, B);
./VMCore/Attributes.cpp:Attributes Attributes::get(LLVMContext &Context, AttrBuilder &B) {
./VMCore/Attributes.cpp:  // If there are no attributes, return an empty Attributes class.
./VMCore/Attributes.cpp:  if (!B.hasAttributes())
./VMCore/Attributes.cpp:    return Attributes();
./VMCore/Attributes.cpp:  AttributesImpl *PA = pImpl->AttrsSet.FindNodeOrInsertPos(ID, InsertPoint);
./VMCore/Attributes.cpp:    PA = new AttributesImpl(B.Raw());
./VMCore/Attributes.cpp:  // Return the AttributesList that we found or created.
./VMCore/Attributes.cpp:  return Attributes(PA);
./VMCore/Attributes.cpp:bool Attributes::hasAttribute(AttrVal Val) const {
./VMCore/Attributes.cpp:  return Attrs && Attrs->hasAttribute(Val);
./VMCore/Attributes.cpp:bool Attributes::hasAttributes() const {
./VMCore/Attributes.cpp:  return Attrs && Attrs->hasAttributes();
./VMCore/Attributes.cpp:bool Attributes::hasAttributes(const Attributes &A) const {
./VMCore/Attributes.cpp:  return Attrs && Attrs->hasAttributes(A);
./VMCore/Attributes.cpp:unsigned Attributes::getAlignment() const {
./VMCore/Attributes.cpp:  if (!hasAttribute(Attributes::Alignment))
./VMCore/Attributes.cpp:unsigned Attributes::getStackAlignment() const {
./VMCore/Attributes.cpp:  if (!hasAttribute(Attributes::StackAlignment))
./VMCore/Attributes.cpp:uint64_t Attributes::Raw() const {
./VMCore/Attributes.cpp:Attributes Attributes::typeIncompatible(Type *Ty) {
./VMCore/Attributes.cpp:    // Attributes that only apply to integers.
./VMCore/Attributes.cpp:    Incompatible.addAttribute(Attributes::SExt)
./VMCore/Attributes.cpp:      .addAttribute(Attributes::ZExt);
./VMCore/Attributes.cpp:    // Attributes that only apply to pointers.
./VMCore/Attributes.cpp:    Incompatible.addAttribute(Attributes::ByVal)
./VMCore/Attributes.cpp:      .addAttribute(Attributes::Nest)
./VMCore/Attributes.cpp:      .addAttribute(Attributes::NoAlias)
./VMCore/Attributes.cpp:      .addAttribute(Attributes::NoCapture)
./VMCore/Attributes.cpp:      .addAttribute(Attributes::StructRet);
./VMCore/Attributes.cpp:  return Attributes::get(Ty->getContext(), Incompatible);
./VMCore/Attributes.cpp:/// encodeLLVMAttributesForBitcode - This returns an integer containing an
./VMCore/Attributes.cpp:uint64_t Attributes::encodeLLVMAttributesForBitcode(Attributes Attrs) {
./VMCore/Attributes.cpp:  if (Attrs.hasAttribute(Attributes::Alignment))
./VMCore/Attributes.cpp:/// decodeLLVMAttributesForBitcode - This returns an attribute bitset containing
./VMCore/Attributes.cpp:/// function must stay in sync with 'encodeLLVMAttributesForBitcode'.
./VMCore/Attributes.cpp:Attributes Attributes::decodeLLVMAttributesForBitcode(LLVMContext &C,
./VMCore/Attributes.cpp:  return Attributes::get(C, B);
./VMCore/Attributes.cpp:std::string Attributes::getAsString() const {
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::ZExt))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::SExt))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::NoReturn))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::NoUnwind))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::UWTable))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::ReturnsTwice))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::InReg))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::NoAlias))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::NoCapture))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::StructRet))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::ByVal))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::Nest))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::ReadNone))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::ReadOnly))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::OptimizeForSize))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::NoInline))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::InlineHint))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::AlwaysInline))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::StackProtect))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::StackProtectReq))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::NoRedZone))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::NoImplicitFloat))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::Naked))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::NonLazyBind))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::AddressSafety))
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::StackAlignment)) {
./VMCore/Attributes.cpp:  if (hasAttribute(Attributes::Alignment)) {
./VMCore/Attributes.cpp:AttrBuilder &AttrBuilder::addAttribute(Attributes::AttrVal Val){
./VMCore/Attributes.cpp:  Bits |= AttributesImpl::getAttrMask(Val);
./VMCore/Attributes.cpp:AttrBuilder &AttrBuilder::removeAttribute(Attributes::AttrVal Val) {
./VMCore/Attributes.cpp:  Bits &= ~AttributesImpl::getAttrMask(Val);
./VMCore/Attributes.cpp:AttrBuilder &AttrBuilder::addAttributes(const Attributes &A) {
./VMCore/Attributes.cpp:AttrBuilder &AttrBuilder::removeAttributes(const Attributes &A){
./VMCore/Attributes.cpp:bool AttrBuilder::hasAttribute(Attributes::AttrVal A) const {
./VMCore/Attributes.cpp:  return Bits & AttributesImpl::getAttrMask(A);
./VMCore/Attributes.cpp:bool AttrBuilder::hasAttributes() const {
./VMCore/Attributes.cpp:bool AttrBuilder::hasAttributes(const Attributes &A) const {
./VMCore/Attributes.cpp:  return Bits & AttributesImpl::getAttrMask(Attributes::Alignment);
./VMCore/Attributes.cpp:    (((Bits & AttributesImpl::getAttrMask(Attributes::Alignment)) >> 16) - 1);
./VMCore/Attributes.cpp:    (((Bits & AttributesImpl::getAttrMask(Attributes::StackAlignment))>>26)-1);
./VMCore/Attributes.cpp:// AttributeImpl Definition
./VMCore/Attributes.cpp:uint64_t AttributesImpl::getAttrMask(uint64_t Val) {
./VMCore/Attributes.cpp:  case Attributes::None:            return 0;
./VMCore/Attributes.cpp:  case Attributes::ZExt:            return 1 << 0;
./VMCore/Attributes.cpp:  case Attributes::SExt:            return 1 << 1;
./VMCore/Attributes.cpp:  case Attributes::NoReturn:        return 1 << 2;
./VMCore/Attributes.cpp:  case Attributes::InReg:           return 1 << 3;
./VMCore/Attributes.cpp:  case Attributes::StructRet:       return 1 << 4;
./VMCore/Attributes.cpp:  case Attributes::NoUnwind:        return 1 << 5;
./VMCore/Attributes.cpp:  case Attributes::NoAlias:         return 1 << 6;
./VMCore/Attributes.cpp:  case Attributes::ByVal:           return 1 << 7;
./VMCore/Attributes.cpp:  case Attributes::Nest:            return 1 << 8;
./VMCore/Attributes.cpp:  case Attributes::ReadNone:        return 1 << 9;
./VMCore/Attributes.cpp:  case Attributes::ReadOnly:        return 1 << 10;
./VMCore/Attributes.cpp:  case Attributes::NoInline:        return 1 << 11;
./VMCore/Attributes.cpp:  case Attributes::AlwaysInline:    return 1 << 12;
./VMCore/Attributes.cpp:  case Attributes::OptimizeForSize: return 1 << 13;
./VMCore/Attributes.cpp:  case Attributes::StackProtect:    return 1 << 14;
./VMCore/Attributes.cpp:  case Attributes::StackProtectReq: return 1 << 15;
./VMCore/Attributes.cpp:  case Attributes::Alignment:       return 31 << 16;
./VMCore/Attributes.cpp:  case Attributes::NoCapture:       return 1 << 21;
./VMCore/Attributes.cpp:  case Attributes::NoRedZone:       return 1 << 22;
./VMCore/Attributes.cpp:  case Attributes::NoImplicitFloat: return 1 << 23;
./VMCore/Attributes.cpp:  case Attributes::Naked:           return 1 << 24;
./VMCore/Attributes.cpp:  case Attributes::InlineHint:      return 1 << 25;
./VMCore/Attributes.cpp:  case Attributes::StackAlignment:  return 7 << 26;
./VMCore/Attributes.cpp:  case Attributes::ReturnsTwice:    return 1 << 29;
./VMCore/Attributes.cpp:  case Attributes::UWTable:         return 1 << 30;
./VMCore/Attributes.cpp:  case Attributes::NonLazyBind:     return 1U << 31;
./VMCore/Attributes.cpp:  case Attributes::AddressSafety:   return 1ULL << 32;
./VMCore/Attributes.cpp:bool AttributesImpl::hasAttribute(uint64_t A) const {
./VMCore/Attributes.cpp:bool AttributesImpl::hasAttributes() const {
./VMCore/Attributes.cpp:bool AttributesImpl::hasAttributes(const Attributes &A) const {
./VMCore/Attributes.cpp:uint64_t AttributesImpl::getAlignment() const {
./VMCore/Attributes.cpp:  return Bits & getAttrMask(Attributes::Alignment);
./VMCore/Attributes.cpp:uint64_t AttributesImpl::getStackAlignment() const {
./VMCore/Attributes.cpp:  return Bits & getAttrMask(Attributes::StackAlignment);
./VMCore/Attributes.cpp:// AttributeListImpl Definition
./VMCore/Attributes.cpp:  class AttributeListImpl;
./VMCore/Attributes.cpp:static ManagedStatic<FoldingSet<AttributeListImpl> > AttributesLists;
./VMCore/Attributes.cpp:class AttributeListImpl : public FoldingSetNode {
./VMCore/Attributes.cpp:  // AttributesList is uniqued, these should not be publicly available.
./VMCore/Attributes.cpp:  void operator=(const AttributeListImpl &) LLVM_DELETED_FUNCTION;
./VMCore/Attributes.cpp:  AttributeListImpl(const AttributeListImpl &) LLVM_DELETED_FUNCTION;
./VMCore/Attributes.cpp:  ~AttributeListImpl();                        // Private implementation
./VMCore/Attributes.cpp:  SmallVector<AttributeWithIndex, 4> Attrs;
./VMCore/Attributes.cpp:  AttributeListImpl(ArrayRef<AttributeWithIndex> attrs)
./VMCore/Attributes.cpp:    if (!AttributesLists.isConstructed())
./VMCore/Attributes.cpp:  static void Profile(FoldingSetNodeID &ID, ArrayRef<AttributeWithIndex> Attrs){
./VMCore/Attributes.cpp:AttributeListImpl::~AttributeListImpl() {
./VMCore/Attributes.cpp:  AttributesLists->RemoveNode(this);
./VMCore/Attributes.cpp:AttrListPtr AttrListPtr::get(ArrayRef<AttributeWithIndex> Attrs) {
./VMCore/Attributes.cpp:  // If there are no attributes then return a null AttributesList pointer.
./VMCore/Attributes.cpp:    assert(Attrs[i].Attrs.hasAttributes() &&
./VMCore/Attributes.cpp:           "Misordered AttributesList!");
./VMCore/Attributes.cpp:  AttributeListImpl::Profile(ID, Attrs);
./VMCore/Attributes.cpp:  AttributeListImpl *PAL =
./VMCore/Attributes.cpp:    AttributesLists->FindNodeOrInsertPos(ID, InsertPos);
./VMCore/Attributes.cpp:    PAL = new AttributeListImpl(Attrs);
./VMCore/Attributes.cpp:    AttributesLists->InsertNode(PAL, InsertPos);
./VMCore/Attributes.cpp:  // Return the AttributesList that we found or created.
./VMCore/Attributes.cpp:AttrListPtr::AttrListPtr(AttributeListImpl *LI) : AttrList(LI) {
./VMCore/Attributes.cpp:/// getSlot - Return the AttributeWithIndex at the specified slot.  This
./VMCore/Attributes.cpp:const AttributeWithIndex &AttrListPtr::getSlot(unsigned Slot) const {
./VMCore/Attributes.cpp:/// getAttributes - The attributes for the specified index are returned.
./VMCore/Attributes.cpp:/// Attributes for the result are denoted with Idx = 0.  Function notes are
./VMCore/Attributes.cpp:Attributes AttrListPtr::getAttributes(unsigned Idx) const {
./VMCore/Attributes.cpp:  if (AttrList == 0) return Attributes();
./VMCore/Attributes.cpp:  const SmallVector<AttributeWithIndex, 4> &Attrs = AttrList->Attrs;
./VMCore/Attributes.cpp:  return Attributes();
./VMCore/Attributes.cpp:bool AttrListPtr::hasAttrSomewhere(Attributes::AttrVal Attr) const {
./VMCore/Attributes.cpp:  const SmallVector<AttributeWithIndex, 4> &Attrs = AttrList->Attrs;
./VMCore/Attributes.cpp:    if (Attrs[i].Attrs.hasAttribute(Attr))
./VMCore/Attributes.cpp:Attributes &AttrListPtr::getAttributesAtIndex(unsigned i) const {
./VMCore/Attributes.cpp:                                 Attributes Attrs) const {
./VMCore/Attributes.cpp:  Attributes OldAttrs = getAttributes(Idx);
./VMCore/Attributes.cpp:    AttrBuilder(OldAttrs).addAttributes(Attrs);
./VMCore/Attributes.cpp:  SmallVector<AttributeWithIndex, 8> NewAttrList;
./VMCore/Attributes.cpp:    NewAttrList.push_back(AttributeWithIndex::get(Idx, Attrs));
./VMCore/Attributes.cpp:    const SmallVector<AttributeWithIndex, 4> &OldAttrList = AttrList->Attrs;
./VMCore/Attributes.cpp:        Attributes::get(C, AttrBuilder(Attrs).
./VMCore/Attributes.cpp:                        addAttributes(OldAttrList[i].Attrs));
./VMCore/Attributes.cpp:    NewAttrList.push_back(AttributeWithIndex::get(Idx, Attrs));
./VMCore/Attributes.cpp:                                    Attributes Attrs) const {
./VMCore/Attributes.cpp:  assert(!Attrs.hasAttribute(Attributes::Alignment) &&
./VMCore/Attributes.cpp:  Attributes OldAttrs = getAttributes(Idx);
./VMCore/Attributes.cpp:    AttrBuilder(OldAttrs).removeAttributes(Attrs);
./VMCore/Attributes.cpp:  SmallVector<AttributeWithIndex, 8> NewAttrList;
./VMCore/Attributes.cpp:  const SmallVector<AttributeWithIndex, 4> &OldAttrList = AttrList->Attrs;
./VMCore/Attributes.cpp:  assert(OldAttrList[i].Index == Idx && "Attribute isn't set?");
./VMCore/Attributes.cpp:  Attrs = Attributes::get(C, AttrBuilder(OldAttrList[i].Attrs).
./VMCore/Attributes.cpp:                          removeAttributes(Attrs));
./VMCore/Attributes.cpp:  if (Attrs.hasAttributes()) // If any attributes left for this param, add them.
./VMCore/Attributes.cpp:    NewAttrList.push_back(AttributeWithIndex::get(Idx, Attrs));
./VMCore/Attributes.cpp:    const AttributeWithIndex &PAWI = getSlot(i);
./VMCore/Core.cpp:#include "llvm/Attributes.h"
./VMCore/Core.cpp:void LLVMAddFunctionAttr(LLVMValueRef Fn, LLVMAttribute PA) {
./VMCore/Core.cpp:  const AttrListPtr PAL = Func->getAttributes();
./VMCore/Core.cpp:                Attributes::get(Func->getContext(), B));
./VMCore/Core.cpp:  Func->setAttributes(PALnew);
./VMCore/Core.cpp:void LLVMRemoveFunctionAttr(LLVMValueRef Fn, LLVMAttribute PA) {
./VMCore/Core.cpp:  const AttrListPtr PAL = Func->getAttributes();
./VMCore/Core.cpp:                   Attributes::get(Func->getContext(), B));
./VMCore/Core.cpp:  Func->setAttributes(PALnew);
./VMCore/Core.cpp:LLVMAttribute LLVMGetFunctionAttr(LLVMValueRef Fn) {
./VMCore/Core.cpp:  const AttrListPtr PAL = Func->getAttributes();
./VMCore/Core.cpp:  Attributes attr = PAL.getFnAttributes();
./VMCore/Core.cpp:  return (LLVMAttribute)attr.Raw();
./VMCore/Core.cpp:void LLVMAddAttribute(LLVMValueRef Arg, LLVMAttribute PA) {
./VMCore/Core.cpp:  A->addAttr(Attributes::get(A->getContext(), B));
./VMCore/Core.cpp:void LLVMRemoveAttribute(LLVMValueRef Arg, LLVMAttribute PA) {
./VMCore/Core.cpp:  A->removeAttr(Attributes::get(A->getContext(), B));
./VMCore/Core.cpp:LLVMAttribute LLVMGetAttribute(LLVMValueRef Arg) {
./VMCore/Core.cpp:  Attributes attr = A->getParent()->getAttributes().getParamAttributes(
./VMCore/Core.cpp:  return (LLVMAttribute)attr.Raw();
./VMCore/Core.cpp:  unwrap<Argument>(Arg)->addAttr(Attributes::
./VMCore/Core.cpp:void LLVMAddInstrAttribute(LLVMValueRef Instr, unsigned index, 
./VMCore/Core.cpp:                           LLVMAttribute PA) {
./VMCore/Core.cpp:  Call.setAttributes(
./VMCore/Core.cpp:    Call.getAttributes().addAttr(Call->getContext(), index,
./VMCore/Core.cpp:                                 Attributes::get(Call->getContext(), B)));
./VMCore/Core.cpp:void LLVMRemoveInstrAttribute(LLVMValueRef Instr, unsigned index, 
./VMCore/Core.cpp:                              LLVMAttribute PA) {
./VMCore/Core.cpp:  Call.setAttributes(
./VMCore/Core.cpp:    Call.getAttributes().removeAttr(Call->getContext(), index,
./VMCore/Core.cpp:                                    Attributes::get(Call->getContext(), B)));
./VMCore/Core.cpp:  Call.setAttributes(Call.getAttributes().addAttr(Call->getContext(), index,
./VMCore/Core.cpp:                                       Attributes::get(Call->getContext(), B)));
./VMCore/CMakeLists.txt:  Attributes.cpp
./VMCore/DIBuilder.cpp:                                 unsigned PropertyAttributes) {
./VMCore/DIBuilder.cpp:    ConstantInt::get(Type::getInt32Ty(VMContext), PropertyAttributes)
./VMCore/DIBuilder.cpp:                                             unsigned PropertyAttributes,
./VMCore/DIBuilder.cpp:    ConstantInt::get(Type::getInt32Ty(VMContext), PropertyAttributes),
./VMCore/LLVMContextImpl.h:#include "AttributesImpl.h"
./VMCore/LLVMContextImpl.h:  FoldingSet<AttributesImpl> AttrsSet;
./VMCore/AttributesImpl.h://===-- AttributesImpl.h - Attributes Internals -----------------*- C++ -*-===//
./VMCore/AttributesImpl.h:class Attributes;
./VMCore/AttributesImpl.h:class AttributesImpl : public FoldingSetNode {
./VMCore/AttributesImpl.h:  AttributesImpl(uint64_t bits) : Bits(bits) {}
./VMCore/AttributesImpl.h:  bool hasAttribute(uint64_t A) const;
./VMCore/AttributesImpl.h:  bool hasAttributes() const;
./VMCore/AttributesImpl.h:  bool hasAttributes(const Attributes &A) const;
./VMCore/Globals.cpp:/// copyAttributesFrom - copy all additional attributes (those not needed to
./VMCore/Globals.cpp:void GlobalValue::copyAttributesFrom(const GlobalValue *Src) {
./VMCore/Globals.cpp:/// copyAttributesFrom - copy all additional attributes (those not needed to
./VMCore/Globals.cpp:void GlobalVariable::copyAttributesFrom(const GlobalValue *Src) {
./VMCore/Globals.cpp:  GlobalValue::copyAttributesFrom(Src);
./VMCore/Module.cpp:                                      AttrListPtr AttributeList) {
./VMCore/Module.cpp:      New->setAttributes(AttributeList);
./VMCore/Module.cpp:                                             AttrListPtr AttributeList) {
./VMCore/Module.cpp:    New->setAttributes(AttributeList);
./VMCore/Module.cpp:                                      AttrListPtr AttributeList,
./VMCore/Module.cpp:                             AttributeList);
./VMCore/tags:ALMutex	Attributes.cpp	/^static ManagedStatic<sys::SmartMutex<true> > ALMutex;$/;"	m	namespace:llvm	file:
./VMCore/tags:AddRef	Attributes.cpp	/^  void AddRef() {$/;"	f	class:llvm::AttributeListImpl
./VMCore/tags:AttrListPtr	Attributes.cpp	/^AttrListPtr::AttrListPtr(AttributeListImpl *LI) : AttrList(LI) {$/;"	f	class:AttrListPtr
./VMCore/tags:AttrListPtr	Attributes.cpp	/^AttrListPtr::AttrListPtr(const AttrListPtr &P) : AttrList(P.AttrList) {$/;"	f	class:AttrListPtr
./VMCore/tags:AttributeListImpl	Attributes.cpp	/^  AttributeListImpl(ArrayRef<AttributeWithIndex> attrs)$/;"	f	class:llvm::AttributeListImpl
./VMCore/tags:AttributeListImpl	Attributes.cpp	/^class AttributeListImpl : public FoldingSetNode {$/;"	c	namespace:llvm	file:
./VMCore/tags:AttributesImpl	AttributesImpl.h	/^  AttributesImpl(uint64_t bits) : Bits(bits) {}$/;"	f	class:llvm::AttributesImpl
./VMCore/tags:AttributesImpl	AttributesImpl.h	/^class AttributesImpl : public FoldingSetNode {$/;"	c	namespace:llvm
./VMCore/tags:AttributesLists	Attributes.cpp	/^static ManagedStatic<FoldingSet<AttributeListImpl> > AttributesLists;$/;"	v	file:
./VMCore/tags:Attrs	Attributes.cpp	/^  SmallVector<AttributeWithIndex, 4> Attrs;$/;"	m	class:llvm::AttributeListImpl	file:
./VMCore/tags:AttrsSet	LLVMContextImpl.h	/^  FoldingSet<AttributesImpl> AttrsSet;$/;"	m	class:llvm::LLVMContextImpl
./VMCore/tags:Bits	AttributesImpl.h	/^  uint64_t Bits;                \/\/ FIXME: We will be expanding this.$/;"	m	class:llvm::AttributesImpl
./VMCore/tags:DropRef	Attributes.cpp	/^  void DropRef() {$/;"	f	class:llvm::AttributeListImpl
./VMCore/tags:LLVMAddAttribute	Core.cpp	/^void LLVMAddAttribute(LLVMValueRef Arg, LLVMAttribute PA) {$/;"	f
./VMCore/tags:LLVMAddFunctionAttr	Core.cpp	/^void LLVMAddFunctionAttr(LLVMValueRef Fn, LLVMAttribute PA) {$/;"	f
./VMCore/tags:LLVMAddInstrAttribute	Core.cpp	/^void LLVMAddInstrAttribute(LLVMValueRef Instr, unsigned index, $/;"	f
./VMCore/tags:LLVMGetAttribute	Core.cpp	/^LLVMAttribute LLVMGetAttribute(LLVMValueRef Arg) {$/;"	f
./VMCore/tags:LLVMGetFunctionAttr	Core.cpp	/^LLVMAttribute LLVMGetFunctionAttr(LLVMValueRef Fn) {$/;"	f
./VMCore/tags:LLVMRemoveAttribute	Core.cpp	/^void LLVMRemoveAttribute(LLVMValueRef Arg, LLVMAttribute PA) {$/;"	f
./VMCore/tags:LLVMRemoveFunctionAttr	Core.cpp	/^void LLVMRemoveFunctionAttr(LLVMValueRef Fn, LLVMAttribute PA) {$/;"	f
./VMCore/tags:LLVMRemoveInstrAttribute	Core.cpp	/^void LLVMRemoveInstrAttribute(LLVMValueRef Instr, unsigned index, $/;"	f
./VMCore/tags:LLVM_ATTRIBUTESIMPL_H	AttributesImpl.h	16;"	d
./VMCore/tags:LLVM_DELETED_FUNCTION	Attributes.cpp	/^  AttributeListImpl(const AttributeListImpl &) LLVM_DELETED_FUNCTION;$/;"	m	class:llvm::AttributeListImpl	file:
./VMCore/tags:LLVM_DELETED_FUNCTION	Attributes.cpp	/^  void operator=(const AttributeListImpl &) LLVM_DELETED_FUNCTION;$/;"	m	class:llvm::AttributeListImpl	file:
./VMCore/tags:Profile	Attributes.cpp	/^  static void Profile(FoldingSetNodeID &ID, ArrayRef<AttributeWithIndex> Attrs){$/;"	f	class:llvm::AttributeListImpl
./VMCore/tags:Profile	Attributes.cpp	/^  void Profile(FoldingSetNodeID &ID) const {$/;"	f	class:llvm::AttributeListImpl
./VMCore/tags:Profile	AttributesImpl.h	/^  static void Profile(FoldingSetNodeID &ID, uint64_t Bits) {$/;"	f	class:llvm::AttributesImpl
./VMCore/tags:Profile	AttributesImpl.h	/^  void Profile(FoldingSetNodeID &ID) const {$/;"	f	class:llvm::AttributesImpl
./VMCore/tags:Raw	Attributes.cpp	/^uint64_t Attributes::Raw() const {$/;"	f	class:Attributes
./VMCore/tags:Raw	AttributesImpl.h	/^  uint64_t Raw() const { return Bits; } \/\/ FIXME: Remove.$/;"	f	class:llvm::AttributesImpl
./VMCore/tags:RefCount	Attributes.cpp	/^  sys::cas_flag RefCount;$/;"	m	class:llvm::AttributeListImpl	file:
./VMCore/tags:VerifyAttributeCount	Verifier.cpp	/^static bool VerifyAttributeCount(const AttrListPtr &Attrs, unsigned Params) {$/;"	f	file:
./VMCore/tags:VerifyParameterAttrs	Verifier.cpp	/^void Verifier::VerifyParameterAttrs(Attributes Attrs, Type *Ty,$/;"	f	class:Verifier
./VMCore/tags:addAlignmentAttr	Attributes.cpp	/^AttrBuilder &AttrBuilder::addAlignmentAttr(unsigned Align) {$/;"	f	class:AttrBuilder
./VMCore/tags:addAttr	Attributes.cpp	/^AttrListPtr AttrListPtr::addAttr(LLVMContext &C, unsigned Idx,$/;"	f	class:AttrListPtr
./VMCore/tags:addAttr	Function.cpp	/^void Argument::addAttr(Attributes attr) {$/;"	f	class:Argument
./VMCore/tags:addAttribute	Attributes.cpp	/^AttrBuilder &AttrBuilder::addAttribute(Attributes::AttrVal Val){$/;"	f	class:AttrBuilder
./VMCore/tags:addAttribute	Function.cpp	/^void Function::addAttribute(unsigned i, Attributes attr) {$/;"	f	class:Function
./VMCore/tags:addAttribute	Instructions.cpp	/^void CallInst::addAttribute(unsigned i, Attributes attr) {$/;"	f	class:CallInst
./VMCore/tags:addAttribute	Instructions.cpp	/^void InvokeInst::addAttribute(unsigned i, Attributes attr) {$/;"	f	class:InvokeInst
./VMCore/tags:addAttributes	Attributes.cpp	/^AttrBuilder &AttrBuilder::addAttributes(const Attributes &A) {$/;"	f	class:AttrBuilder
./VMCore/tags:addRawValue	Attributes.cpp	/^AttrBuilder &AttrBuilder::addRawValue(uint64_t Val) {$/;"	f	class:AttrBuilder
./VMCore/tags:addStackAlignmentAttr	Attributes.cpp	/^AttrBuilder &AttrBuilder::addStackAlignmentAttr(unsigned Align){$/;"	f	class:AttrBuilder
./VMCore/tags:copyAttributesFrom	Function.cpp	/^void Function::copyAttributesFrom(const GlobalValue *Src) {$/;"	f	class:Function
./VMCore/tags:copyAttributesFrom	Globals.cpp	/^void GlobalValue::copyAttributesFrom(const GlobalValue *Src) {$/;"	f	class:GlobalValue
./VMCore/tags:copyAttributesFrom	Globals.cpp	/^void GlobalVariable::copyAttributesFrom(const GlobalValue *Src) {$/;"	f	class:GlobalVariable
./VMCore/tags:decodeLLVMAttributesForBitcode	Attributes.cpp	/^Attributes Attributes::decodeLLVMAttributesForBitcode(LLVMContext &C,$/;"	f	class:Attributes
./VMCore/tags:dump	Attributes.cpp	/^void AttrListPtr::dump() const {$/;"	f	class:AttrListPtr
./VMCore/tags:encodeLLVMAttributesForBitcode	Attributes.cpp	/^uint64_t Attributes::encodeLLVMAttributesForBitcode(Attributes Attrs) {$/;"	f	class:Attributes
./VMCore/tags:get	Attributes.cpp	/^AttrListPtr AttrListPtr::get(ArrayRef<AttributeWithIndex> Attrs) {$/;"	f	class:AttrListPtr
./VMCore/tags:get	Attributes.cpp	/^Attributes Attributes::get(LLVMContext &Context, ArrayRef<AttrVal> Vals) {$/;"	f	class:Attributes
./VMCore/tags:get	Attributes.cpp	/^Attributes Attributes::get(LLVMContext &Context, AttrBuilder &B) {$/;"	f	class:Attributes
./VMCore/tags:getAlignment	Attributes.cpp	/^uint64_t AttrBuilder::getAlignment() const {$/;"	f	class:AttrBuilder
./VMCore/tags:getAlignment	Attributes.cpp	/^uint64_t AttributesImpl::getAlignment() const {$/;"	f	class:AttributesImpl
./VMCore/tags:getAlignment	Attributes.cpp	/^unsigned Attributes::getAlignment() const {$/;"	f	class:Attributes
./VMCore/tags:getAsString	Attributes.cpp	/^std::string Attributes::getAsString() const {$/;"	f	class:Attributes
./VMCore/tags:getAttrMask	Attributes.cpp	/^uint64_t AttributesImpl::getAttrMask(uint64_t Val) {$/;"	f	class:AttributesImpl
./VMCore/tags:getAttributes	Attributes.cpp	/^Attributes AttrListPtr::getAttributes(unsigned Idx) const {$/;"	f	class:AttrListPtr
./VMCore/tags:getAttributesAtIndex	Attributes.cpp	/^Attributes &AttrListPtr::getAttributesAtIndex(unsigned i) const {$/;"	f	class:AttrListPtr
./VMCore/tags:getNumAttrs	Attributes.cpp	/^unsigned AttrListPtr::getNumAttrs() const {$/;"	f	class:AttrListPtr
./VMCore/tags:getNumSlots	Attributes.cpp	/^unsigned AttrListPtr::getNumSlots() const {$/;"	f	class:AttrListPtr
./VMCore/tags:getSlot	Attributes.cpp	/^const AttributeWithIndex &AttrListPtr::getSlot(unsigned Slot) const {$/;"	f	class:AttrListPtr
./VMCore/tags:getStackAlignment	Attributes.cpp	/^uint64_t AttrBuilder::getStackAlignment() const {$/;"	f	class:AttrBuilder
./VMCore/tags:getStackAlignment	Attributes.cpp	/^uint64_t AttributesImpl::getStackAlignment() const {$/;"	f	class:AttributesImpl
./VMCore/tags:getStackAlignment	Attributes.cpp	/^unsigned Attributes::getStackAlignment() const {$/;"	f	class:Attributes
./VMCore/tags:hasAlignmentAttr	Attributes.cpp	/^bool AttrBuilder::hasAlignmentAttr() const {$/;"	f	class:AttrBuilder
./VMCore/tags:hasAttrSomewhere	Attributes.cpp	/^bool AttrListPtr::hasAttrSomewhere(Attributes::AttrVal Attr) const {$/;"	f	class:AttrListPtr
./VMCore/tags:hasAttribute	Attributes.cpp	/^bool AttrBuilder::hasAttribute(Attributes::AttrVal A) const {$/;"	f	class:AttrBuilder
./VMCore/tags:hasAttribute	Attributes.cpp	/^bool Attributes::hasAttribute(AttrVal Val) const {$/;"	f	class:Attributes
./VMCore/tags:hasAttribute	Attributes.cpp	/^bool AttributesImpl::hasAttribute(uint64_t A) const {$/;"	f	class:AttributesImpl
./VMCore/tags:hasAttributes	Attributes.cpp	/^bool AttrBuilder::hasAttributes() const {$/;"	f	class:AttrBuilder
./VMCore/tags:hasAttributes	Attributes.cpp	/^bool AttrBuilder::hasAttributes(const Attributes &A) const {$/;"	f	class:AttrBuilder
./VMCore/tags:hasAttributes	Attributes.cpp	/^bool Attributes::hasAttributes() const {$/;"	f	class:Attributes
./VMCore/tags:hasAttributes	Attributes.cpp	/^bool Attributes::hasAttributes(const Attributes &A) const {$/;"	f	class:Attributes
./VMCore/tags:hasAttributes	Attributes.cpp	/^bool AttributesImpl::hasAttributes() const {$/;"	f	class:AttributesImpl
./VMCore/tags:hasAttributes	Attributes.cpp	/^bool AttributesImpl::hasAttributes(const Attributes &A) const {$/;"	f	class:AttributesImpl
./VMCore/tags:hasFnAttr	Instructions.cpp	/^bool CallInst::hasFnAttr(Attributes::AttrVal A) const {$/;"	f	class:CallInst
./VMCore/tags:hasFnAttr	Instructions.cpp	/^bool InvokeInst::hasFnAttr(Attributes::AttrVal A) const {$/;"	f	class:InvokeInst
./VMCore/tags:llvm	Attributes.cpp	/^namespace llvm {$/;"	n	file:
./VMCore/tags:llvm	AttributesImpl.h	/^namespace llvm {$/;"	n
./VMCore/tags:operator =	Attributes.cpp	/^const AttrListPtr &AttrListPtr::operator=(const AttrListPtr &RHS) {$/;"	f	class:AttrListPtr
./VMCore/tags:paramHasAttr	Instructions.cpp	/^bool CallInst::paramHasAttr(unsigned i, Attributes::AttrVal A) const {$/;"	f	class:CallInst
./VMCore/tags:paramHasAttr	Instructions.cpp	/^bool InvokeInst::paramHasAttr(unsigned i, Attributes::AttrVal A) const {$/;"	f	class:InvokeInst
./VMCore/tags:removeAttr	Attributes.cpp	/^AttrListPtr AttrListPtr::removeAttr(LLVMContext &C, unsigned Idx,$/;"	f	class:AttrListPtr
./VMCore/tags:removeAttr	Function.cpp	/^void Argument::removeAttr(Attributes attr) {$/;"	f	class:Argument
./VMCore/tags:removeAttribute	Attributes.cpp	/^AttrBuilder &AttrBuilder::removeAttribute(Attributes::AttrVal Val) {$/;"	f	class:AttrBuilder
./VMCore/tags:removeAttribute	Function.cpp	/^void Function::removeAttribute(unsigned i, Attributes attr) {$/;"	f	class:Function
./VMCore/tags:removeAttribute	Instructions.cpp	/^void CallInst::removeAttribute(unsigned i, Attributes attr) {$/;"	f	class:CallInst
./VMCore/tags:removeAttribute	Instructions.cpp	/^void InvokeInst::removeAttribute(unsigned i, Attributes attr) {$/;"	f	class:InvokeInst
./VMCore/tags:removeAttributes	Attributes.cpp	/^AttrBuilder &AttrBuilder::removeAttributes(const Attributes &A){$/;"	f	class:AttrBuilder
./VMCore/tags:typeIncompatible	Attributes.cpp	/^Attributes Attributes::typeIncompatible(Type *Ty) {$/;"	f	class:Attributes
./VMCore/tags:~AttrListPtr	Attributes.cpp	/^AttrListPtr::~AttrListPtr() {$/;"	f	class:AttrListPtr
./VMCore/tags:~AttributeListImpl	Attributes.cpp	/^AttributeListImpl::~AttributeListImpl() {$/;"	f	class:AttributeListImpl
